
%pythoncode %{
import os
i_m_p="IMP_MODULE_PATH"
if i_m_p in os.environ.keys():
  __path__.insert(0, os.environ[i_m_p])

def _forward_add_attribute(self, name, value, opt=None):
    if opt is not None:
        self.get_particle().add_attribute(name, value, opt)
    else:
        self.get_particle().add_attribute(name, value)
def _forward_get_value(self, name):
    self.get_particle().get_value(name)
def _forward_set_value(self, name, value):
    self.get_particle().set_value(name, value)
%}


%typemap(in) char * {
  strings_must_be_passed_by_std_string;
}
%typemap(out) char * {
  strings_must_be_passed_by_std_string;
}



#if IMP_BUILD == IMP_FAST
%pythoncode %{
build="fast"
%}
#elif IMP_BUILD == IMP_RELEASE
%pythoncode %{
build="release"
%}
#else
%pythoncode %{
build="debug"
%}
#endif


namespace IMP {
%warnfilter(403) FailureHandlerBase;
%warnfilter(473) Refiner;
%warnfilter(473) SingletonContainer;
%warnfilter(473) PairContainer;
%warnfilter(403) Constraint;
%warnfilter(473) Sampler;
}
// to avoid extend clash
IMP_SWIG_OBJECT(IMP, Object, Objects);
IMP_SWIG_DIRECTOR(IMP, Object);
IMP_SWIG_BASE_OBJECT(IMP,Constraint, Constraints);
IMP_SWIG_BASE_OBJECT(IMP,Container, Containers);
IMP_SWIG_BASE_OBJECT(IMP,FailureHandler, FailureHandlers);
IMP_SWIG_BASE_OBJECT(IMP,Optimizer, Optimizers);
IMP_SWIG_BASE_OBJECT(IMP,OptimizerState, OptimizerStates);
IMP_SWIG_BASE_OBJECT(IMP,PairContainer, PairContainers);
IMP_SWIG_BASE_OBJECT(IMP,PairFilter, PairFilters);
IMP_SWIG_BASE_OBJECT(IMP,PairModifier, PairModifiers);
IMP_SWIG_BASE_OBJECT(IMP,PairScore, PairScores);
IMP_SWIG_BASE_OBJECT(IMP,QuadContainer, QuadContainers);
IMP_SWIG_BASE_OBJECT(IMP,QuadFilter, QuadFilters);
IMP_SWIG_BASE_OBJECT(IMP,QuadModifier, QuadModifiers);
IMP_SWIG_BASE_OBJECT(IMP,QuadScore, QuadScores);
IMP_SWIG_BASE_OBJECT(IMP,Refiner, Refiners);
IMP_SWIG_BASE_OBJECT(IMP,Restraint, Restraints);
IMP_SWIG_BASE_OBJECT(IMP,Sampler, Samplers);
IMP_SWIG_BASE_OBJECT(IMP,ScoreState, ScoreStates);
IMP_SWIG_BASE_OBJECT(IMP,SingletonContainer, SingletonContainers);
IMP_SWIG_BASE_OBJECT(IMP,SingletonFilter, SingletonFilters);
IMP_SWIG_BASE_OBJECT(IMP,SingletonModifier, SingletonModifiers);
IMP_SWIG_BASE_OBJECT(IMP,SingletonScore, SingletonScores);
IMP_SWIG_BASE_OBJECT(IMP,TripletContainer, TripletContainers);
IMP_SWIG_BASE_OBJECT(IMP,TripletFilter, TripletFilters);
IMP_SWIG_BASE_OBJECT(IMP,TripletModifier, TripletModifiers);
IMP_SWIG_BASE_OBJECT(IMP,TripletScore, TripletScores);
IMP_SWIG_BASE_OBJECT(IMP,UnaryFunction, UnaryFunctions);
IMP_SWIG_OBJECT(IMP,ConfigurationSet, ConfigurationSets);
IMP_SWIG_OBJECT(IMP,Configuration, Configurations);
IMP_SWIG_OBJECT(IMP,Model, Models);
//IMP_SWIG_OBJECT(IMP,Object, Objects);
IMP_SWIG_OBJECT(IMP,Particle, Particles);
IMP_SWIG_OBJECT(IMP,RestraintSet, RestraintSets);
IMP_SWIG_OBJECT_TUPLE(IMP, ParticlePair, ParticlePairs);
IMP_SWIG_OBJECT_TUPLE(IMP, ParticleTriplet, ParticleTriplets);
IMP_SWIG_OBJECT_TUPLE(IMP, ParticleQuad, ParticleQuads);
IMP_SWIG_OBJECT(IMP, PairScoreRestraint,PairScoreRestraints);
IMP_SWIG_OBJECT(IMP, PairsScoreRestraint,PairsScoreRestraints);
IMP_SWIG_OBJECT(IMP, QuadScoreRestraint,QuadScoreRestraints);
IMP_SWIG_OBJECT(IMP, QuadsScoreRestraint,QuadsScoreRestraints);
IMP_SWIG_OBJECT(IMP, SingletonScoreRestraint,SingletonScoreRestraints);
IMP_SWIG_OBJECT(IMP, SingletonsScoreRestraint,SingletonsScoreRestraints);
IMP_SWIG_OBJECT(IMP, TripletScoreRestraint,TripletScoreRestraints);
IMP_SWIG_OBJECT(IMP, TripletsScoreRestraint, TripletsScoreRestraints);

#ifdef IMP_USE_DEPRECATED
IMP_SWIG_OBJECT(IMP, WriteParticlesOptimizerState, WriteParticlesOptimizerStates);
IMP_SWIG_OBJECT(IMP, WriteParticlesFailureHandler, WriteParticlesFailureHandlers);
#ifdef IMP_KERNEL_USE_NETCDFCPP
IMP_SWIG_OBJECT(IMP, WriteParticlesBinaryOptimizerState, WriteParticlesBinaryOptimizerStates);
IMP_SWIG_OBJECT(IMP, WriteParticlesBinaryFailureHandler, WriteParticlesBinaryFailureHandlers);
#endif
#endif

IMP_SWIG_OBJECT(IMP, SaveToConfigurationSetOptimizerState, SaveToConfigurationSetOptimizerStates);
IMP_SWIG_OBJECT(IMP, SaveToConfigurationSetFailureHandler, SaveToConfigurationSetFailureHandlers);

IMP_SWIG_PAIR(IMP, Double, DerivativePair, DerivativePairs);
IMP_SWIG_PAIR(IMP, Double, FloatRange, FloatRanges);
IMP_SWIG_PAIR(IMP, Double, FloatPair, FloatPairs);
IMP_SWIG_PAIR(IMP, Int, IntRange, IntRanges);
IMP_SWIG_PAIR(IMP, Int, IntPair, IntPairs);
IMP_SWIG_SEQUENCE_PAIR(IMP, IMP::Restraint*, double, RestraintsAndWeights);

IMP_SWIG_VALUE(IMP, VersionInfo, VersionInfos);
// derivative accumulator is weird
// IMP_SWIG_VALUE(IMP, DerivativeAccumulator, DerivativeAccumulators);
IMP_SWIG_VALUE_INSTANCE(IMP, FloatKey, Key, FloatKeys);
IMP_SWIG_VALUE_INSTANCE(IMP, IntKey, Key, IntKeys);
IMP_SWIG_VALUE_INSTANCE(IMP, StringKey, Key, StringKeys);
IMP_SWIG_VALUE_INSTANCE(IMP, ParticleKey, Key, ParticleKeys);
IMP_SWIG_VALUE_INSTANCE(IMP, ObjectKey, Key, ObjectKeys);
IMP_SWIG_VALUE_TEMPLATE(IMP, Key);
IMP_SWIG_VALUE_BUILTIN(IMP, Float, Floats, double);
IMP_SWIG_VALUE_BUILTIN(IMP, Int, Ints, int);
IMP_SWIG_VALUE_BUILTIN(IMP, String, Strings, std::string);
IMP_SWIG_NATIVE_VALUE(float);
IMP_SWIG_NATIVE_VALUE(double);
IMP_SWIG_NATIVE_VALUE(int);
IMP_SWIG_NATIVE_VALUE(std::string);
IMP_SWIG_RAII(IMP, SetLogState);
IMP_SWIG_RAII(IMP, SetLogTarget);
IMP_SWIG_RAII(IMP, ScopedFailureHandler);
IMP_SWIG_RAII_INSTANCE(IMP, ScopedRestraint, GenericScopedRestraint);
IMP_SWIG_RAII_INSTANCE(IMP, ScopedRemoveRestraint, GenericScopedRemoveRestraint);
IMP_SWIG_RAII_INSTANCE(IMP, ScopedScoreState, GenericScopedScoreState);
IMP_SWIG_RAII_TEMPLATE(IMP, GenericScopedRestraint);
IMP_SWIG_RAII_TEMPLATE(IMP, GenericScopedScoreState);
IMP_SWIG_RAII(IMP, SaveOptimizeds);
IMP_SWIG_RAII(IMP, CreateLogContext)
IMP_SWIG_RAII(IMP, WarningContext)


IMP_SWIG_VALUE(IMP, TextOutput, TextOutputs);
IMP_SWIG_VALUE(IMP, TextInput, TextInputs);

IMP_SWIG_VALUE(IMP, RestraintStatistics, RestraintStatisticsList);



IMP_SWIG_DECORATOR(IMP::internal, _TrivialDecorator, _TrivialDecorators);
IMP_SWIG_DECORATOR(IMP::internal, _TrivialDerivedDecorator, _TrivialDerivedDecorators);
IMP_SWIG_DECORATOR_WITH_TRAITS(IMP::internal, _TrivialTraitsDecorator, _TrivialTraitsDecorators);
IMP_SWIG_OBJECT(IMP::internal, _ConstRestraint, _ConstRestraints);
IMP_SWIG_OBJECT(IMP::internal, _ConstOptimizer, _ConstOptimizers);
IMP_SWIG_VALUE(IMP::internal, _Value, _Values);
IMP_SWIG_GRAPH(IMP, DependencyGraph, DependencyGraph, IMP::Object*);

/*%typemap(in) IMP::VersionInfo* {
 values_like_##Name##_must_be_passed_by_value_or_const_ref;
}*/

%extend IMP::Object {
  bool __eq__(const Object *o) const {
     return self ==o;
  }
  bool __ne__(const Object *o) const {
     return self !=o;
  }
  bool __le__(const Object *o) const {
     return self <= o;
  }
  bool __lt__(const Object *o) const {
     return self < o;
  }
  bool __ge__(const Object *o) const {
     return self >= o;
  }
  bool __gt__(const Object *o) const {
     return self > o;
  }
  bool __eq__(const IMP::Decorator &d) const {
     return self == d.get_particle();
  }
  bool __ne__(const IMP::Decorator &d) const {
     return self != d.get_particle();
  }
  bool __le__(const IMP::Decorator &d) const {
     return self <= d.get_particle();
  }
  bool __lt__(const IMP::Decorator &d) const {
     return self < d.get_particle();
  }
  bool __ge__(const IMP::Decorator &d) const {
     return self >= d.get_particle();
  }
  bool __gt__(const IMP::Decorator &d) const {
     return self > d.get_particle();
  }
}

%feature("ref")   IMP::RefCounted "IMP::internal::ref($this);"
%feature("unref") IMP::RefCounted "IMP::internal::unref($this);"

IMP_SWIG_CONTAINER(IMP, IMP, RestraintSet, Restraint, restraint)
IMP_SWIG_CONTAINER(IMP, IMP, Model, ScoreState, score_state)
IMP_SWIG_CONTAINER(IMP, IMP, Model, Restraint, restraint)
IMP_SWIG_CONTAINER(IMP, IMP, Model, Particle, particle)
IMP_SWIG_CONTAINER(IMP, IMP, Optimizer, OptimizerState, optimizer_state)

%include "IMP/utility.h"
%include "IMP/Key.h"

namespace IMP {
  %template(FloatKey) ::IMP::Key<0, true>;
  %template(IntKey) ::IMP::Key<1, true>;
  %template(StringKey) ::IMP::Key<2, true>;
  %template(ParticleKey) ::IMP::Key<3, true>;
  %template(ObjectKey) ::IMP::Key<4, true>;
  %implicitconv TextInput;
  %implicitconv TextOutput;
}

%inline %{
namespace IMP {
template <class T, class P>
class VectorOfRefCounted;
template <class T, class P, class E>
class Decorators;
template <unsigned int D>
class ParticleTuple;
// just let swig know which namespace they are in
#ifdef SWIG
class ParticlePair;
class ParticleTriplet;
class ParticleQuad;
class ParticlePairs;
class ParticleTriplets;
class ParticleQuads;
class ParticlePairsTemp;
class ParticleTripletsTemp;
class ParticleQuadsTemp;
#endif
}
%}

%pythoncode %{
  def ParticlePair(a, b):
    return (a,b)
  def ParticleTriplet(a, b, c):
    return (a,b,c)
  def ParticleQuad(a, b, c, d):
    return (a,b,c,d)
%}

%include "IMP/log.h"
%include "IMP/base_types.h"
%include "IMP/file.h"

%include "IMP/utility.h"
%include "IMP/deprecation.h"
%include "IMP/VersionInfo.h"
%include "IMP/RefCounted.h"
//%include "IMP/VectorOfRefCounted.h"
%include "IMP/Object.h"
%include "IMP/FailureHandler.h"
%include "IMP/DerivativeAccumulator.h"
%include "IMP/container_base.h"
%include "IMP_kernel_particle.i"
%include "IMP/Decorator.h"

namespace IMP {
  class Restraints;
  class ScoreStates;
}

%include "IMP/Restraint.h"
%include "IMP/RestraintSet.h"
%include "IMP/ScoreState.h"
%include "IMP/Model.h"
%include "IMP/UnaryFunction.h"
%include "IMP/Constraint.h"
%include "IMP/OptimizerState.h"
%include "IMP/Refiner.h"
%include "IMP_kernel_random.i"
%include "IMP/Optimizer.h"
%include "IMP/ConfigurationSet.h"
%include "IMP/Configuration.h"
%include "IMP/Sampler.h"
%include "IMP/SingletonScore.h"
%include "IMP/PairScore.h"
%include "IMP/SingletonModifier.h"
%include "IMP/PairModifier.h"
%include "IMP/SingletonContainer.h"
%include "IMP/PairContainer.h"
%include "IMP/SingletonFilter.h"
%include "IMP/PairFilter.h"
%include "IMP/TripletScore.h"
%include "IMP/QuadScore.h"
%include "IMP/TripletModifier.h"
%include "IMP/QuadModifier.h"
%include "IMP/TripletContainer.h"
%include "IMP/QuadContainer.h"
%include "IMP/TripletFilter.h"
%include "IMP/QuadFilter.h"
%include "IMP/SetLogState.h"
%include "IMP/io.h"
%include "IMP/internal/swig.h"
%include "IMP/scoped.h"
%include "IMP/dependency_graph.h"


namespace IMP {
  %template(DependencyGraph) ::IMP::internal::BoostDigraph< IMP::DependencyGraph, IMP::Object*>;
  %template(ScopedScoreState) ::IMP::GenericScopedScoreState< IMP::ScoreState>;
  %template(ScopedRestraint) ::IMP::GenericScopedRestraint< IMP::Restraint>;
  %template(ScopedRemoveRestraint) ::IMP::GenericScopedRemoveRestraint< IMP::Restraint>;
}


%pythoncode %{
used_modules=[]
def show_used_modules():
    for m in used_modules:
        print "%-20s %s" % (m.get_module(), m.get_version())


def get_networkx_graph(ig):
   import networkx
   g= networkx.DiGraph()
   if len(ig.get_vertices())==0:
       return g
   class NodeWrapper:
     def __init__(self, p):
        self.p=p
     def __str__(self):
        return self.p.get_name()
     def __call__(self, name):
        return self.p.__call__(name)
     
   for vi in ig.get_vertices():
      n= ig.get_vertex_name(vi)
      g.add_node(NodeWrapper(n))
   for vi in ig.get_vertices():
      n= ig.get_vertex_name(vi)
      for ni in ig.get_out_neighbors(vi):
         nn= ig.get_vertex_name(ni)
         g.add_edge(NodeWrapper(n), NodeWrapper(nn))
   return g


def show_altgraph(g):
           def clean(name):
              try:
                n0=name.get_name()
              except:
                n0=str(name)
              n1= str(n0).replace('"','')
              n2= n1.replace("\n",'')
              return n2
           import altgraph
           from altgraph import Graph, Dot
           graph= Graph.Graph()
           for i,v in enumerate(g.get_vertices()):
               graph.add_node(i) #, node_data=g.get_vertex_name(v)
           for i,v in enumerate(g.get_vertices()):
               for n in g.get_out_neighbors(v):
                  graph.add_edge(v, n)
           dot = Dot.Dot(graph) #, graph_type="digraph"
           for i,v in enumerate(g.get_vertices()):
               dot.node_style(i, label=clean(g.get_vertex_name(v)))
           dot.display()

def show_graphviz(g):
           tfn= create_temporary_file_name("graph", ".dot")
           tfon= create_temporary_file_name("graph", ".pdf")
           st= g.get_graphviz_string()
           open(tfn, "w").write(st)
           import subprocess
           sp=subprocess.Popen(["dot", "-Tpdf", tfn, "-o"+tfon])
           sp.wait()
           try:
             subprocess.Popen(["open", tfon])
           except:
             try:
                subprocess.Popen(["acroread", tfon])
             except:
                print "Could not display file. It is saved at", tfon
           return tfon
%}
