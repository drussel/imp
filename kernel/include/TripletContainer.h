/**
 *  \file TripletContainer.h    \brief A container for Triplets.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2011 IMP Inventors. All rights reserved.
 */

#ifndef IMP_TRIPLET_CONTAINER_H
#define IMP_TRIPLET_CONTAINER_H

#include "kernel_config.h"
#include "internal/IndexingIterator.h"
#include "Particle.h"
#include "container_base.h"
#include "VersionInfo.h"
#include "DerivativeAccumulator.h"
#include "internal/OwnerPointer.h"
#include "ParticleTuple.h"
#include "TripletScore.h"
#include "TripletModifier.h"
#include "TripletDerivativeModifier.h"
#include "macros.h"

IMP_BEGIN_NAMESPACE

class TripletContainer;
typedef std::pair<TripletContainer*,
                  TripletContainer*> TripletContainerPair;

//! A shared container for Triplets
/** Stores a searchable shared collection of Triplets.
    \ingroup restraints

    \implementationwithoutexample{TripletContainer, IMP_TRIPLET_CONTAINER}
 */
class IMPEXPORT TripletContainer : public Container
{
  mutable internal::OwnerPointer<Container> added_, removed_;
  struct Accessor {
    typedef ParticleTriplet result_type;
    typedef unsigned int argument_type;
    result_type operator()(argument_type i) const {
      return o_->get_particle_triplet(i);
    }
    Accessor(TripletContainer *pc): o_(pc){}
    Accessor(): o_(NULL){}
    IMP_COMPARISONS_1(Accessor, o_);
  private:
    // This should be ref counted, but swig memory management is broken
    TripletContainer* o_;
  };
 protected:
  /** Containers must have containers that keep track of the particles
      which have been added or since the last step. These containers
      must be registered with the parent TripletContainer.

      Containers which are themselves returned by the get_added/removed
      functions do not have to register such containers.
  */
  virtual TripletContainerPair
    get_added_and_removed_containers() const =0;
  bool get_has_added_and_removed_containers() const {
    return (added_ && added_->get_is_shared())
      || (removed_ && removed_->get_is_shared());
  }
  TripletContainer(){}
  TripletContainer(Model *m,
                     std::string name="TripletContainer %1%");
#ifndef IMP_DOXYGEN
  template <class S>
    static double call_evaluate(const S *s, const ParticleTriplet& a,
                                DerivativeAccumulator *da) {
    return s->S::evaluate(a, da);
  }
  static double call_evaluate(const TripletScore *s, const ParticleTriplet& a,
                              DerivativeAccumulator *da) {
    return s->evaluate(a, da);
  }
  template <class S>
    static double call_evaluate_if_good(const S *s,
                                        const ParticleTriplet& a,
                                        DerivativeAccumulator *da,
                                        double max) {
    return s->S::evaluate_if_good(a, da, max);
  }
  static double call_evaluate_if_good(const TripletScore *s,
                                      const ParticleTriplet& a,
                                      DerivativeAccumulator *da,
                                      double max) {
    return s->evaluate_if_good(a, da, max);
  }
  template <class S>
    static void call_apply(const S *s, const ParticleTriplet& a) {
    s->S::apply(a);
  }
  static void call_apply(const TripletModifier *s, const ParticleTriplet& a) {
    s->apply(a);
  }
  template <class S>
    static void call_apply(const S *s, const ParticleTriplet& a,
                           DerivativeAccumulator *&da) {
    s->S::apply(a, da);
  }
  static void call_apply(const TripletDerivativeModifier *s,
                         const ParticleTriplet& a,
                         DerivativeAccumulator &da) {
    s->apply(a, da);
  }



  template <class S>
    static double call_evaluate(const S *s, Model *m,
                                const ParticleIndexTriplet& a,
                                DerivativeAccumulator *da) {
    return s->S::evaluate(m, a, da);
  }
  static double call_evaluate(const TripletScore *s, Model *m,
                              const ParticleIndexTriplet& a,
                              DerivativeAccumulator *da) {
    return s->evaluate(m, a, da);
  }
  template <class S>
    static double call_evaluate_if_good(const S *s,
                                        Model *m,
                                        const ParticleIndexTriplet& a,
                                        DerivativeAccumulator *da,
                                        double max) {
    return s->S::evaluate_if_good(m, a, da, max);
  }
  static double call_evaluate_if_good(const TripletScore *s,
                                      Model *m,
                                      const ParticleIndexTriplet& a,
                                      DerivativeAccumulator *da,
                                      double max) {
    return s->evaluate_if_good(m, a, da, max);
  }
  template <class S>
    static void call_apply(const S *s, Model *m,
                              const ParticleIndexTriplet& a) {
    s->S::apply(m, a);
  }
  static void call_apply(const TripletModifier *s, Model *m,
                         const ParticleIndexTriplet& a) {
    s->apply(m, a);
  }
  template <class S>
    static void call_apply(const S *s, Model *m,
                           const ParticleIndexTriplet& a,
                           DerivativeAccumulator *&da) {
    s->S::apply(m, a, da);
  }
  static void call_apply(const TripletDerivativeModifier *s,
                         Model *m,
                         const ParticleIndexTriplet& a,
                         DerivativeAccumulator &da) {
    s->apply(m, a, da);
  }
#endif
public:
  typedef ParticleTriplet ContainedType;
  /** \note This function may be linear. Be aware of the complexity
      bounds of your particular container.
   */
  virtual bool get_contains_particle_triplet(const ParticleTriplet& v) const =0;
  //! return the number of Triplets in the container
  /** \note this isn't always constant time
   */
  virtual unsigned int get_number_of_particle_triplets() const =0;

  ParticleTripletsTemp get_particle_triplets() const {
    return ParticleTripletsTemp(particle_triplets_begin(),
                              particle_triplets_end());
  }
  virtual ParticleTriplet get_particle_triplet(unsigned int i) const=0;

#ifdef IMP_DOXYGEN
  //! An iterator through the contents of the container
  class ParticleTripletIterator;
#else
  typedef internal::IndexingIterator<Accessor> ParticleTripletIterator;
#endif
#ifndef SWIG
  //! begin iterating through the Triplets
  ParticleTripletIterator particle_triplets_begin() const {
    // Since I can't make the count mutable in Object
    return
      ParticleTripletIterator(Accessor(const_cast<TripletContainer*>(this)),
                        0);
  }
  //! iterate through the Triplets
  ParticleTripletIterator particle_triplets_end() const {
    return
      ParticleTripletIterator(Accessor(const_cast<TripletContainer*>(this)),
                        get_number_of_particle_triplets());
    }
#endif

  //! Apply a SingletonModifier to the contents
  virtual void apply(const TripletModifier *sm)=0;

  //! Apply a SingletonModifier to the contents
  virtual void apply(const TripletDerivativeModifier *sm,
                     DerivativeAccumulator &da)=0;

  //! Evaluate a score on the contents
  virtual double evaluate(const TripletScore *s,
                          DerivativeAccumulator *da) const=0;

  //! Evaluate a score on the contents
  virtual double evaluate_if_good(const TripletScore *s,
                                  DerivativeAccumulator *da,
                                  double max) const=0;


  /** \name Tracking changes
      The container can keep track of the changes since the last
      Model::evaluate() call. To use this, make sure to call
      get_removed_container() or get_added_container() before
      Model::evaluate() so the container knows to track changes.
      @{
  */
  TripletContainer* get_removed_container() const {
    // must not be an added or removed container
    get_model();
    if (!added_) {
      std::pair<TripletContainer*, TripletContainer*>
        cp= get_added_and_removed_containers();
      added_=cp.first;
      removed_=cp.second;
    }
    IMP_USAGE_CHECK(added_, "The containers returned by "
                    << " get_added_container() do not "
                    << " track their own added and removed contents.");
    TripletContainer *ret= dynamic_cast<TripletContainer*>(removed_.get());
    IMP_INTERNAL_CHECK(ret, "Cannot cast object " << removed_->get_name()
                       << " to a TripletContainer.");
    return ret;
  }
  TripletContainer* get_added_container() const {
    // must not be an added or removed container
    if (!added_) {
      std::pair<TripletContainer*, TripletContainer*>
        cp= get_added_and_removed_containers();
      added_=cp.first;
      removed_=cp.second;
    }
    IMP_USAGE_CHECK(added_, "The containers returned by "
                    << " get_added_container() do not "
                    << " track their own added and removed contents.");
    TripletContainer *ret= dynamic_cast<TripletContainer*>(added_.get());
    IMP_INTERNAL_CHECK(ret, "Cannot cast object " << added_->get_name()
                       << " to a TripletContainer.");
    return ret;
  }
  /** @} */

#ifndef IMP_DOXYGEN
  typedef ParticleTriplet value_type;
  ParticleTriplet get(unsigned int i) const {return get_particle_triplet(i);}
  ParticleTripletsTemp get() const {
    return get_particle_triplets();
  }
  bool get_contains(const ParticleTriplet& v) const {
    return get_contains_particle_triplet(v);
  }
  unsigned int get_number() const {return get_number_of_particle_triplets();}
#ifndef SWIG
  virtual bool get_provides_access() const {return false;}
  virtual const ParticleIndexTriplets& get_access() const {
    IMP_THROW("Object not implemented properly.", IndexException);
  }
#endif
  virtual ParticleIndexTriplets get_indexes() const {
    ParticleIndexTriplets ret(get_number());
    for (unsigned int i=0; i< ret.size(); ++i) {
      ret[i]= IMP::internal::get_index(get(i));
    }
    return ret;
  }
#endif

  IMP_REF_COUNTED_NONTRIVIAL_DESTRUCTOR(TripletContainer);
};

IMP_OBJECTS(TripletContainer,TripletContainers);

IMP_END_NAMESPACE

#endif  /* IMP_TRIPLET_CONTAINER_H */
