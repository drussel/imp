/**
\page introduction An Introduction to IMP


\section i0 Architecture
 
 There are several key concepts in \imp:
  - Representation: all data is stored as attributes of an IMP::Particle
    - \ref decorators "Decorators" ease use of the particles and help
    maintain invariants, such as ensuring that a bond is internally consistent
    - IMP::ScoreState objects can be used to maintain representational invariants such
    as a particle being the centroid of other particles or a set of particles moving as
    a rigid body.
  - Scoring:
    - a IMP::Restraint is used to compute the score of the current configuration of some subset of the Particles. The total score is the sum of the various restraint scores.
    - IMP::ScoreState objects compute maintain high level information about the particles (such as which particles are close to one another)
  - an IMP::Optimizer optimizes the Particles with respect to the Restraints by changing the Particle attribute values.


  - The IMP::Model holds the particles, restraints, and score states.
    - It also ensures that the IMP::ScoreState objects are properly called when computing
    the score of the current configuration.


\section i05 Restraints

 The scoring function for the particles is created by combining various components.
 For example:

  - IMP::core::PairsRestraint applies an arbitrary IMP::PairScore to
    all the pairs of particles in a list of particles

  - this list of particles could be generated from an
    IMP::core::ClosePairsScoreState so that it always contains a list
    of which particles are close to one another

  - the IMP::PairScore could be an IMP::core::SphereDistancePairScore,
    which scores the pair of particles on the distance between the two
    spheres defined by the particles center and radius.

  - the way the IMP::core::SphereDistancePairScore computes a score
    from the distance could be using an IMP::core::HarmonicLowerBound
    so that the particles are repelled.


\section i5 Other important bits
There is good \ref log "logging support":
\code
IMP::set_log_level(IMP.VERBOSE);
IMP_LOG(TERSE, "Something interesting has occurred with variable " 
                 << var << std::endl);
\endcode

\ref assert "Error reporting/checking" which can be controlled at runtime. By default
     some checks are performed. Make sure to turn them off if for maximum speed.
\code
IMP::set_check_level(IMP.EXPENSIVE);
IMP_check(boolean_condition, "An error has occurred with value "
                             << some_value,
                             ExceptionType);
\endcode

The control functions are accessible from Python, but the check and log macros are not.

Saving state
\htmlinclude read_write.py.html

\verbatim
IMP::core::write(my_imp_model, "somefile");
IMP::core::read("somefile", my_imp_model);
\endverbatim



\section i6 Examples
The following examples all are in python and C++ The following code is ommitted from the examples:
\htmlinclude setup.py.html

\code
#include <IMP.h>
#include <IMP/core.h>

IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::core::SingletonContainer ps;
for (int i=0; i< 100; ++i) {
    IMP::Particle* p=new IMP::Particle();
    ps->add_particle(p);
    m->add_particles(p);
    IMP::core::XYZRDecorator d= IMP::core::XYZRDecorator::setup_particle(p);
    d.set_coordinates_are_optimized(true);
    d.set_coordinates(IMP::random_vector_in_box());
    d.set_radius(1.0);
}

\endcode





\section i7 Restrain some distances

Restrain the distance between the first two particles.

\htmlinclude fragments/pair_restraint.py.html


\code
IMP::core::Harmonic *uf= new IMP::core::Harmonic(0,1);
IMP::core::SphereDistancePairScore *df= new IMP::core::SphereDistancePairScore(uf);
IMP::core::PairRestraint* r= new IMP::core::PairRestraint(df, ps->get_particle(0), ps->get_particle(1));
m->add_restraint(r);
\endcode



\section i8 Preventing collisions
The ClosePairsScoreState maintains a list of all pairs of particles which contains all pairs closer than min distance (between the spheres). The HarmonicLowerBound forces the spheres apart.
\htmlinclude fragments/excluded_volume.py.html

\code
IMP::core::ClosePairsScoreState *nbl= new IMP::core::ClosePairsScoreState(ps);
nbl->set_distance(min_distance)
m->add_score_state(nbl);
IMP::core::HarmonicLowerBound* h= new IMP::core::HarmonicLowerBound(0,1);
IMP::core::SphereDistancePairScore *sd= new IMP::core::SphereDistancePairScore(h);
IMP::core::SingletonsRestraint* nbr= new IMP::core::SingletonsRestraint(sd, nbl->get_close_pairs_container());
m->add_restraint(nbr);
\endcode







\section i9 Restraining bonds

Load a protein and restrain all the bonds to have the correct length. Bond angles is a bit trickier at the moment.

\htmlinclude fragments/load_protein_restrain_bonds.py.html

\code
IMP::core::MolecularHierarchyDecorator prot=IMP::atom::read_pdb("my.pdb", m);
IMP::core::BondDecorators bds= IMP::core::get_internal_bonds(prot);
IMP::Particles ps(bds.size());
for (unsigned int i=0; i< bds.size(); ++i) ps[i]= bds[i].get_particle();
IMP::core::ListSingletonContainer *bl= new IMP::core::ListSingletonContainer(ps);
IMP::core::Harmonic *h= new IMP::core::Harmonic(0,1);
IMP::core::BondDecoratorSingletonScore* bs= new IMP::core::BondDecoratorSingletonScore(h);
IMP::core::SingletonsRestraint *br= new IMP::core::SingletonsRestraint(bs, bl);
m->add_restraint(br);
\endcode







\section i10 Simple optimization setup
A basic setup for optimizing a model.
\htmlinclude basic_optimization.py.html

\code
IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::Particles particles = setup_model(m);

std::string best;
float best_score=std::numeric_limits<IMP::Float>::infinity();

IMP::core::ConjugateGradients o;
o.set_model(m)
for (int i=0; i< 100; ++i) {
    randomize(particles)
    IMP::Float score=o.optimize(1000)
    if (score < best_score) {
       std::ostringstream oss;
       IMP::core::write(m, oss);
       best=oss.str();
       best_score= score;
    }
}
std::istringstream iss(best_score);
IMP::core::read(iss, m);
\endcode

\section i11 Writing a simple restraint
This is actually an IMP::core::SingletonsRestraint. You really wouldn't want to write such a thing in Python, although you can.

\code
class IMPDLLEXPORT MyRestraint: public IMP::Restraint {
      IMP::Pointer<IMP::SingletonScore> ss_;
      IMP::Pointer<IMP::core::SingletonContainer> sc_;
public:
        MyRestraint(IMP::SingletonScore *ss,
                    IMP::core::SingletonContainer *sc): ss_(ss),
                                                        sc_(sc){}
        IMP_RESTRAINT(my_version_info);
};

IMP::Float MyRestraint::evaluate(IMP::DerivativeAccumulator *da) {
      IMP::Float accum=0;
      for (IMP::core::SingletonContainer::ParticlesIterator it = sc_->particles_begin(); 
           it != sc_->particles_end(); ++it) {
          accum += ss_->evaluate(*it, da);
       }
       return accum;
}
IMP::Float MyRestraint::show(std::ostream &out) const {
      out << "MyRestraint on " << sc_->get_number_of_particles() << " particles" << std::endl;
}

IMP::ParticlesList
MyRestraint::get_interacting_particles() const
{
       return IMP::ParticlesList();
}

\endcode


\section i12 Available functionality

Look through the types inherited from these methods to get an idea of the functionality available.

- IMP::Decorator
- IMP::Restraint
- IMP::SingletonScore
- IMP::PairScore
- IMP::TripletScore
- and check out the namespace list above for an orthogonal view


\section i125 Modules
Functionality in \imp is grouped into modules. Each module contails classes,
methods and data which are related and "owned" by a certain set of people. Examples
of current modules include
- IMP.core which includes functionality used by almost all \imp modules
- IMP.algebra which contains math-related functionality used by other modules
- IMP.em which contains functionality for fitting moleculars to EM maps
- IMP.saxs which contains functionality for fitting molecules to SAXS data

\section i13 C++ vs Python

Most code maps trivially from one to the other as you can see in the examples.
<table>
<tr><td></td><td>C++</td><td>Python</td></tr>
<tr><td>memory management</td><td>using IMP::Pointer</td><td>automatic</td></tr>
<tr><td>debugging</td><td>use gdb</td><td>hard to inspect IMP objects from Python</td></tr>
</table>

Normal python usage expects a few things that we do not currently offer from out objects such as doc strings and support for the \c str method.

Recommendations:
- write restraints and decorators in C++
- use python to set up and construct your optimization protocol

\section i15 Getting started

The easiest way to get started developing with \imp is to use a local module.
To do this run the \command{./kernel/doc/bin/make-module my_module} in the
main \imp directory. This will create a new module in modules/my_module. See
\ref make_module "Making a module" for more information.

You should then read the
 - \ref api "API documentation"
 - \ref conventions "Conventions"
 - and \ref coding_conventions "Coding conventions"

*/
