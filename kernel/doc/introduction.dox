/**
\page introduction An Introduction to IMP

\imp is a library for solving a a wide variety of molecular structures and
dynamics using many different data sources. As a result, it is provides a
great deal of flexibility. In order to best make the required decisions
about how to use \imp to solve a particular problem, it is useful to
understand the overall structure of \imp.

\section im1 Theory

Structure and dynamics modeling in \imp proceeds in a five stage iterative process
 -# Gathering of experimental data
 -# Choice of the representation scheme for the model
 -# Encoding of the data as a scoring function on the representation scheme
 -# Sampling of the possible models in the representation scheme to try to find good models
 -# Analysis of the found models to determine if more work is needed

\imp provides tools to help address the last four of these
stages. Unfortunately, it doesn't offer much help performing the
experiments. We are working on that.

Knowledge about the system being modeled enters the process at all
stages, but a few need extra note:

- A certain amount of knowledge is encoded as "constraints". These are
  choices made in choosing the representation scheme that force
  relationships between parts to always hold. For example,
  representing part of the system as a rigid body, means that none of
  the distances or angles within the rigid body ever change.

- Other knowledge is encoded as restraints via scoring functions that
  penalize models which don't fit that bit of information.

- Knowledge can also be used to tune the sampling scheme by choosing
  starting configurations, the discrete sample etc.

\section i0 Architecture
 
\imp provides a large number of classes and functions from which to
choose when solving a particular problem. Fortunately, these classes
fall into a variety of categories.

- Representation: The model in \imp is represented as a collection
  of IMP::Particle objects, stored in the IMP::Model. The
  IMP::Particle class provides storage for arbitrary data, and as such is
  not that easy to use directly. To ease use, \imp provides a layer on
  top of particles called decorators. A decorator wraps an existing
  particle and provides a simplified interface to access and
  manipulate a certain type of data. For example, the IMP::core::XYZ
  decorator decorates a particle to provide easy access to and
  manipulation of the cartesian coordinates; the IMP::atom::Hierarchy
  decorator with the associated IMP::atom::Atom, IMP::atom::Residue
  etc. decorators provide a standard representation of molecular
  structures; the IMP::core::RigidBodyDecorator represents part of the
  model rigidly etc. See the IMP::Decorator page for
  more information.

- Scoring: Proposed models are scored based on how well they match the
  data. In \imp the scoring function is the sum of restraint
  terms. Each restraint term has a corresponding IMP::Restraint object
  which computes a score and derivatives based on a set of particles
  in the IMP::Model. Restraints can be such things as how well a set of
  particles fits an EM density map (IMP::em::FitRestraint), how close
  the volume of a molecule is to a known value (IMP::core::VolumeRestraint),
  penalize a set of spheres if they become disconnected
  (IMP::core::ConnectivityRestraint) etc.

- Sampling: It is then necessary to search for conformations of the model that
  have low scores (and therefore fit the data well). Sampling produces a set of
  conformations of the model, organized into an IMP::ConformationSet. Currently
  \imp provides two sampling protocols, IMP::core::MCCGSampler which uses a
  combination of Monto Carlo and Conjugate Gradients with randomized starting
  conformations and IMP::domino::DominoOptimizer which uses a graph based
  inference algorithm.

- Analysis: Finally, one needs to analyze the set of conformations produced by
  sampling. \imp provides a variety of tools to help display the conformations,
  in IMP::display, and to cluster them, in IMP::statistics. 

Coming up with the right choices for representation, scoring and sampling for
a given system typically takes a few iterations and trial and error. \imp
provides tools to help monitor how things are performing.

- Logging: most actions in \imp can produce logged information to help understand
  what is going on. The amount of logging information produced can be controlled
  globally using the IMP.set_log_level() function, passing it one of the IMP::LogLevel
  values. In addition, restraints, samplers, constraints (and all objects which inherit
  from IMP::Object) have an internal log level that overrides the global one. To set
  that call the IMP::Object::set_log_level() function on that object. Setting the log
  level to IMP::VERBOSE will produce a huge amount of information during a typical
  sampling run. IMP::TERSE is generally better. Make sure to set it to at least
  IMP::WARNING to make sure that you don't miss any important warnings.

- Usage checking: \imp can perform a lot of checks that it is being used correctly
  as well as that it is behaving correctly. The checks being performed are controlled
  by the IMP::set_check_level() function call. Set the check level to IMP::USAGE to
  make sure that all parameters passed are correct. Set it to IMP::USAGE_AND_INTERNAL
  if you are developing new restraints or sampling protocols or are worried that
  \imp is malfunctioning.

- IO: \imp supports I/O to and from a variety of formats. To preserve the maximum amount
  of information, one can used the IMP::core::read() and IMP::core::write() methods to
  save and load a whole model to a human (and machine) readable file. IMP::display supports
  export to a wide variety of graphical display formats and IMP::atom::read_pdb() and
  IMP::atom::write_pdb() provide PDB-centric I/O.


\section i6 Examples
The following examples all are in Python and C++.

The following setup code is ommitted from the Python examples for clarity:
\htmlinclude setup.py.html

The following setup code is ommitted from the C++ examples for clarity:
\code
#include <IMP.h>
#include <IMP/core.h>

IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::core::SingletonContainer ps;
for (int i=0; i< 100; ++i) {
    IMP::Particle* p=new IMP::Particle();
    ps->add_particle(p);
    m->add_particles(p);
    IMP::core::XYZRDecorator d= IMP::core::XYZRDecorator::setup_particle(p);
    d.set_coordinates_are_optimized(true);
    d.set_coordinates(IMP::random_vector_in_box());
    d.set_radius(1.0);
}

\endcode

See the \ref examples "Examples Page" for a full list of examples.



\section i7 Restrain some distances

Restrain the distance between the first two particles.

\htmlinclude pair_restraint.py.html


\code
IMP::core::Harmonic *uf= new IMP::core::Harmonic(0,1);
IMP::core::SphereDistancePairScore *df= new IMP::core::SphereDistancePairScore(uf);
IMP::core::PairRestraint* r= new IMP::core::PairRestraint(df, ps->get_particle(0), ps->get_particle(1));
m->add_restraint(r);
\endcode



\section i8 Preventing collisions
The IMP::core::ClosePairsContainer maintains a list of all pairs of particles which contains all pairs closer than min distance (between the spheres). The HarmonicLowerBound forces the spheres apart.
\htmlinclude excluded_volume.py.html

\code
IMP::core::ClosePairsContainer *nbl= new IMP::core::ClosePairsScoreState(ps, min_distance);
IMP::core::HarmonicLowerBound* h= new IMP::core::HarmonicLowerBound(0,1);
IMP::core::SphereDistancePairScore *sd= new IMP::core::SphereDistancePairScore(h);
IMP::core::SingletonsRestraint* nbr= new IMP::core::SingletonsRestraint(sd, nbl);
m->add_restraint(nbr);
\endcode







\section i9 Restraining bonds

Load a protein and restrain all the bonds to have the correct length. Bond angles is a bit trickier at the moment.

\htmlinclude load_protein_restrain_bonds.py.html

\code
IMP::core::MolecularHierarchyDecorator prot=IMP::atom::read_pdb("my.pdb", m);
IMP::core::BondDecorators bds= IMP::core::get_internal_bonds(prot);
IMP::Particles ps(bds.size());
for (unsigned int i=0; i< bds.size(); ++i) ps[i]= bds[i].get_particle();
IMP::core::ListSingletonContainer *bl= new IMP::core::ListSingletonContainer(ps);
IMP::core::Harmonic *h= new IMP::core::Harmonic(0,1);
IMP::core::BondDecoratorSingletonScore* bs= new IMP::core::BondDecoratorSingletonScore(h);
IMP::core::SingletonsRestraint *br= new IMP::core::SingletonsRestraint(bs, bl);
m->add_restraint(br);
\endcode







\section i10 Simple optimization setup
A basic setup for optimizing a model.
\htmlinclude basic_optimization.py.html

\code
IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::Particles particles = setup_model(m);

std::string best;
float best_score=std::numeric_limits<IMP::Float>::infinity();

IMP::core::ConjugateGradients o;
o.set_model(m)
for (int i=0; i< 100; ++i) {
    randomize(particles)
    IMP::Float score=o.optimize(1000)
    if (score < best_score) {
       std::ostringstream oss;
       IMP::core::write(m, oss);
       best=oss.str();
       best_score= score;
    }
}
std::istringstream iss(best_score);
IMP::core::read(iss, m);
\endcode

\section i11 Writing a simple restraint
This is actually an IMP::core::SingletonsRestraint. You really wouldn't want to write such a thing in Python, although you can.

\code
class IMPDLLEXPORT MyRestraint: public IMP::Restraint {
      IMP::Pointer<IMP::SingletonScore> ss_;
      IMP::Pointer<IMP::core::SingletonContainer> sc_;
public:
        MyRestraint(IMP::SingletonScore *ss,
                    IMP::core::SingletonContainer *sc): ss_(ss),
                                                        sc_(sc){}
        IMP_RESTRAINT(my_version_info);
};

IMP::Float MyRestraint::evaluate(IMP::DerivativeAccumulator *da) {
      IMP::Float accum=0;
      for (IMP::core::SingletonContainer::ParticlesIterator it = sc_->particles_begin(); 
           it != sc_->particles_end(); ++it) {
          accum += ss_->evaluate(*it, da);
       }
       return accum;
}
IMP::Float MyRestraint::show(std::ostream &out) const {
      out << "MyRestraint on " << sc_->get_number_of_particles() << " particles" << std::endl;
}

IMP::ParticlesList
MyRestraint::get_interacting_particles() const
{
       return IMP::ParticlesList();
}

\endcode


\section installation Installing IMP
Instructions on how to build and install \imp can be found in
the \ref installation "installation instructions".


\section next Where to go next
  
There are a few areas of core functionality that have already been mentioned.
- IMP::Decorator
- \ref log "Logging Support"
- \ref assert "Error Reporting Facilities"

Then look through the examples which can be found at:
- \ref examples "Examples"

There are a variety of useful base classes which are used to provide
most functionality. They are:
    - IMP::Model
    - IMP::Particle
    - IMP::Decorator
    - IMP::Restraint
    - IMP::ScoreState
    - IMP::Sampler
    - IMP::Optimizer
    - IMP::SingletonContainer, IMP::PairContainer
    - IMP::SingletonScore, IMP::PairScore, IMP::TripletScore
    - IMP::SingletonModifier, IMP::PairModifier

There are a few blocks of functionality that cut across modules. They
include
- \ref hierarchy "Code to create and manipulate hierarchies"
- \ref bond "Code to create and manipulate bonds"

When programming with \imp, one of the more useful pages is the
<a href="hierarchy.html">class hierarchy</a> as well as
the \salilab{imp/doc/doxygen/namespaces.html, module pages}.


\section i125 Modules

Functionality in \imp is grouped into modules, each with its own
namespace. A module contain classes, methods and data which are
related and owned by a certain set of people. See the "Namespaces"
tab above for a complete list of modules in this version of \imp.

\section i13 C++ vs Python
\anchor cpppythondifferences
\imp can be used from both C++ and Python. We recommend that you:
- use Python to put \imp classes together to handle your data and resulting structures
- write new \imp classes in C++

People who are new to programming should check out a general python 
introduction such as
\external{docs.python.org/tutorial/introduction.html, the official introduction to Python} and
\external{www.rexx.com/~dkuhlman/python_101/python_101.html, Python
101}. Users who have
programmed but are not familiar with Python should take a look at
\external{diveintopython.org/toc/index.html, Dive into Python},
especially chapters 1-6, and 15-18.

While effort has been made to ensure that the interfaces are the same
between the two languages, a number of differences remain due to
differences in the languages and limitations of the program used to
generate the connection between the two languages. Key differences are

- Python does not support templates and so template classes (eg
  IMP::algebra::BoundingBoxD, IMP::VectorOfRefCounted) cannot be
  directly exposed in python. Instead, specific versions of the
  classes are exported (IMP::algebra::BoundingBox3D and
  IMP::Particles, respectively). New versions can be easily added, so
  feel free to request them when desired.

- Iterators on C++ containers do not easily into Python. For
  every iterator generating pair \c foos_begin(), \c foos_end(), we
  provide a method \c get_foos() which can be used with python \c
  foreach loops.

- Macros such as IMP_RESTRAINT(), IMP_LOG(), IMP_USAGE_CHECK() are not
  available in Python. While we could, conceivably, provide python
  function equivalents, we do not.

- Oddly, the Python side is much stricter about converting between
  different types. In C++ you can call a function that takes a \c
  Particle* with a \c Decorator and the decorator will automatically
  be converted. It will not on the python side. Similarly for
  converting between \c ParticlesTemp and \c Particles.

- All \imp exceptions are exposed as identical Python exception
classes. The class hierarchy is similar (e.g. all exceptions derive
from IMP::Exception, so "except IMP.Exception" will catch all IMP
exceptions), except for convenience some generic IMP exceptions also
derive from their standard Python equivalents (e.g. IMP.IndexException
derives from the standard Python IndexError as well as
IMP::Exception). Thus, an IMP::IndexException could be caught in
Python most specifically with "except IMP.IndexException" but also
with "except IMP.Exception" or "except IndexError".

- All objects in python are reference counted so that they are cleaned
up when they are no longer in use. \imp also uses reference counting
on the C++ side so that memory managment works naturally across the
language barrier. See IMP::RefCounted for a detailed description of
how to do \imp reference counting in C++.


\section conventions IMP conventions

    To ensure consistency and ease of use, certain conventions should be
    adhered to when writing code using or in \imp.

    \subsection physical Measurements
    Unless these is a good reason, the following units are be used
    - angstrom for all distances
    - kcal/mol angstrom for forces/derivatives
    - kcal/mol for energies
    - radians for angles. All angles are counterclockwise.

    Anything that breaks from these conventions must be labeled
    clearly and accompanied by an explaination of why the normal units
    could not be used.

    \section storage Passing and storing data

    - 3D points and vectors are stored and passed using
      IMP::algebra::Vector3D objects.

    - 3D rotations are stored and passed using
      IMP::algebra::Rotation3D objects.

    - Likewise for spheres (IMP::algebra::Sphere3D), segments
      (IMP::algebra::Segment3D) etc.

    - Collections of object \c Name are passed using the type \c Names. For
    example, a bunch of IMP::algebra::Vector3D objects is passed using
    a IMP::algebra::Vector3Ds type, and a bunch of IMP::Restraint
    objects is passed using IMP::Restraints (or, equivalently
    IMP::RestraintsTemp).

    \subsection names Names in IMP
    - Class names are be in \c CamelCase, for example \c class \c SpecialVector'
    - For each type of object in \imp, \c Name, there is a type \c Names
      which is used to pass a list of objects of type \c Name. \c Names
      look like an \c std::vector in C++ or a \c list in Python. Sometimes,
      for efficiency, a \c NamesTemp is passed instead
      (see \ref tempornot "when to use Temp values" for the reason). \c Names
      will be converted into \c NamesTemp without cost, so the distinction
      should not matter for the caller.
    - method names and variables should be \c separated_by_underscores, for
      example \c void \c SpecialVector::add_constant(int the_constant)'
    - member methods that change a value begin with \c set_
    - member methods which return a value begin with \c get_
    - all preprocessor symbols (things created by \c \#define) begin with \c %IMP_
    - Abbreviations are not used in names except when the abbreviation is more
    common than the unabreviated name.

    \subsection objects Values and Objects
    \anchor values
    As is conventional in C++, \imp classes are divided into two types
    - value classes which are be passed, stored, and returned by value
      (or, for speed, \c const&). Examples include IMP::algebra::Vector3D,
      collections such as IMP::Restraints or IMP::RestraintsTemp, or
      decorators, such as IMP::core::XYZ.

    - object classes which are passed and returned via pointers and
      stored using reference counted pointers (eg IMP::Pointer). In
      \imp, these classes all inherit from IMP::Object.
      \anchor tempornot Since reference counting can be expensive,
      it can be useful to pass, return or store a non-reference
      counted list of objects (or IMP::Decorator). This should only
      be done when it is known to be safe. If you can't figure out
      that it is, don't do it. If it is safe, pass a \c NamesTemp
      instead of a \c Names.  

    Python does not have this distinction.


    \section errors Errors
    Classes and methods use IMP exceptions to report errors. See
    IMP::Exception for a list of existing exceptions. These C++
    exceptions are mapped onto the normal python exception types.

\section incremental Incremental Scoring
    Scoring in IMP can be performed in two different ways....

    Incremental scoring  works as follows:

    To set it up call IMP::Model::set_is_incremental() with the value \c true. This
    -# calls regular evaluate on all incremental restraints
    -# a shadow particle is added to each particle. The shadow particles have all the same attributes. It is accessed using IMP::Particle::get_prechange_particle()
    -# saves copies of their derivatives to the shadow particles

    When evaluate is called during optimization
    -# the derivatives are cleared on all the particles (but not the shadow particles)
    -# incremental restraints are evaluated. They need to make sure that the the change in the sum of the particle and shadow particle derivatives is equal to the change in derivatives and that the actual score is returned.
    -# derivatives are added to the shadow derivatives and then cleared
    -# the non-incremental restraints are then evaluated
    -# the derivatives of the shadow particles are added to the particle derivatives
    -# after scoring, all the particles are marked as clean and shadow particles are updated to reflect the current attributes of the particles

    A IMP::Restraint is an incremental restraint if IMP::Restraint::get_is_incremental() returns true. For such restraints,
    IMP::Restraint::incremental_evaluate() is called instead of IMP::Restraint::evaluate().

    Whenever a particle is changed is marked as dirty, so that IMP::Particle::get_is_changed() returns true.

    A (perhaps partial) list of classes which benefit from incremental evaluation is:
    - IMP::core::IncrementalBallMover

\section fixbug Reporting bugs in IMP

While we strive for perfection, we, lamentably, slip up from time to
time. If you find a bug in \imp, please report it on the
\salilab{imp/bugs/,IMP bug tracker}. This will ensure it does not get
lost.  The best way to report a bug is to provide a short script file
that demonstrates the problem.


*/
