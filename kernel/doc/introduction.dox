/**
\page introduction An Introduction to IMP

\imp is a library for solving a a wide variety of molecular structures and
dynamics using many different data sources. As a result, it is provides a
great deal of flexibility. In order to best make the required decisions
about how to use \imp to solve a particular problem, it is useful to
understand the overall structure of \imp.

\section im1 Theory

Structure and dynamics modeling in \imp proceeds in a five stage iterative process
 -# Gathering of experimental data
 -# Choice of the representation scheme for the model
 -# Encoding of the data as a scoring function on the representation scheme
 -# Sampling of the possible models in the representation scheme to try to find good models
 -# Analysis of the found models to determine if more work is needed

\imp provides tools to help address the last four of these stages. Unfortunately, it doesn't offer much help performing the experiments. We are working on that.

Knowledge about the system being modeled enters the process at all stages, but a few need extra note:
- A certain amount of knowledge is encoded as "constraints". These are choices made in choosing the representation scheme that force relationships between parts to always hold. For example, representing part of the system as a rigid body, means that none of the distances or angles within the rigid body ever change.

- Other knowledge is encoded as restraints via scoring functions that penalize models which don't fit that bit of information.

- Knowledge can also be used to tune the sampling scheme by choosing starting configurations, the discrete sample etc.

\section i0 Architecture
 
\imp provides a large number of classes and functions from which to choose when solving a particular problem. Fortunately, these classes fall into a variety of categories.

- Representation: The model in \imp is represented as a collection
  of IMP::Particle objects, stored in the IMP::Model. The
  IMP::Particle class provides storage for arbitrary data, and as such is
  not that easy to use directly. To ease use, \imp provides a layer on
  top of particles called decorators. A decorator wraps an existing
  particle and provides a simplified interface to access and
  manipulate a certain type of data. For example, the IMP::core::XYZ
  decorator decorates a particle to provide easy access to and
  manipulation of the cartesian coordinates; the IMP::atom::Hierarchy
  decorator with the associated IMP::atom::Atom, IMP::atom::Residue
  etc. decorators provide a standard representation of molecular
  structures; the IMP::core::RigidBodyDecorator represents part of the
  model rigidly etc. See the \ref decorators "Decorators" page for
  more information.

- Scoring: Proposed models are scored based on how well they match the
  data. In \imp the scoring function is the sum of restraint
  terms. Each restraint term has a corresponding IMP::Restraint object
  which computes a score and derivatives based on a set of particles
  in the IMP::Model. Restraints can be such things as how well a set of
  particles fits an EM density map (IMP::em::FitRestraint), how close
  the volume of a molecule is to a known value (IMP::core::VolumeRestraint),
  penalize a set of spheres if they become disconnected
  (IMP::core::ConnectivityRestraint) etc.

- Sampling: It is then necessary to search for conformations of the model that
  have low scores (and therefore fit the data well). Sampling produces a set of
  conformations of the model, organized into an IMP::ConformationSet. Currently
  \imp provides two sampling protocols, IMP::core::MCCGSampler which uses a
  combination of Monto Carlo and Conjugate Gradients with randomized starting
  conformations and IMP::domino::DominoOptimizer which uses a graph based
  inference algorithm.

- Analysis: Finally, one needs to analyze the set of conformations produced by
  sampling. \imp provides a variety of tools to help display the conformations,
  in IMP::display, and to cluster them, in IMP::statistics. 

Coming up with the right choices for representation, scoring and sampling for
a given system typically takes a few iterations and trial and error. \imp
provides tools to help monitor how things are performing.

- Logging: most actions in \imp can produce logged information to help understand
  what is going on. The amount of logging information produced can be controlled
  globally using the IMP.set_log_level() function, passing it one of the IMP::LogLevel
  values. In addition, restraints, samplers, constraints (and all objects which inherit
  from IMP::Object) have an internal log level that overrides the global one. To set
  that call the IMP::Object::set_log_level() function on that object. Setting the log
  level to IMP::VERBOSE will produce a huge amount of information during a typical
  sampling run. IMP::TERSE is generally better. Make sure to set it to at least
  IMP::WARNING to make sure that you don't miss any important warnings.

- Usage checking: \imp can perform a lot of checks that it is being used correctly
  as well as that it is behaving correctly. The checks being performed are controlled
  by the IMP::set_check_level() function call. Set the check level to IMP::USAGE to
  make sure that all parameters passed are correct. Set it to IMP::USAGE_AND_INTERNAL
  if you are developing new restraints or sampling protocols or are worried that
  \imp is malfunctioning.

- IO: \imp supports I/O to and from a variety of formats. To preserve the maximum amount
  of information, one can used the IMP::core::read() and IMP::core::write() methods to
  save and load a whole model to a human (and machine) readable file. IMP::display supports
  export to a wide variety of graphical display formats and IMP::atom::read_pdb() and
  IMP::atom::write_pdb() provide PDB-centric I/O.


\section i6 Examples
The following examples all are in Python and C++.

The following setup code is ommitted from the Python examples for clarity:
\htmlinclude setup.py.html

The following setup code is ommitted from the C++ examples for clarity:
\code
#include <IMP.h>
#include <IMP/core.h>

IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::core::SingletonContainer ps;
for (int i=0; i< 100; ++i) {
    IMP::Particle* p=new IMP::Particle();
    ps->add_particle(p);
    m->add_particles(p);
    IMP::core::XYZRDecorator d= IMP::core::XYZRDecorator::setup_particle(p);
    d.set_coordinates_are_optimized(true);
    d.set_coordinates(IMP::random_vector_in_box());
    d.set_radius(1.0);
}

\endcode

See the \ref examples "Examples Page" for a full list of examples.



\section i7 Restrain some distances

Restrain the distance between the first two particles.

\htmlinclude pair_restraint.py.html


\code
IMP::core::Harmonic *uf= new IMP::core::Harmonic(0,1);
IMP::core::SphereDistancePairScore *df= new IMP::core::SphereDistancePairScore(uf);
IMP::core::PairRestraint* r= new IMP::core::PairRestraint(df, ps->get_particle(0), ps->get_particle(1));
m->add_restraint(r);
\endcode



\section i8 Preventing collisions
The IMP::core::ClosePairsContainer maintains a list of all pairs of particles which contains all pairs closer than min distance (between the spheres). The HarmonicLowerBound forces the spheres apart.
\htmlinclude excluded_volume.py.html

\code
IMP::core::ClosePairsContainer *nbl= new IMP::core::ClosePairsScoreState(ps, min_distance);
IMP::core::HarmonicLowerBound* h= new IMP::core::HarmonicLowerBound(0,1);
IMP::core::SphereDistancePairScore *sd= new IMP::core::SphereDistancePairScore(h);
IMP::core::SingletonsRestraint* nbr= new IMP::core::SingletonsRestraint(sd, nbl);
m->add_restraint(nbr);
\endcode







\section i9 Restraining bonds

Load a protein and restrain all the bonds to have the correct length. Bond angles is a bit trickier at the moment.

\htmlinclude load_protein_restrain_bonds.py.html

\code
IMP::core::MolecularHierarchyDecorator prot=IMP::atom::read_pdb("my.pdb", m);
IMP::core::BondDecorators bds= IMP::core::get_internal_bonds(prot);
IMP::Particles ps(bds.size());
for (unsigned int i=0; i< bds.size(); ++i) ps[i]= bds[i].get_particle();
IMP::core::ListSingletonContainer *bl= new IMP::core::ListSingletonContainer(ps);
IMP::core::Harmonic *h= new IMP::core::Harmonic(0,1);
IMP::core::BondDecoratorSingletonScore* bs= new IMP::core::BondDecoratorSingletonScore(h);
IMP::core::SingletonsRestraint *br= new IMP::core::SingletonsRestraint(bs, bl);
m->add_restraint(br);
\endcode







\section i10 Simple optimization setup
A basic setup for optimizing a model.
\htmlinclude basic_optimization.py.html

\code
IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::Particles particles = setup_model(m);

std::string best;
float best_score=std::numeric_limits<IMP::Float>::infinity();

IMP::core::ConjugateGradients o;
o.set_model(m)
for (int i=0; i< 100; ++i) {
    randomize(particles)
    IMP::Float score=o.optimize(1000)
    if (score < best_score) {
       std::ostringstream oss;
       IMP::core::write(m, oss);
       best=oss.str();
       best_score= score;
    }
}
std::istringstream iss(best_score);
IMP::core::read(iss, m);
\endcode

\section i11 Writing a simple restraint
This is actually an IMP::core::SingletonsRestraint. You really wouldn't want to write such a thing in Python, although you can.

\code
class IMPDLLEXPORT MyRestraint: public IMP::Restraint {
      IMP::Pointer<IMP::SingletonScore> ss_;
      IMP::Pointer<IMP::core::SingletonContainer> sc_;
public:
        MyRestraint(IMP::SingletonScore *ss,
                    IMP::core::SingletonContainer *sc): ss_(ss),
                                                        sc_(sc){}
        IMP_RESTRAINT(my_version_info);
};

IMP::Float MyRestraint::evaluate(IMP::DerivativeAccumulator *da) {
      IMP::Float accum=0;
      for (IMP::core::SingletonContainer::ParticlesIterator it = sc_->particles_begin(); 
           it != sc_->particles_end(); ++it) {
          accum += ss_->evaluate(*it, da);
       }
       return accum;
}
IMP::Float MyRestraint::show(std::ostream &out) const {
      out << "MyRestraint on " << sc_->get_number_of_particles() << " particles" << std::endl;
}

IMP::ParticlesList
MyRestraint::get_interacting_particles() const
{
       return IMP::ParticlesList();
}

\endcode


\section i12 Available functionality

Look through the types inherited from these methods to get an idea of the functionality available.

- IMP::Decorator
- IMP::Restraint
- IMP::SingletonScore
- IMP::PairScore
- IMP::TripletScore
- and check out the namespace list above for an orthogonal view


\section i125 Modules

Functionality in \imp is grouped into modules, each with its own
namespace. A module contain classes, methods and data which are
related and owned by a certain set of people. See the "Namespaces"
tab above for a complete list of modules in this version of \imp.

\section i13 C++ vs Python

Most code maps trivially from one to the other as you can see in the
examples.  See \ref differences "Python/C++ differences" for a full
description of the differences between the Python and C++ interfaces
to \imp.

Recommendations:
- write new \imp classes in C++
- use Python to put \imp classes together to handle your data and resulting structures

\section i15 Getting started

The easiest way to get started developing with \imp is to use a local module.
To do this run the \command{./tools/make-module my_module_name} in the
main \imp directory. This will create a new module in modules/my_module. See
\ref make_module "Making a module" for more information.

You should then read the
 - \ref api "API documentation"
 - \ref conventions "Conventions"
 - and \ref coding_conventions "Coding conventions"

*/
