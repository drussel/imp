/**
\page introduction An Introduction to IMP


\section i0 Architecture
 
 There are several key concepts in \imp:
  - Representation: all data is stored as attributes of an IMP::Particle
    - \ref decorators "Decorators" ease use of the particles and help
    maintain invariants
  - Scoring:
    - a IMP::Restraint is used to compute the score of some subset of the particles
    - IMP::ScoreState objects compute maintain high level information about the particles (such as which particles are close to one another)
  - an IMP::Optimizer optimizes the Particles with respect to the Restraints


  - The IMP::Model holds the particles, restraints, and score states.


\section i05 Restraints

 The scoring function for the particles is created by combining various components.
 For example:

  - IMP::core::PairsRestraint applies an arbitrary IMP::PairScore to
    all the pairs of particles in a list of particles

  - this list of particles could be generated from an
    IMP::core::ClosePairsScoreState so that it always contains a list
    of which particles are close to one another

  - the IMP::PairScore could be an IMP::core::SphereDistancePairScore,
    which scores the pair of particles on the distance between the two
    spheres defined by the particles center and radius.

  - the way the IMP::core::SphereDistancePairScore computes a score
    from the distance could be using an IMP::core::HarmonicLowerBound
    so that the particles are repelled.


\section i5 Other important bits
There is good \ref log "logging support":
\code
IMP::set_log_level(IMP.VERBOSE);
IMP_LOG(TERSE, "Something interesting has occurred with variable " 
                 << var << std::endl);
\endcode

\ref assert "Error reporting/checking" which can be controlled at runtime. By default
     some checks are performed. Make sure to turn them off if for maximum speed.
\code
IMP::set_check_level(IMP.EXPENSIVE);
IMP_check(boolean_condition, "An error has occurred with value "
                             << some_value,
                             ExceptionType);
\endcode

The control functions are accessible from Python, but the check and log macros are not.

Saving state
\htmlonly
IMP_PYTHON(fragments/read_write)
\endhtmlonly

\verbatim
IMP::core::write(my_imp_model, "somefile");
IMP::core::read("somefile", my_imp_model);
\endverbatim



\section i6 Examples
The following examples all are in python and C++ The following code is ommitted from the examples:
\htmlonly
IMP_PYTHON(fragments/setup)
\endhtmlonly

\code
#include <IMP.h>
#include <IMP/core.h>

IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::core::SingletonContainer ps;
for (int i=0; i< 100; ++i) {
    IMP::Particle* p=new IMP::Particle();
    ps->add_particle(p);
    m->add_particles(p);
    IMP::core::XYZRDecorator d= IMP::core::XYZRDecorator::create(p);
    d.set_coordinates_are_optimized(true);
    d.set_coordinates(IMP::random_vector_in_box());
    d.set_radius(1.0);
}

\endcode





\section i7 Restraint some distances

Restrain the distance between the first two particles.

\htmlonly
IMP_PYTHON(fragments/pair_restraint)
\endhtmlonly


\code
IMP::core::Harmonic *uf= new IMP::core::Harmonic(0,1);
IMP::core::SphereDistancePairScore *df= new IMP::core::SphereDistancePairScore(uf);
IMP::core::PairRestraint* r= new IMP::core::PairRestraint(df, ps->get_particle(0), ps->get_particle(1));
m->add_restraint(r);
\endcode



\section i8 Preventing collisions
The ClosePairsScoreState maintains a list of all pairs of particles which contains all pairs closer than min distance (between the spheres). The HarmonicLowerBound forces the spheres apart.
\htmlonly
IMP_PYTHON(fragments/excluded_volume)
\endhtmlonly

\code
IMP::core::ClosePairsScoreState *nbl= new IMP::core::ClosePairsScoreState(ps);
nbl->set_distance(min_distance)
m->add_score_state(nbl);
IMP::core::HarmonicLowerBound* h= new IMP::core::HarmonicLowerBound(0,1);
IMP::core::SphereDistancePairScore *sd= new IMP::core::SphereDistancePairScore(h);
IMP::core::SingletonsRestraint* nbr= new IMP::core::SingletonsRestraint(sd, nbl->get_close_pairs_container());
m->add_restraint(nbr);
\endcode







\section i9 Restraining bonds

Load a protein and restrain all the bonds to have the correct length. Bond angles is a bit trickier at the moment.

\htmlonly
IMP_PYTHON(fragments/load_protein_restrain_bonds)
\endhtmlonly

\code
// Currently you can't read a pdb from C++
IMP::core::MolecularHierarchyDecorator prot=???;
IMP::core::BondDecorators bds= IMP::core::get_internal_bonds(prot);
IMP::Particles ps(bds.size());
for (unsigned int i=0; i< bds.size(); ++i) ps[i]= bds[i].get_particle();
IMP::core::ListSingletonContainer *bl= new IMP::core::ListSingletonContainer(ps);
IMP::core::Harmonic *h= new IMP::core::Harmonic(0,1);
IMP::core::BondDecoratorSingletonScore* bs= new IMP::core::BondDecoratorSingletonScore(h);
IMP::core::SingletonsRestraint *br= new IMP::core::SingletonsRestraint(bs, bl);
m->add_restraint(br);
\endcode







\section i10 Simple optimization setup
A basic setup for optimizing a model.
\htmlonly
IMP_PYTHON(fragments/basic_optimization)
\endhtmlonly

\code
IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::Particles particles = setup_model(m);

std::string best;
float best_score=std::numeric_limits<IMP::Float>::infinity();

IMP::core::ConjugateGradients o;
o.set_model(m)
for (int i=0; i< 100; ++i) {
    randomize(particles)
    IMP::Float score=o.optimize(1000)
    if (score < best_score) {
       std::ostringstream oss;
       IMP::core::write(m, oss);
       best=oss.str();
       best_score= score;
    }
}
std::istringstream iss(best_score);
IMP::core::read(iss, m);
\endcode

\section i11 Writing a simple restraint
This is actually an IMP::core::SingletonsRestraint. You really wouldn't want to write such a thing in Python, although you can.

\code
class IMPDLLEXPORT MyRestraint: public IMP::Restraint {
      IMP::Pointer<IMP::SingletonScore> ss_;
      IMP::Pointer<IMP::core::SingletonContainer> sc_;
public:
        MyRestraint(IMP::SingletonScore *ss,
                    IMP::core::SingletonContainer *sc): ss_(ss),
                                                        sc_(sc){}
        IMP_RESTRAINT(my_version_info);
};

IMP::Float MyRestraint::evaluate(IMP::DerivativeAccumulator *da) {
      IMP::Float accum=0;
      for (IMP::core::SingletonContainer::ParticlesIterator it = sc_->particles_begin(); 
           it != sc_->particles_end(); ++it) {
          accum += ss_->evaluate(*it, da);
       }
       return accum;
}
IMP::Float MyRestraint::show(std::ostream &out) const {
      out << "MyRestraint on " << sc_->get_number_of_particles() << " particles" << std::endl;
}

IMP::ParticlesList
MyRestraint::get_interacting_particles() const
{
       return IMP::ParticlesList();
}

\endcode


\section i12 Available functionality

Look through the types inherited from these methods to get an idea of the functionality available.

- IMP::DecoratorBase
- IMP::Restraint
- IMP::SingletonScore
- IMP::PairScore
- IMP::TripletScore
- and check out the modules page for an orthogonal view


\section i125 Modules
Functionality in \imp is grouped into modules. Each module contails classes,
methods and data which are related and "owned" by a certain set of people. Examples
of current modules include
- IMP.core which includes functionality used by almost all \imp modules
- IMP.algebra which contains math-related functionality used by other modules
- IMP.em which contains functionality for fitting moleculars to EM maps
- IMP.saxs which contains functionality for fitting molecules to SAXS data

\section i13 C++ vs Python

Most code maps trivially from one to the other as you can see in the example.
- have to declare variables in C++
- need to know about smart pointers (use IMP::Pointer to store pointers)
- memory management is a bit of a mess in Python
- a few things can only be done in one language or the other (pdb files in python)

Debugging is much easier in C++.
- hard to inspect objects in python

Easier to experiment in Python.
- we don't have good doc strings though and no str(foo)

Recommendations:
- write restraints and decorators in C++
- never inherit from a C++ object in Python: the python wrapper we use does not manage memory properly.



\section i15 Getting started

The easiest way to get started developing with \imp is to use a local module.
To do this run the \command{./kernel/doc/bin/make-module my_module} in the
main \imp directory. This will create a new module in modules/my_module. See
\ref make_module "Making a module" for more information.

You should then read the
 - \ref api "API documentation"
 - and \ref coding_conventions "Coding conventions"

*/
