/** 
\page codingconventions Coding conventions

Make sure you read the \ref conventions "API conventions" page
first.

To ensure code consistency and readability, certain conventions
must be adhered to when writing code for \imp. Some of these
conventions are automatically checked for by source control before
allowing a new commit, and can also be checked yourself in new
code by running \command{scons standards}

\section indent Indentation

All C++ headers and code should be indented in 'Linux' style, with
2-space indents. Do not use tabs. This is roughly the output of
Artistic Style run like \command{astyle --convert-tabs
--style=linux --indent=spaces=2 --unpad=paren --pad=oper} Split
lines if necessary to ensure that no line is longer than 80
characters.

    \b Rationale: Different users have different-sized windows or
    terminals, and different tab settings, but everybody can read 80
    column output without tabs.

    All Python code should conform to the
    \external{www.python.org/dev/peps/pep-0008/, Python style guide}.
    In essence this
    translates to 4-space indents, no tabs, and similar class, method
    and variable naming to the C++ code. You can ensure that your
    Python code is correctly indented by using the
    \command{tools/reindent.py} script, available as part of the \imp
    distribution.

    \section docs Documentation

    Format to allow Doxygen automated documentation creation. If
    possible, and appropriate, specify both a 'brief' description and
    a more detailed one (in which parameters, return values, and
    exceptions are documented). Use \c //! for the one-line brief
    description and \c /** ... * / for the multi-line detailed
    description (put the closing * / on a new line, so that these
    comments are always multi-line (Doxygen will not accept both a
    'brief' comment and a one-line detailed comment). All header and
    source files should have a starting comment header, using the
    \b \\file command to document the purpose of the file.

    For example:
    \verbatim
    //! Calculates the square root.
    /** \param[in] the_value Calculate the square root of this value.
        \exception ValueException if value is out of range (negative).
        \return the square root of the given value.
      */
    \endverbatim

    Python code should provide Python doc strings.

    We provide a number of \ref doxygen_commands "additional commands to help with documentation".


    \section names Names

    See the names section of the \ref conventions "IMP conventions" page.
    In addition, developers should be aware that
    - all preprocessor symbols (things created by \#define) must begin with \c IMP
    - names of files that implement a single class should be named for that
      class; for example the SpecialVector class could be implemented in
      \c SpecialVector.h and \c SpecialVector.cpp
    - files that provide free functions or macros should be given names
      \c separated_by_underscores, for example \c container_macros.h
    - Functions which take a parameter which has units should have the
      unit as part of the function name, for example
      IMP::atom::BrownianDynamics::set_time_step_in_femtoseconds().
      Remember the Mars orbiter. The exception to this is distance
      and force numbers which should always be in angstroms and
      kcal/mol angstrom respectively unless otherwise stated.

    \b Rationale: This makes it easier to tell between class names and
    function names where this is ambiguous (particularly an issue with
    the Python interface). The Python guys also mandate CamelCase for
    their class names, so this avoids any need to rename classes
    between C++ and Python to ensure clean Python code. Good naming is
    especially important with preprocessor symbols since these have
    file scope and so can change the meaning of other people's code.

\section datastorage Passing and storing data

- When a class or function takes a set of particles which are expected to
  be those of a particular type of decorator, it should take a list of
  decorators instead. eg IMP::core::transform() takes a IMP::core::XYZ.
  This makes it clearer what attributes the particle is required to have
  as well as allows functions to be overloaded (so there can be an
  IMP::core::transform() which takes IMP::core::RigidBody particles instead).


- IMP::Restraint and IMP::ScoreState classes should generally use a
      IMP::SingletonContainer (or other type of Container) to store the set of
      IMP::Particle objects that they act on.

- Store collections of IMP::Object-derived or IMP::Decorator-derived
  objects of type \c Name using a \c Names. Declare functions that
  accept them to take a \c NamesTemp (\c Names is a \c NamesTemp). \c
  Names are reference counted (see IMP::RefCounted for details), \c
  NamesTemp are not.

\section display Display

All classes must have a \c show method which takes an optional 
\c std::ostream and prints information about the object. The helper
macros, such as IMP_RESTRAINT() define such a method.  In addition they
must have \c operator<< defined. This can be easily done using the
IMP_OUTPUT_OPERATOR() macro once the show method is defined. Note that
\c operator<< writes human readable information. Add a \c write method
if you want to provide output that can be read back in.


\section errors Errors

Classes and methods should use IMP exceptions to report errors. See
IMP::Exception for a list of existing exceptions. See \ref assert for
a list of functions to aid in error reporting and detection.


\section internal_ns Namespaces

Use the provided \c IMPMODULE_BEGIN_NAMESPACE,
	  \c IMPMODULE_END_NAMESPACE, \c IMPMODULE_BEGIN_INTERNAL_NAMESPACE 
	  and \c IMPMODULE_END_INTERNAL_NAMESPACE macros to put declarations 
	  in a namespace appropriate for module \c MODULE.

Each module has an internal namespace, \c module_name::internal and an internal
include directory \c modulename/internal. Any function which is
 - not intended to be part of the API,
 - not documented,
 - liable to change without notice,
 - or not tested

should be declared in an internal header and placed in the internal namespace.

The functionality in such internal headers is
 - not exported to python
 - and not part of of documented API

As a result, such functions do not need to obey all the coding conventions
(but we recommend that they do).
*/
