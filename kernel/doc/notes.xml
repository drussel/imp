<chapter id="newinterface">
<title>New &IMP; interface</title>

<para>This describes the transition to a new interface for &IMP;. Some
functionality has been lost or at least not yet re-implemented, but the
overhead for adding restraints and optimizers has been reduced. To add a
restraint you just define the constructor, destructor (often empty), and the
evaluate method.  To add an optimizer you just define the constructor (often
empty), destructor (often empty), and the optimize method. Another advantage
of the new interface is that it is intended to be more tightly integrated
with Python (a la Javier's request). The model, its particles and restraints,
can be constructed in Python component by component rather than relying on
reading in files via IMP.</para>

<sect1 id="addrsr">
<title>Adding a Restraint</title>

<para>Create file <filename>MyRestraint.h</filename> in the
<filename>restraints</filename> directory (use another file as a
model; e.g. <filename>DistanceRestraint.h</filename>).</para>

<note><para>Make sure you change the #define value to match the new file name
or it won't get compiled.</para></note>

<para>Create file <filename>MyRestraint.cpp</filename> (use another file as a
model; e.g. <filename>DistanceRestraint.cpp</filename>).</para>

<para>Define the constructor, destructor, and evaluate method.</para>

<para>Add header file name to <filename>pyext/IMP.i</filename> (for SWIG) and
the C++ file name to <filename>SConstruct</filename>.</para>

<para>Recompile the shared library and the restraint should now be available
through Python. If you want, you can also define a syntax and code for loading
the restraint from a text file by modifying the
<filename>ModelLoader.cpp</filename> code.</para>

</sect1>


<sect1 id="optimizer">
<title>Optimizer</title>

<para>An optimizer has an <methodname>optimize</methodname> method that can
be applied to the model that is passed as an argument. The optimization
continues until the max_steps are taken or the score threshold is reached.
</para>

<sect2 id="optinterface">
<title>Interface</title>

<para>See the <ulink url="&doxygen;classIMP_1_1Optimizer.html"><classname>IMP::Optimizer</classname> class reference</ulink>.</para>

</sect2>

<sect2 id="optissues">
<title>Issues</title>

<para>Still need to work out the right way to handle
<emphasis>constraints</emphasis> (e.g. rigid bodies).</para>

</sect2>

<sect2 id="opthistory">
<title>Historical notes</title>
	
<para><classname>Optimizer</classname> was contained within
<classname>Model</classname> until we deviated away from the pattern of using
the <classname>Model</classname> as containing the API from which most methods
are called.</para>
	
<para>Score and score derivatives had their own type. However, it was suggested
that since the compiler does not enforce the typedef types, this might cause
confusion later on if the policy wasn't always adhered to and then the type
was aliased to a new underlying type.</para>

</sect2>

</sect1>

<sect1 id="model">
<title>Model</title>

<para>An <classname>IMP::Model</classname> contains the particles and restraints that act on those
particles. It can be optimized with respect to the restraints and particles
that it contains.</para>

<sect2 id="modelinterface">
<title>Interface</title>

<para>See the <ulink url="&doxygen;classIMP_1_1Model.html"><classname>IMP::Model</classname> class reference</ulink>.</para>
</sect2>

</sect1>

<sect1 id="particle">
<title>Particle</title>

<para>A particle is an entity within the model that has attributes with
associated values.</para>

<sect2 id="particleinterface">
<title>Interface</title>
<para>See the <ulink url="&doxygen;classIMP_1_1Particle.html"><classname>IMP::Particle</classname> class reference</ulink>.</para>
</sect2>

<sect2 id="particleissues">
<title>Issues</title>

<para>A key issue is how to remove particles. Removing particles has at least
two complications. The indexed attributes (see
<classname>ModelData</classname>) cannot actually be removed without
disrupting the indexes used by other particles. Reuse also runs the risk of
the new particle being used although the index was intended for the old one.
Another complication is that it is not clear what the best way to handle
restraints that reference a particle that has been deleted. Concerns have
been raised about methods that require the restraint writer to do the
bookkeeping.</para>

<para>A proposed solution to the first complication is to deactivate rather
than physically remove particles. Deactivated particles will continue to
take up space in memory, but all indexes will continue to refer correctly
to the associated particle attributes.</para>

<para>A proposed solution to the second complication is to provide some
functionality in the <classname>Restraint</classname> base class that will
deactivate the restraint if any particles in the maintained list of particles
is deactivated. The restraint writer can override this behavior if it is
not appropriate for their particular restraint type.</para>
</sect2>

<sect2 id="particlehistory">
<title>Historical notes</title>

<para>Variables were initially handled separated from Float attributes.
However, to simplify the interface, all Float attributes have can be
optimizable variables if the appropriate flag is set. The disadvantage of
this approach is that some storage space is allocated for all Float
attributes that will not be used for those that are not optimized.</para>

</sect2>
</sect1>

<sect1 id="rsrset">
<title>RestraintSet</title>

<para>A restraint set is a container holding restraints and other restraint
sets. It can also hold filters that can be used to deactivate some of the
restraints.</para>

<sect2 id="rsrsetinterface">
<title>Interface</title>
<para>See the <ulink url="&doxygen;classIMP_1_1RestraintSet.html"><classname>IMP::RestraintSet</classname> class reference</ulink>.</para>
</sect2>

<sect2 id="rsrsetissues">
<title>Issues</title>

<para>None of the methods are virtual here. The hope is that all restraint
set functionality can be provided by the base class and will not be
subclassed.</para>
</sect2>

<sect2 id="rsrsethistory">
<title>Historical notes</title>

<para>Restraint sets were initially a subclass of Restraints but it ended up
being easier to keep them separate, so analogous functions are now overloaded
rather than accessed via polymorphism. This was done in part to implement
filters in a different way. Filters will be added to restraint sets and
applied in the order that they are added. Previously, Filters were restraint
sets that were applied to the restraints and restraint sets that they
contained (including other filters). The approaches are basically equivalent.
</para>

<para>The model only contains restraint sets rather than individual restraints.
The restraint sets are named, but the Model interface no longer provides a
method for turning off restraints by hand. This functionality must be coded
by sequencing through the restraint sets.</para>
</sect2>

</sect1>

<sect1 id="restraint">
<title>Restraint</title>

<para>A restraint uses the current state of some subset of particles of the
model to determine a feature of the model and a score with respect to that
feature. It can also calculate first derivatives for the score with respect
to the feature and subsequently to the different particle attributes to
provide a gradient in a direction that will reduce the current score.</para>

<sect2 id="restraintinterface">
<title>Interface</title>
<para>See the <ulink url="&doxygen;classIMP_1_1Restraint.html"><classname>IMP::Restraint</classname> class reference</ulink>.</para>
</sect2>


<sect2 id="restraintissues">
<title>Issues</title>

<para><methodname>check_particles_active()</methodname> is meant to be
invisible to most users and almost no one should override this method unless
they are defining a restraint where they are going to allow some particles
within the restraint to be inactivated while still calculating some score
based on the remaining particles.</para>
</sect2>

<sect2 id="restrainthistory">
<title>Historical notes</title>

<para>Restraints were definable for a set of sets of particles so that a
large number of similar restraints could be easily defined and efficiently
specified and stored. This capability has been removed and current restraints
tend to refer to one feature for one set of particles.</para>

<para>However, it is still possible for a restraint to in fact represent a
set of related restraints. It also might make sense for similar restraints
that can use the same proximal pair list (non-bonded pair list) to be
combined into a single restraint and for a pointer to that list to be held
within the restraint. The restraints that use the list could then check
before they re-evaluate whether the list needs to be updated. It might thus
be possible to prevent any knowledge of the proximal pair list in the
optimizers which seems desirable.</para>
</sect2>
</sect1>

<sect1 id="modeldata">
<title>ModelData</title>

<para>The model data refers to all of the attributes of the model and their
associated values. Currently, all attributes are associated with particles
but this need not be the case. For example, a restraint could add optimizable
variables to the model data.</para>

<para>The currently supported data types are Float, Int, and String. All
Float values are considered potentially optimizable and have space allocated
for storing derivatives. Also, groups of optimized variables with the same
name reference in Particle instances have their statistics associated with
changes in state saved in Model. For example, "X" variable for all particles
would have a set of statistics that can be reached in Model with the name "X".
</para>

<sect2 id="modeldatainterface">
<title>Interface</title>
<para>See the <ulink url="&doxygen;classIMP_1_1ModelData.html"><classname>IMP::ModelData</classname> class reference</ulink>.</para>
</sect2>

<sect2 id="modeldataissues">
<title>Issues</title>

<para>There is some question what is the best way to sequence through a list.
Here we are using reset(), next(), and get(), which is common and is easy to
access and use through Python. Here OptFloatIndexIterator is used to get
all of the Float attributes that are being optimized.</para>

<para>The inconsistency of naming of the accessors here is due to fact that
the normal method (the word alone without the get_ prefix) is disallowed
because they are keywords.</para>
</sect2>

<sect2 id="modeldatahistory">
<title>Historical notes</title>

<para>This new storage scheme is intended to allow efficiencies near those
of one dimensional arrays for each variable type but allow particles to have
very different attributes without lots of unused memory locations.</para>

</sect2>
</sect1>

</chapter>
