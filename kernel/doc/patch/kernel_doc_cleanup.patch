Index: kernel/test/run-all-tests.py
===================================================================
--- kernel/test/run-all-tests.py	(revision 1087)
+++ kernel/test/run-all-tests.py	(working copy)
@@ -1 +1,26 @@
-link ../../tools/run-all-tests.py
\ No newline at end of file
+import unittest, sys, os, re
+
+def regressionTest():
+    """Run all tests in files called test_*.py in current directory and
+       subdirectories"""
+    path = os.path.dirname(sys.argv[0])
+    if path == '':
+        path = '.'
+    # Tell test cases where to find any input files needed
+    os.environ['TEST_DIRECTORY'] = path
+    modobjs = []
+    for subdir in [''] + [x for x in os.listdir(path) \
+                          if os.path.isdir(os.path.join(path, x))]:
+        files = os.listdir(os.path.join(path, subdir))
+        test = re.compile("^test_.*\.py$", re.IGNORECASE)
+        files = filter(test.search, files)
+        modnames = [os.path.splitext(f)[0] for f in files]
+        sys.path.insert(0, os.path.join(path, subdir))
+        modobjs.extend([__import__(m) for m in modnames])
+        sys.path.pop(0)
+
+    tests = [unittest.defaultTestLoader.loadTestsFromModule(o) for o in modobjs]
+    return unittest.TestSuite(tests)
+
+if __name__ == "__main__":
+    unittest.main(defaultTest="regressionTest")
Index: kernel/test/particles/test_refcount.py
===================================================================
--- kernel/test/particles/test_refcount.py	(revision 1087)
+++ kernel/test/particles/test_refcount.py	(working copy)
@@ -34,8 +34,7 @@
         self._check_number(0)
 
         m= IMP.Model()
-        p= IMP.Particle()
-        m.add_particle(p)
+        p= IMP.Particle(m)
         self._check_number(1)
 
         p=1
@@ -47,8 +46,8 @@
         """Check that ref counting works with removing particles"""
         self._check_number(0)
         m= IMP.Model()
-        p= IMP.Particle()
-        pi= m.add_particle(p)
+        p= IMP.Particle(m)
+        pi= p.get_index()
         self._check_number(1)
         m.remove_particle(pi)
         self._check_number(1)
@@ -86,10 +85,10 @@
         self._check_number(0)
         m= IMP.Model()
         print 7
-        p= IMP.Particle()
+        p= IMP.Particle(m)
         print p
         print 8
-        pi= m.add_particle(p)
+        pi= p.get_index()
         print 9
         p=None
         self._check_number(1)
@@ -141,8 +140,8 @@
         """Check that removed particles are skipped"""
         print "skipped"
         m= IMP.Model()
-        p= IMP.Particle()
-        pi= m.add_particle(p)
+        p= IMP.Particle(m)
+        pi= p.get_index()
         ps= m.get_particles()
         self.assertEqual(len(ps), 1, "Should only be 1 particle")
         m.remove_particle(pi)
Index: kernel/include/Model.h
===================================================================
--- kernel/include/Model.h	(revision 1087)
+++ kernel/include/Model.h	(working copy)
@@ -28,6 +28,10 @@
 //! Class for storing model, its restraints, and particles.
 /** The Model maintains a standard IMP container for each of Particle,
     ScoreState and Restraint object types.
+
+    \note Think carefully about using the iterators over the entire set
+    of Particles or Restraints. Most operations should be done using
+    a user-passed set of Particles or Restraints instead.
  */
 class IMPEXPORT Model: public Object
 {
@@ -35,9 +39,10 @@
   friend class Restraint;
   unsigned int iteration_;
 public:
-  //!
+  /** Construct and empty model */
   Model();
-  //!
+  /** Particles, ScoreStates and Restraints are ref-counted so they
+      will be deleted if no other Pointers to them held. */
   ~Model();
 
   IMP_CONTAINER(Particle, particle, ParticleIndex);
Index: kernel/include/VersionInfo.h
===================================================================
--- kernel/include/VersionInfo.h	(revision 1087)
+++ kernel/include/VersionInfo.h	(working copy)
@@ -19,6 +19,7 @@
 class IMPEXPORT VersionInfo
 {
 public:
+  //! Create a VersionInfo object with the given author and version.
   VersionInfo(std::string author, std::string version) : author_(author),
                                                          version_(version) {}
 
Index: kernel/include/Restraint.h
===================================================================
--- kernel/include/Restraint.h	(revision 1087)
+++ kernel/include/Restraint.h	(working copy)
@@ -25,6 +25,8 @@
 
 IMP_BEGIN_NAMESPACE
 
+//! Sets of Particles
+/** This is primarily used for representing lists of interacting particles */
 typedef std::vector<Particles> ParticlesList;
 
 class Model;
@@ -51,6 +53,8 @@
     without ever having been added to a model as this is an easy mistake
     to make. To disable this warning for a particular restraint, call
     set_was_owned(true).
+
+    See the \ref restraint example for how to implement a simple restraint.
  */
 class IMPEXPORT Restraint : public RefCountedObject
 {
Index: kernel/include/DecoratorBase.h
===================================================================
--- kernel/include/DecoratorBase.h	(revision 1087)
+++ kernel/include/DecoratorBase.h	(working copy)
@@ -15,7 +15,20 @@
 IMP_BEGIN_NAMESPACE
 
 /** A base class for decorators. Implementers of decorators should
-    just inherit from this and then use the IMP_DECORATOR macro
+    just inherit from this and then use the IMP_DECORATOR macro to
+    provide the key implementation. If you do not use the IMP_DECORATOR
+    macro, you should instead implement
+    - MyDecorator(Particle *p) which creates a decorator from a particle
+      which is assumed to have the needed attributes.
+    - MyDecorator::cast(Particle*p) which creates a decorator from a particle
+      after checking that it has the needed attributes. An InvalidStateException
+      should be thrown if it does not.
+    - MyDecroator::create(Particle *p) which adds the required attributes to
+      particle which is assumed not to have them and throws an
+      InvalidStateException if there is a problem.
+
+    \note Remember that attribute keys should always be created lazily
+    (at the time of the first use), and not be created as static variables.
 */
 class DecoratorBase
 {
Index: kernel/include/ParticleRefiner.h
===================================================================
--- kernel/include/ParticleRefiner.h	(revision 1087)
+++ kernel/include/ParticleRefiner.h	(working copy)
@@ -49,11 +49,12 @@
     out << "ParticleRefiner base" << std::endl;
   };
 
+  //! Get information about the author and version
   virtual IMP::VersionInfo get_version_info() const =0;
 
   IMP_REF_COUNTED_DESTRUCTOR(ParticleRefiner)
 };
-
+//! a collection of ParticleRefiner objects
 typedef std::vector<ParticleRefiner*> ParticleRefiners;
 typedef Index<ParticleRefiner> ParticleRefinerIndex;
 
Index: kernel/include/container_macros.h
===================================================================
--- kernel/include/container_macros.h	(revision 1087)
+++ kernel/include/container_macros.h	(working copy)
@@ -13,8 +13,6 @@
 #include "internal/ObjectContainer.h"
 #include "macros.h"
 
-/** \internal
- */
 #define IMP_CONTAINER_CORE(protection, Ucname, lcname, Data, IndexType,\
 Container)                                  \
 protection:                                                          \
@@ -44,19 +42,21 @@
 /** \short A const iterator through the objects.
 The value type is a pointer.*/                                     \
 typedef Container::const_iterator Ucname##ConstIterator;               \
+/** Begin iterating through container */                               \
 Ucname##Iterator lcname##s_begin() {return lcname##_vector_.begin();}  \
+/** End iterating through container */                               \
 Ucname##Iterator lcname##s_end() {return lcname##_vector_.end();}      \
+/** Begin iterating through container */                               \
 Ucname##ConstIterator lcname##s_begin() const {                        \
 return lcname##_vector_.begin();}                                    \
+/** End iterating through container */                               \
 Ucname##ConstIterator lcname##s_end() const {                          \
 return lcname##_vector_.end();}                                      \
 private:                                                                \
-/** \internal */                                                       \
 Container lcname##_vector_;                                            \
 protection:
 
-/** \internal
- */
+
 #define IMP_CONTAINER_CORE_IMPL(Class, Ucname, lcname, Data, IndexType, \
 Init_obj, Onchanged)                    \
 IndexType Class::add_##lcname(Data obj) {                             \
@@ -78,20 +78,23 @@
 }                                                                   \
 Onchanged;                                                          \
 }                                                                     \
-/** \short Clear the contents of the container */                     \
 void Class::clear_##lcname##s(){                                      \
 lcname##_vector_.clear();                                           \
 Onchanged;                                                          \
 }                                                                     \
 
 
-//! Use this to add a container of IMP objects
-/**
+//! Use this to add a list of objects to a class.
+/** The difference between a IMP_LIST and IMP_CONTAINER is that an
+ IMP_CONTAINER uses Index objects to return access to the objects and this
+ container just uses ints.
+
  Such a container adds public methods add_foo, get_foo, get_number_of_foo
  and a private type foo_iterator, with methods foo_begin, foo_end.
- \param[in] protection The level of protection for the container.
- \param[in] Ucname The name of the type in uppercase
- \param[in] lcname The name of the type in lower case
+ \param[in] protection The level of protection for the container
+ (public, private).
+ \param[in] Ucname The name of the type of container in uppercase.
+ \param[in] lcname The name of the type of container in lower case.
  \param[in] Data The type of the data to store.
 
  \note the type Ucnames must be declared and be a vector of
@@ -99,6 +102,8 @@
  */
 #define IMP_LIST(protection, Ucname, lcname, Data)                      \
 protection:                                                           \
+/** @name Methods acting on a contained list*/                        \
+/*@{*/                                                                \
 /** \short Remove any occurences of d from the container */           \
 void erase_##lcname(Data d);                                          \
 /** \short Get a container of all the objects.
@@ -111,13 +116,21 @@
 add_##lcname##s(ps);                                                \
 }                                                                     \
 IMP_CONTAINER_CORE(protection, Ucname, lcname, Data, unsigned int,    \
-IMP::internal::Vector<Data>)
+IMP::internal::Vector<Data>)                                          \
+/*@}*/                                                                \
 
 
 
-//! Use this to add a container of IMP objects
+
+//! This should go in a .cpp file for the respective class.
 /**
  This code should go in a .cpp file. One macro for each IMP_CONTAINER.
+ \param[in] The name of the class containing this container.
+ \param[in] protection The level of protection for the container
+ (public, private).
+ \param[in] Ucname The name of the type of container in uppercase.
+ \param[in] lcname The name of the type of container in lower case.
+ \param[in] Data The type of the data to store.
  \param[in] init Code to modify the passed in object. The object is obj
  its index index.
  \param[in] OnChanged Code to get executed when the container changes.
@@ -125,7 +138,6 @@
 #define IMP_LIST_IMPL(Class, Ucname, lcname, Data, init, OnChanged)     \
 IMP_CONTAINER_CORE_IMPL(Class, Ucname, lcname, Data, unsigned int,    \
 init, OnChanged)                              \
-/** \short Remove any occurences of d from the container */           \
 void Class::erase_##lcname(Data d) {                                  \
 for (Ucname##Iterator it= lcname##s_begin();                        \
 it != lcname##s_end(); ++it) {                                 \
@@ -152,18 +164,21 @@
  \note these containers are always public
  */
 #define IMP_CONTAINER(Ucname, lcname, IndexType)            \
-public:                                                   \
-void remove_##lcname(IndexType i) ;                       \
 private:                                                                \
-/** \internal
-This is an implementation detail.*/                                 \
+/* This is an implementation detail.*/                                 \
 typedef IMP::internal::ObjectContainer<Ucname, IndexType>               \
 Ucname##Container;                                                      \
+public:                                                   \
+/** @name Methods acting on a contained set of Objects*/               \
+/*@{*/                                                                \
+void remove_##lcname(IndexType i) ;                       \
 IMP_CONTAINER_CORE(public, Ucname, lcname, Ucname*, IndexType,          \
-Ucname##Container)
+Ucname##Container)                                                      \
+/*@}*/                                                               \
 
 
 
+
 //! Use this to add a container of IMP objects
 /**
  This code should go in a .cpp file. One macro for each
Index: kernel/include/internal/log_internal.h
===================================================================
--- kernel/include/internal/log_internal.h	(revision 0)
+++ kernel/include/internal/log_internal.h	(revision 0)
@@ -0,0 +1,77 @@
+/**
+ *  \file log_internal.h     \brief Logging and error reporting support.
+ *
+ *  Copyright 2007-8 Sali Lab. All rights reserved.
+ *
+ */
+
+#ifndef IMP_INTERNAL_LOG_INTERNAL_H
+#define IMP_INTERNAL_LOG_INTERNAL_H
+
+#include "../config.h"
+
+#include <boost/noncopyable.hpp>
+
+#include <iostream>
+#include <fstream>
+#include <cstdlib>
+#include <cassert>
+#include <string>
+
+IMP_BEGIN_INTERNAL_NAMESPACE
+
+class IMPEXPORT Log: boost::noncopyable
+{
+public:
+  static Log& get();
+
+  unsigned int get_level() {
+    return level_;
+  }
+  void set_level(unsigned int l) {
+    level_=l;
+  }
+
+  std::ostream &get_stream(unsigned int l) {
+    if (is_output(l)) {
+      if (target_== 0) {
+        return std::cout;
+      } else if (target_== 1) {
+        return std::cerr;
+      } else {
+        return fstream_;
+      }
+    } else return std::cout;
+  }
+
+  bool is_output(unsigned int l) {
+    return l <= get_level();
+  }
+
+  unsigned int get_target() {
+    return target_;
+  }
+  void set_target(unsigned int k) {
+    target_=k;
+  }
+  void set_filename(std::string k) {
+    fstream_.open(k.c_str());
+    if (!fstream_) {
+      std::cerr << "Error opening log file " << k << std::endl;
+    }
+  }
+
+private:
+
+  Log(unsigned int level, unsigned int target)  :level_(level),
+                                                 target_(target) {}
+  unsigned int level_;
+  unsigned int target_;
+  std::ofstream fstream_;
+  static Log *logpt_;
+};
+
+
+IMP_END_INTERNAL_NAMESPACE
+
+#endif  /* IMP_INTERNAL_LOG_INTERNAL_H */
Index: kernel/include/internal/SConscript
===================================================================
--- kernel/include/internal/SConscript	(revision 1087)
+++ kernel/include/internal/SConscript	(working copy)
@@ -1,7 +1,8 @@
 files = ['AttributeTable.h', 'Vector.h',
          'ref_counting.h', 'ObjectContainer.h',
          'kernel_version_info.h', 'constants.h', 'units.h',
-         'utility.h', 'Unit.h', 'ExponentialNumber.h', 'key_helpers.h']
+         'utility.h', 'Unit.h', 'ExponentialNumber.h', 'key_helpers.h',
+         'log_internal.h']
 
 files = [File(f) for f in files]
 Return('files')
Index: kernel/include/exception.h
===================================================================
--- kernel/include/exception.h	(revision 1087)
+++ kernel/include/exception.h	(working copy)
@@ -76,6 +76,7 @@
  */
 struct IMPEXPORT ErrorException: public Exception
 {
+  //! Create exception with an error message
   ErrorException(const char *msg="Fatal error"): Exception(msg){}
   ~ErrorException() throw();
 };
@@ -86,6 +87,7 @@
 class IMPEXPORT InvalidStateException : public Exception
 {
 public:
+  //! Create exception with an error message
   InvalidStateException(const char *t): Exception(t){}
   ~InvalidStateException() throw();
 };
@@ -96,6 +98,7 @@
 class IMPEXPORT InactiveParticleException : public Exception
 {
 public:
+  //! Create exception with an error message
   InactiveParticleException(const char *msg
                             ="Attempting to use inactive particle"):
     Exception(msg){}
@@ -108,6 +111,7 @@
 class IMPEXPORT IndexException: public Exception
 {
 public:
+  //! Create exception with an error message
   IndexException(const char *t): Exception(t){}
   ~IndexException() throw();
 };
@@ -118,6 +122,7 @@
 class IMPEXPORT ValueException: public Exception
 {
 public:
+  //! Create exception with an error message
   ValueException(const char *t): Exception(t){}
   ~ValueException() throw();
 };
Index: kernel/include/DerivativeAccumulator.h
===================================================================
--- kernel/include/DerivativeAccumulator.h	(revision 1087)
+++ kernel/include/DerivativeAccumulator.h	(working copy)
@@ -11,11 +11,14 @@
 
 #include "config.h"
 #include "base_types.h"
+#include "utility.h"
 #include <cmath>
 
 IMP_BEGIN_NAMESPACE
 
 //! Class for adding derivatives from restraints to the model.
+/** This class was created so that restraints can be weighted using
+    a RestraintSet and that the derivatives would be scaled appropriately */
 class IMPEXPORT DerivativeAccumulator
 {
 public:
@@ -32,7 +35,7 @@
    */
   Float operator()(const Float value) const {
     // x!=x when x==NaN (can only use std::isnan on gcc C99 systems)
-    IMP_assert(value == value, "Can't set derivative to NaN.");
+    IMP_assert(!is_nan(value), "Can't set derivative to NaN.");
     return value * weight_;
   }
 
Index: kernel/include/Particle.h
===================================================================
--- kernel/include/Particle.h	(revision 1087)
+++ kernel/include/Particle.h	(working copy)
@@ -96,8 +96,9 @@
 
 public:
 
+  //! Construct a particle and add it to the Model
+  Particle(Model *m);
 
-
   Particle();
   ~Particle();
 
Index: kernel/include/utility.h
===================================================================
--- kernel/include/utility.h	(revision 1087)
+++ kernel/include/utility.h	(working copy)
@@ -10,6 +10,11 @@
 
 #include "macros.h"
 
+#ifdef __GNUC__
+#include <cmath>
+#endif
+
+
 IMP_BEGIN_NAMESPACE
 
 //! Compute the square of a number
@@ -19,6 +24,32 @@
   return t*t;
 }
 
+
+//! Return true if a number is NaN
+/** With certain compiler settings the compiler can optimize
+ out a!=a (and certain intel chips had issues with it too).
+ */
+inline bool is_nan(const float& a) {
+  // Not all gcc versions include C99 math
+#if defined(_GLIBCXX_USE_C99_MATH) && defined(__GNUC__)
+  return std::isnan(a);
+#else
+  return a != a;
+#endif
+}
+
+//! Return true if a number is NaN
+/** With certain compiler settings the compiler can optimize
+ out a!=a (and certain intel chips had issues with it too).
+ */
+inline bool is_nan(const double& a) {
+#if defined(_GLIBCXX_USE_C99_MATH) && defined(__GNUC__)
+  return std::isnan(a);
+#else
+  return a != a;
+#endif
+}
+
 IMP_END_NAMESPACE
 
 #endif  /* IMP_UTILITY_H */
Index: kernel/include/Object.h
===================================================================
--- kernel/include/Object.h	(revision 1087)
+++ kernel/include/Object.h	(working copy)
@@ -17,10 +17,6 @@
 /** Currently this just makes the object noncopyable and adds heuristic checks
     to make sure the memory has not been freed.
 
-    \note Do not use NDEBUG to remove check_value_ as that changes the memory
-    layout and causes bad things to happen. It should get wrapped in some
-    sort of macro later.
-
     \note This has ref and unref methods to simplifity ObjectContainer.
     For Object, the reference count can be at most 1.
 
@@ -58,6 +54,9 @@
   const Object& operator=(const Object &o) {return *this;}
 
   int count_;
+  /* Do not use NDEBUG to remove check_value_ as that changes the memory
+   layout and causes bad things to happen. It should get wrapped in some
+   sort of macro later. */
   double check_value_;
 };
 
Index: kernel/include/VectorD.h
===================================================================
--- kernel/include/VectorD.h	(revision 1087)
+++ kernel/include/VectorD.h	(working copy)
@@ -363,7 +363,17 @@
   SpacesIO(const VectorD<D> &v): v_(v){}
 };
 
+//! Use this before outputing to delimited vector entries with a space
+/** std::cout << spaces_io(v);
+    produces "(1.0 2.0 3.0)"
+
+ */
 template <unsigned int D>
+SpacesIO<D> spaces_io(const VectorD<D> &v) {
+  return SpacesIO<D>(v);
+}
+
+template <unsigned int D>
 inline std::ostream &operator<<(std::ostream &out, const SpacesIO<D> &s)
 {
   s.v_.show(out, " ");
@@ -377,7 +387,17 @@
   CommasIO(const VectorD<D> &v): v_(v){}
 };
 
+//! Use this before outputing to delimited vector entries with a comma
+/** std::cout << commas_io(v);
+ produces "(1.0, 2.0, 3.0)"
+
+ */
 template <unsigned int D>
+CommasIO<D> commas_io(const VectorD<D> &v) {
+  return CommasIO<D>(v);
+}
+
+template <unsigned int D>
 inline std::ostream &operator<<(std::ostream &out, const CommasIO<D> &s)
 {
   s.v_.show(out, ", ");
Index: kernel/include/log.h
===================================================================
--- kernel/include/log.h	(revision 1087)
+++ kernel/include/log.h	(working copy)
@@ -9,6 +9,7 @@
 #define IMP_LOG_H
 
 #include "config.h"
+#include "internal/log_internal.h"
 
 #include <iostream>
 #include <fstream>
@@ -37,71 +38,12 @@
  */
 enum LogTarget {COUT, FILE, CERR};
 
-class IMPEXPORT Log
-{
-public:
-  //! Get a reference to a singleton Log object.
-  static Log& get() {
-    if (!logpt_) {
-      logpt_ = new Log();
-    }
-    return *logpt_;
-  }
-
-  LogLevel get_level() {
-    return level_;
-  }
-  void set_level(LogLevel l) {
-    level_=l;
-  }
-
-  std::ostream &get_stream(LogLevel l) {
-    if (is_output(l)) {
-      if (target_== COUT) {
-        return std::cout;
-      } else if (target_== CERR) {
-        return std::cerr;
-      } else {
-        return fstream_;
-      }
-    } else return std::cout;
-  }
-
-  bool is_output(LogLevel l) {
-    return l <= get_level();
-  }
-
-  LogTarget get_target() {
-    return target_;
-  }
-  void set_target(LogTarget k) {
-    target_=k;
-  }
-  void set_filename(std::string k) {
-    fstream_.open(k.c_str());
-    if (!fstream_) {
-      std::cerr << "Error opening log file " << k << std::endl;
-    }
-  }
-
-private:
-
-  Log()  :level_(SILENT), target_(COUT) {}
-  Log(const Log&) {}
-
-  LogLevel level_;
-  LogTarget target_;
-  std::ofstream fstream_;
-  static Log *logpt_;
-};
-
-
 //! Set the current log level for IMP
 /** \ingroup log
  */
 IMPEXPORT inline void set_log_level(LogLevel l)
 {
-  Log::get().set_level(l);
+  internal::Log::get().set_level(l);
 }
 
 //! Set the target of logs
@@ -109,7 +51,7 @@
  */
 IMPEXPORT inline void set_log_target(LogTarget l)
 {
-  Log::get().set_target(l);
+  internal::Log::get().set_target(l);
 }
 
 //! Get the current log level for IMP
@@ -117,7 +59,7 @@
  */
 IMPEXPORT inline LogLevel get_log_level()
 {
-  return Log::get().get_level();
+  return LogLevel(internal::Log::get().get_level());
 }
 
 //! Get the target of logs
@@ -125,7 +67,7 @@
  */
 IMPEXPORT inline LogTarget get_log_target()
 {
-  return Log::get().get_target();
+  return LogTarget(internal::Log::get().get_target());
 }
 
 //! Set the file name for the IMP log; must be called if a file is to be used.
@@ -133,7 +75,7 @@
  */
 IMPEXPORT inline void set_log_file(std::string l)
 {
-  Log::get().set_filename(l);
+  internal::Log::get().set_filename(l);
 }
 
 //! Determine whether a given log level should be output.
@@ -142,7 +84,7 @@
  */
 IMPEXPORT inline bool is_log_output(LogLevel l)
 {
-  return Log::get().is_output(l);
+  return internal::Log::get().is_output(l);
 }
 
 
@@ -152,7 +94,7 @@
  */
 IMPEXPORT inline std::ostream& get_log_stream(LogLevel l)
 {
-  return Log::get().get_stream(l);
+  return internal::Log::get().get_stream(l);
 }
 
 
Index: kernel/include/Optimizer.h
===================================================================
--- kernel/include/Optimizer.h	(revision 1087)
+++ kernel/include/Optimizer.h	(working copy)
@@ -196,6 +196,7 @@
     return (*fi.p_)->get_derivative(*fi.fk_);
   }
 
+  //! A collection of indexes
   typedef std::vector<FloatIndex> FloatIndexes;
 
 private:
Index: kernel/src/Particle.cpp
===================================================================
--- kernel/src/Particle.cpp	(revision 1087)
+++ kernel/src/Particle.cpp	(working copy)
@@ -11,6 +11,13 @@
 
 IMP_BEGIN_NAMESPACE
 
+Particle::Particle(Model *m)
+{
+  is_active_ = true;
+  m->add_particle(this);
+}
+
+
 Particle::Particle()
 {
   is_active_ = true;
Index: kernel/src/Log.cpp
===================================================================
--- kernel/src/Log.cpp	(revision 1087)
+++ kernel/src/Log.cpp	(working copy)
@@ -6,11 +6,20 @@
  */
 
 #include "IMP/log.h"
+#include "IMP/internal/log_internal.h"
 #include "IMP/exception.h"
 
-IMP_BEGIN_NAMESPACE
+IMP_BEGIN_INTERNAL_NAMESPACE
 
 /* Initialize singleton pointer to NULL */
 Log* Log::logpt_ = NULL;
 
-IMP_END_NAMESPACE
+Log &Log::get() {
+  if (!logpt_) {
+    logpt_ = new Log(TERSE, COUT);
+  }
+  return *logpt_;
+}
+
+
+IMP_END_INTERNAL_NAMESPACE
Index: kernel/pyext/IMP/test.py
===================================================================
--- kernel/pyext/IMP/test.py	(revision 1087)
+++ kernel/pyext/IMP/test.py	(working copy)
@@ -34,8 +34,7 @@
     def create_point_particle(self, model, x, y, z):
         """Make a particle with optimizable x, y and z attributes, and
            add it to the model."""
-        p = IMP.Particle()
-        model.add_particle(p)
+        p = IMP.Particle(model)
         p.add_attribute(IMP.FloatKey("x"), x, True)
         p.add_attribute(IMP.FloatKey("y"), y, True)
         p.add_attribute(IMP.FloatKey("z"), z, True)
