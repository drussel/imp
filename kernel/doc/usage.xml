<chapter id="usage">
<title>Usage</title>

<sect1 id="compilation">
<title>Compilation from source code</title>

<sect2 id="prereq">
<title>Prerequisites</title>

<para>In order to obtain and compile &IMP;, you will need:</para>

<itemizedlist>
<listitem><para>A recent version of
<ulink url="http://www.swig.org">SWIG</ulink> (1.3.33 or later recommended).
</para></listitem>

<listitem><para>A recent version of
<ulink url="http://www.scons.org">scons</ulink> (0.97 or later recommended).
</para></listitem>

<listitem><para>A <ulink url="http://subversion.tigris.org/">Subversion</ulink>
(svn) client.</para></listitem>

<listitem><para>The <ulink url="http://www.boost.org">Boost</ulink> C++ libraries, version 1.30 or later.</para></listitem>

<listitem><para><ulink url="http://www.python.org">Python</ulink> 2.3 or
later.</para></listitem>

<listitem><para>If you want to use &IMP; with &MODELLER; (optional), you should
use version 9v2 or later.</para></listitem>

</itemizedlist>
</sect2>

<para>
You can get the current &IMP; code by running the following:
</para>
<screen>
<command>svn co https://svn.salilab.org/imp/trunk imp</command>
</screen>

<para>
If you already have a copy of &IMP;, you can update it to the current code
by running (in the <filename>imp</filename> directory):
</para>
<screen>
<command>svn update</command>
</screen>

<para>
To compile, run <command>scons</command> in the
<filename>imp</filename> directory (it is also recommended that you run
<command>scons test</command> to run all of the unit tests). To install, run
<command>scons install</command>.
</para>

<para>
If you want to use &IMP; with &MODELLER;, set the <command>scons</command>
<varname>modeller</varname> variable to the directory where you have
&MODELLER; installed, e.g. <command>scons modeller=~/modinstall</command>.
Type <command>scons -h</command> to get help on this and other command-line
options.
</para>

</sect1>

<sect1 id="reference">
<title>Reference manual</title>
<para>
For information on the low-level &IMP; code, see the
<ulink url="doxygen/index.html">C++ API reference</ulink>.
</para>
</sect1>

<sect1 id="style">
<title>Style guide</title>

<para>
To ensure code consistency and readability, certain conventions should be
adhered to when writing code for &IMP;. Some of these conventions are
automatically checked for by source control before allowing a new commit, and
should also be checked yourself in new code by running
<command>scons standards</command>.
</para>

<sect2>
<title>C++ formatting</title>

<sect3>
<title>Indentation</title>
<para>All C++ headers and code should be indented in 'Linux' style, with
2-space indents. Do not use tabs. This is roughly the output of
<ulink url="http://astyle.sourceforge.net/">Artistic Style</ulink> with
the <parameter>--convert-tabs --style=linux --indent=spaces=2 --unpad=paren --pad=oper</parameter>
parameters. Split lines if necessary to ensure that no line is longer than
80 characters.
</para>

<para><emphasis>Rationale:</emphasis>
Different users have different-sized windows or terminals, and different tab
settings. This is also similar to other lab C and Fortran projects.
</para>
</sect3>

<sect3>
<title>Comments</title>

<para>Format to allow 
<ulink url="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink>
automated documentation creation. If possible, specify both a 'brief'
description and a more detailed one (in which parameters, return values,
and exceptions are documented). Use //! for the one-line brief description
and /** ... */ for the multi-line detailed description (put the closing */ on
a new line, so that these comments are always multi-line (Doxygen will not
accept both a 'brief' comment and a one-line detailed comment). All header
and source files should have a starting comment header, using the
<command>\file</command> command to document the purpose of the file.
For example:</para>
<informalexample><programlisting>
//! Calculates the square root.
/** \param[in] the_value Calculate the square root of this value.
    \exception std::domain_error value is out of range (negative).
    \return the square root of the given value.
 */
</programlisting></informalexample>
</sect3>

<sect3>
<title>Class names</title>

<para>Use CamelCase (i.e. capitalized concatenated words). For example:</para>
<informalexample><programlisting>
class SpecialVector
{
};
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
This makes it easier to tell between class names and function names where
this is ambiguous (particularly an issue with the Python interface). The
Python guys also mandate CamelCase for their class names, so this avoids
any need to rename classes between C++ and Python to ensure clean Python code.
</para>
</sect3>

<sect3>
<title>Exceptions</title>
<para>Exceptions are classes, so name as for classes, above. Do not use
exception specfications, but do document the possible exceptions thrown by
a function with the Doxygen <command>\exception</command> command.
</para>

<para><emphasis>Rationale:</emphasis>
Exception specifications do not guarantee that only the listed exceptions will
be thrown, and actually hurt compiler optimizations in many cases. Many
libraries (such as Boost) <ulink url="http://www.gotw.ca/publications/mill22.htm">advise against using them</ulink>.
</para>

</sect3>

<sect3>
<title>Member functions (class methods)</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
void SpecialVector::add_constant(int the_constant)
</programlisting></informalexample>

<para>Use set_ at the beginning of setting accessor functions, and get_ at the
beginning of accessor functions used to get a member variable value.
For example:</para>

<informalexample><programlisting>
float Sphere::get_radius(void) const;
void Sphere::set_radius(float);
</programlisting></informalexample>
</sect3>

<sect3>
<title>Member variables (class variables)</title>

<para>Use lower case, with words separated by underscores. End name in an
underscore. For example:</para>
<informalexample><programlisting>
std::vector&lt;int&gt; spec_vector_; 
</programlisting></informalexample>
</sect3>

<sect3>
<title>Local variables</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
int i, num_particles;
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
A trailing underscore makes it simple to tell between class members and
local variables.</para>
</sect3>

</sect2>

<sect2>
<title>C++ libraries and namespaces</title>
<para>Explicitly use namespace prefixes rather than the "using namespace"
syntax.</para>

<para><emphasis>Rationale:</emphasis>
Avoids namespace pollution, and removes any ambiguity.
</para>

</sect2>

<sect2>
<title>Python formatting</title>
<para>All Python code should conform to the
<ulink url="http://www.python.org/dev/peps/pep-0008/">Python style
guide</ulink>. In essence this translates to 4-space indents, no tabs, and
similar class, method and variable naming to the C++ code. You can ensure that
your Python code is correctly indented by using the
<ulink url="http://docutils.sourceforge.net/sandbox/py-rest-doc/utils/reindent.py">reindent.py</ulink>
script, available as part of the Python distribution.
</para>

</sect2>

</sect1>

<sect1 id="codereview">
<title>Code review</title>

<para>To ensure code quality, additions to the IMP kernel should be reviewed
by the other developers. In general, this means posting a patch with some
explanation of the changes (e.g. suitable for the source control logs) to the
<email>imp-dev@salilab.org</email> mailing list. This is mandatory for
changes that:</para>
<itemizedlist>
<listitem><para>Change the API (e.g. remove or rename existing methods or
classes, change the arguments taken by existing methods, change the behavior
of existing methods, change the return values or thrown exceptions of existing
methods).</para></listitem>

<listitem><para>Remove or modify existing test cases.</para></listitem>
</itemizedlist>

<para>For more minor changes, such as adding new tests, methods and/or classes
(which may change the ABI but not the API), documentation updates, etc.
review is not <emphasis>required</emphasis> but is recommended.</para>

<para>Patches should contain a related set of changes. For example, a patch
which adds a new method <methodname>foo</methodname>, a new testcase for
<methodname>foo</methodname>, and some documentation for the
<classname>SpecialVector</classname> class, should be split into two patches:
one for the <methodname>foo</methodname> method and test, and the other for
the <classname>SpecialVector</classname> documentation.</para>

<para>New code in patches should also adhere to the
<link linkend="style">coding style guidelines</link>.</para>

<para>If new methods and/or classes are added, it is
<emphasis>strongly</emphasis> recommended that unit tests are added for these.
(Even a simple call of each method with no checking of the return values or
other effects is better than nothing.)</para>

<para><emphasis>Rationale:</emphasis>
Other developers may have external applications and their own in-progress work
which may be adversely affected by your changes. There may also be disagreement
about a change, so discussing it on the mailing list first assures that a
consensus is first reached, rather than other developers later reverting the
change. It is much easier to review a patch if it is small and contains only
relevant changes, and in addition it can generally be applied to source control
virtually unchanged if the code is OK. Test cases also help to document the
intent of code changes, as well as making sure that the new additions are not
accidentally broken in future.
</para>

</sect1>

</chapter>
