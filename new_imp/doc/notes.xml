<chapter id="newinterface">
<title>New &IMP; interface</title>

<para>This describes the transition to a new interface for &IMP;. Some
functionality has been lost or at least not yet re-implemented, but the
overhead for adding restraints and optimizers has been reduced. To add a
restraint you just define the constructor, destructor (often empty), and the
evaluate method.  To add an optimizer you just define the constructor (often
empty), destructor (often empty), and the optimize method. Another advantage
of the new interface is that it is intended to be more tightly integrated
with Python (a la Javier's request). The model, its particles and restraints,
can be constructed in Python component by component rather than relying on
reading in files via IMP.</para>

<sect1 id="addrsr">
<title>Adding a Restraint</title>

<para>Create file <filename>my_restraint.h</filename> (use another file as a
model; e.g. <filename>Complexes_Restraints.h</filename>).</para>

<note><para>Make sure you change the #define value to match the new file name
or it won't get compiled.</para></note>

<para>Create file <filename>my_restraint.cpp</filename> (use another file as a
model; e.g. <filename>Complexes_Restraints.cpp</filename>).</para>

<para>Define the constructor, destructor, and evaluate method.</para>

<para>Add header file name to <filename>imp.i</filename> (for SWIG) and the C++
file name to <filename>SConstruct</filename>.</para>

<para>Recompile the shared library and the restraint should now be available
through Python. If you want, you can also define a syntax and code for loading
the restraint from a text file by modifying the
<filename>Model_Loader.cpp</filename> code.</para>

<note><para>SWIG seems to have a problem with subclasses in separate .h files.
For now, put the declaration in the <filename>Restraint.h</filename>
file.</para></note>

</sect1>


<sect1 id="optimizer">
<title>Optimizer</title>

<para>An optimizer has an <methodname>optimize</methodname> method that can
be applied to the model that is passed as an argument. The optimization
continues until the max_steps are taken or the score threshold is reached.
</para>

<sect2 id="optinterface">
<title>Interface</title>

<informalexample><programlisting>
public:
  Optimizer();
  virtual ~Optimizer();
	
  virtual Float optimize(Model&amp; model, int max_steps, Float threshold=0.0) = 0;
</programlisting></informalexample>

</sect2>

<sect2 id="optissues">
<title>Issues</title>

<para>Still need to work out the right way to handle
<emphasis>constraints</emphasis> (e.g. rigid bodies).</para>

</sect2>

<sect2 id="opthistory">
<title>Historical notes</title>
	
<para><classname>Optimizer</classname> was contained within
<classname>Model</classname> until we deviated away from the pattern of using
the <classname>Model</classname> as containing the API from which most methods
are called.</para>
	
<para>Score and score derivatives had their own type. However, it was suggested
that since the compiler does not enforce the typedef types, this might cause
confusion later on if the policy wasn't always adhered to and then the type
was aliased to a new underlying type.</para>

</sect2>

</sect1>

<sect1 id="model">
<title>Model</title>

<para>A model contains the particles and restraints that act on those
particles. It can be optimized with respect to the restraints and particles
that it contains.</para>

<sect2 id="modelinterface">
<title>Interface</title>

<informalexample><programlisting>
public:
  Model();
  ~Model();
  Model_Data* get_model_data(void);
	
  // particles
  void add_particle(Particle* particle);
  Particle* particle(size_t idx);

  // restraints
  void add_restraint_set(Restraint_Set* restraint_set);
  Restraint_Set* restraint_set(const std::string name);

  // for each restraint_set, call evaluate
  Float evaluate(bool calc_derivs);

  void show (std::ostream&amp; out = std::cout);
</programlisting></informalexample>
</sect2>

</sect1>

<sect1 id="particle">
<title>Particle</title>

<para>A particle is an entity within the model that has attributes with
associated values.</para>

<sect2 id="particleinterface">
<title>Interface</title>
<informalexample><programlisting>
public:
  Particle();
  ~Particle();
  void set_model_data(Model_Data* model_data);

  // float attributes
  bool add_float(const std::string name, const Float value = 0.0, const bool optimize = false);
  Float_Index float_index(const std::string name);

  // int attributes
  bool add_int(const std::string name, const Int value);
  Int_Index int_index(const std::string name);

  // string attributes
  bool add_string(const std::string name, const String value);
  String_Index string_index(const std::string name);
	
  // status
  void set_is_active(bool is_active);
  bool is_active(void);
	
  void show(std::ostream&amp; out = std::cout);
</programlisting></informalexample>

</sect2>

<sect2 id="particleissues">
<title>Issues</title>

<para>A key issue is how to remove particles. Removing particles has at least
two complications. The indexed attributes (see
<classname>Model_Data</classname>) cannot actually be removed without
disrupting the indexes used by other particles. Reuse also runs the risk of
the new particle being used although the index was intended for the old one.
Another complication is that it is not clear what the best way to handle
restraints that reference a particle that has been deleted. Concerns have
been raised about methods that require the restraint writer to do the
bookkeeping.</para>

<para>A proposed solution to the first complication is to deactivate rather
than physically remove particles. Deactivated particles will continue to
take up space in memory, but all indexes will continue to refer correctly
to the associated particle attributes.</para>

<para>A proposed solution to the second complication is to provide some
functionality in the <classname>Restraint</classname> base class that will
deactivate the restraint if any particles in the maintained list of particles
is deactivated. The restraint writer can override this behavior if it is
not appropriate for their particular restraint type.</para>
</sect2>

<sect2 id="particlehistory">
<title>Historical notes</title>

<para>Variables were initially handled separated from Float attributes.
However, to simplify the interface, all Float attributes have can be
optimizable variables if the appropriate flag is set. The disadvantage of
this approach is that some storage space is allocated for all Float
attributes that will not be used for those that are not optimized.</para>

</sect2>
</sect1>

<sect1 id="rsrset">
<title>Restraint_Set</title>

<para>A restraint set is a container holding restraints and other restraint
sets. It can also hold filters that can be used to deactivate some of the
restraints.</para>

<sect2 id="rsrsetinterface">
<title>Interface</title>

<informalexample><programlisting>
public:
  Restraint_Set(std::string name = std::string("no_name"));
  ~Restraint_Set();
  void set_model_data(Model_Data* model_data);
	
  std::string name(void) {return name_;}
  void set_name(std::string name) {name_ = name;}

  // return the score for this restraint or set of restraints
  // ... given the current state of the model
  Float evaluate(bool calc_deriv);
	
  void add_restraint(Restraint *restraint);
  void add_restraint_set(Restraint_Set *restraint_set);
  // void add_filter(Filter *filter);
	
  // status
  void set_is_active(const bool is_active);
  bool is_active(void);

  // called when at least one particle has been inactivated
  void check_particles_active(void);

  void show(std::ostream&amp; out = std::cout);
</programlisting></informalexample>
</sect2>

<sect2 id="rsrsetissues">
<title>Issues</title>

<para>None of the methods are virtual here. The hope is that all restraint
set functionality can be provided by the base class and will not be
subclassed.</para>
</sect2>

<sect2 id="rsrsethistory">
<title>Historical notes</title>

<para>Restraint sets were initially a subclass of Restraints but it ended up
being easier to keep them separate, so analagous functions are now overloaded
rather than accessed via polymorphism. This was done in part to implement
filters in a different way. Filters will be added to restraint sets and
applied in the order that they are added. Previously, Filters were restraint
sets that were applied to the restraints and restraint sets that they
contained (including other filters). The approaches are basically equivalent.
</para>

<para>The model only contains restraint sets rather than individual restraints.
The restraint sets are named, but the Model interface no longer provides a
method for turning off restraints by hand. This functionality must be coded
by sequencing through the restraint sets.</para>
</sect2>

</sect1>

<sect1 id="restraint">
<title>Restraint</title>

<para>A restraint uses the current state of some subset of particles of the
model to determine a feature of the model and a score with respect to that
feature. It can also calculate first derivatives for the score with respect
to the feature and subsequently to the different particle attributes to
provide a gradient in a direction that will reduce the current score.</para>

<sect2 id="restraintinterface">
<title>Interface</title>
<informalexample><programlisting>
public:
  Restraint();
  virtual ~Restraint();
  void set_model_data(Model_Data* model_data);

  // return the score for this restraint or set of restraints
  // ... given the current state of the model
  virtual Float evaluate(bool calc_deriv) = 0;

  // status
  void set_is_active(const bool active);
  bool is_active(void);

  // called when at least one particle has been inactivated
  virtual void check_particles_active(void);

  virtual void show(std::ostream&amp; out = std::cout);
</programlisting></informalexample>
</sect2>


<sect2 id="restraintissues">
<title>Issues</title>

<para><methodname>check_particles_active()</methodname> is meant to be
invisible to most users and almost no one should override this method unless
they are defining a restraint where they are going to allow some particles
within the restraint to be inactivated while still calculating some score
based on the remaining particles.</para>
</sect2>

<sect2 id="restrainthistory">
<title>Historical notes</title>

<para>Restraints were definable for a set of sets of particles so that a
large number of similar restraints could be easily defined and efficiently
specified and stored. This capability has been removed and current restraints
tend to refer to one feature for one set of particles.</para>

<para>However, it is still possible for a restraint to in fact represent a
set of related restraints. It also might make sense for similar restraints
that can use the same proximal pair list (non-bonded pair list) to be
combined into a single restraint and for a pointer to that list to be held
within the restraint. The restraints that use the list could then check
before they re-evaluate whether the list needs to be updated. It might thus
be possible to prevent any knowledge of the proximal pair list in the
optimizers which seems desirable.</para>
</sect2>
</sect1>

<sect1 id="modeldata">
<title>Model_Data</title>

<para>The model data refers to all of the attributes of the model and their
associated values. Currently, all attributes are associated with particles
but this need not be the case. For example, a restraint could add optimizable
variables to the model data.</para>

<para>The currently supported data types are Float, Int, and String. All
Float values are considered potentially optimizable and have space allocated
for storing derivatives. Also, groups of optimized variables with the same
name reference in Particle instances have their statistics associated with
changes in state saved in Model. For example, "X" variable for all particles
would have a set of statistics that can be reached in Model with the name "X".
</para>

<sect2 id="modeldatainterface">
<title>Interface</title>

<informalexample><programlisting>
public:
  // variables
  class Float_Data {
  public:
    Float value_;
    Float deriv_;
    int stats_index_;
    bool is_optimized_;
  };

  // variable statistics
  // intended for keeping track of change sizes during optimization
  // ... for efficiency issues (e.g. updates of neighborhoods)
  class Statistics {
  public:
    Float min_;
    Float max_;
    Float max_delta_;
    Float min_delta_;
  };

  // particle float attributes (assumed differentiable variables)
  Float_Index add_float(const Float value, const std::string name="none");
  void set_float(const Float_Index idx, const Float value);
  Float get_float(const Float_Index idx);

  void add_to_deriv(const Float_Index idx, const Float value);
  Float get_deriv(const Float_Index idx);
  bool is_optimized(const Float_Index idx);
  void set_is_optimized(const Float_Index idx, bool is_optimized);

  void zero_derivatives(void);

  // particle int attributes
  Int_Index add_int(const Int value);
  void set_int(const Int_Index idx, const Int value);
  Int get_int(const Int_Index idx);

  // particle string attributes
  String_Index add_string(const String value);
  void set_string(const String_Index idx, const String value);
  String get_string(const String_Index idx);
</programlisting></informalexample>
</sect2>

<sect2 id="modeldataissues">
<title>Issues</title>

<para>There is some question what is the best way to sequence through a list.
Here we are using reset(), next(), and get(), which is common and is easy to
access and use through Python. Here Opt_Float_Index_Iterator is used to get
all of the Float attributes that are being optimized.</para>

<para>The inconsistency of naming of the accessors here is due to fact that
the normal method (the word alone without the get_ prefix) is disallowed
because they are keywords.</para>
</sect2>

<sect2 id="modeldatahistory">
<title>Historical notes</title>

<para>This new storage scheme is intended to allow efficiencies near those
of one dimensional arrays for each variable type but allow particles to have
very different attributes without lots of unused memory locations.</para>

</sect2>
</sect1>

<sect1 id="modelloader">
<title>Model_Loader</title>

<para>The model loader loads the model from a file.</para>

<sect2 id="modelloaderinterface">
<title>Interface</title>

<informalexample><programlisting>
public:
  Model_Loader();
  ~Model_Loader();

  // Model
  bool load_model(Model&amp; model, const std::string&amp; fname);
  void load_particle(Particle&amp; particle, std::istream&amp; in);
  void load_restraint_set(Model&amp; model, Restraint_Set&amp; restraint_set, std::istream&amp; in);
  void load_distance_restraints(Model&amp; model, Restraint_Set&amp; restraint_set, std::istream&amp; in);
  score_func* get_score_func(const std::string score_func_name);
</programlisting></informalexample>
</sect2>

<sect2 id="modelloaderissues">
<title>Issues</title>
<para>The loader will probably end up not being used, since it easier to
write your own in Python or use the Python XML loader.</para>
</sect2>

<sect2 id="modelloaderhistory">
<title>Historical notes</title>

<para>Each component of the model was previously responsible for loading
itself from a text file. This has some advantages in that it extending
the system can be contained within a single Restraint class definition.
However, the current mode assumes that instantiation of components is more
likely to come through the Python interface than through reading of a single
text file. In that case, the Model Loader will be used mostly internally
for testing.</para>
</sect2>

</sect1>

</chapter>
