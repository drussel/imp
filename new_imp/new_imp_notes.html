<p> This doc describes the transition to a new interface for IMP. Some functionality has been lost or at least not yet re-implemented, but the overhead for adding restraints and optimizers has been reduced. To add a restraint you just define the constructor, destructor (often empty), and the evaluate method.  To add an optimizer you just define the constructor (often empty), destructor (often empty), and the optimize method. Another advantage of the new interface is that it is intended to be more tightly integrated with Python (a la Javier's request). The model, its particles and restraints, can be constructed in Python component by component rather than relying on reading in files via IMP.

<hr>
<h2>Adding a Restraint</h2>
<p>Create file <i>my_restraint.h</i> (use another file as a model; e.g. Complexes_Restraints.h). <b>Make sure you change the #define value to match the new file name or it won't get compiled.</b>

<p>Create file <i>my_restraint.cpp</i> (use another file as a model; e.g. Complexes_Restraints.cpp).

<p>Define the constructor, destructor, and evaluate method.

<p>Add file reference to imp.i (for swig) and compiler and link files.

<p>Recompile the shared library and the restraint should now be available through Python. If you want, you can also define a syntax and code for loading the restraint from a text file by modifying the Model_Loader.cpp code.

<p><b>Swig seems to have a problem with subclasses in separate .h files. For now, put the declaration in the Restraint.h file.</b>

<hr>
<h2>Optimizer</h2>

<p>An optimizer has an <i>optimize</i> method that can be applied to the model that is passed as an argument. The optimization continues until the max_steps are taken or the score threshold is reached.

<h3>Interface:</h3>
<pre>
public:
	Optimizer();
	virtual ~Optimizer();
	
	virtual Float optimize(Model& model, int max_steps, Float threshold=0.0) = 0;
</pre>

<h3>Issues:</h3>

<p>Still need to work out the right way to handle <i>constraints</i> (e.g. rigid bodies).

<h3>Historical notes:</h3>
	
<p>Optimizer was contained within Model until we deviated away from the pattern of using the Model as containing the API from which most methods are called.
	
<p>Score and score derivatives had their own type. However, it was suggested that since the compiler does not enforce the typedef types, this might cause confusion later on if the policy wasn't always adhered to and then the type was aliased to a new underlying type.



<hr>
<h2>Model</h2>

<p>A model contains the particles and restraints that act on those particles. It can be optimized with respect to the restraints and particles that it contains.

<h3>Interface:</h3>
<pre>
public:
	Model();
	~Model();
	Model_Data* get_model_data(void);
	
	// particles
	void add_particle(Particle* particle);
	Particle* particle(size_t idx);

	// restraints
	void add_restraint_set(Restraint_Set* restraint_set);
	Restraint_Set* restraint_set(const std::string name);

	// for each restraint_set, call evaluate
	Float evaluate(bool calc_derivs);

	void show (std::ostream& out = std::cout);
</pre>


<h3>Issues:</h3>


<h3>Historical notes:</h3>



<hr>
<h2>Particle</h2>

<p>A particle is an entity within the model that has attributes with associated values.

<h3>Interface:</h3>
<pre>
public:
	Particle();
	~Particle();
	void set_model_data(Model_Data* model_data);

	// float attributes
	bool add_float(const std::string name, const Float value = 0.0, const bool optimize = false);
	Float_Index float_index(const std::string name);

	// int attributes
	bool add_int(const std::string name, const Int value);
	Int_Index int_index(const std::string name);

	// string attributes
	bool add_string(const std::string name, const String value);
	String_Index string_index(const std::string name);
	
	// status
	void set_is_active (bool is_active);
	bool is_active (void);
	
	void show (std::ostream& out = std::cout);
</pre>


<h3>Issues:</h3>

<p>A key issue is how to remove particles. Removing particles has at least two complications. The indexed attributes (see Model_Data) cannot actually be removed without disrupting the indexes used by other particles. Reuse also runs the risk of the new particle being used although the index was intended for the old one. Another complication is that it is not clear what the best way to handle restraints that reference a particle that has been deleted. Concerns have been raised about methods that require the restraint writer to do the bookkeeping.

<p>A proposed solution to the first complication is to deactivate rather than physically remove particles. Deactivated particles will continue to take up space in memory, but all indexes will continue to refer correctly to the associated particle attributes.

<p>A proposed solution to the second complication is to provide some functionality in the Restraint base class that will deactivate the restraint if any particles in the maintained list of particles is deactivated. The restraint writer can override this behavior if it is not appropriate for their particular restraint type.


<h3>Historical notes:</h3>

<p>Variables were initially handled separated from Float attributes. However, to simplify the interface, all Float attributes have can be optimizable variables if the appropriate flag is set. The disadvantage of this approach is that some storage space is allocated for all Float attributes that will not be used for those that are not optimized.




<hr>
<h2>Restraint_Set</h2>

<p>A restraint set is a container holding restraints and other restraint sets. It can also hold filters that can be used to deactivate some of the restraints.

<h3>Interface:</h3>
<pre>
public:
	Restraint_Set(std::string name = std::string("no_name"));
	~Restraint_Set();
	void set_model_data(Model_Data* model_data);
	
	std::string name(void) {return name_;}
	void set_name(std::string name) {name_ = name;}

	// return the score for this restraint or set of restraints
	// ... given the current state of the model
	Float evaluate(bool calc_deriv);
	
	void add_restraint(Restraint *restraint);
	void add_restraint_set(Restraint_Set *restraint_set);
	// void add_filter(Filter *filter);
	
	// status
	void set_is_active (const bool is_active);
	bool is_active (void);

	// called when at least one particle has been inactivated
	void check_particles_active (void);

	void show (std::ostream& out = std::cout);
</pre>

<h3>Issues:</h3>

<p>None of the methods are virtual here. The hope is that all restraint set functionality can be provided by the base class and will not be subclassed.

<h3>Historical notes:</h3>

<p>Restraint sets were initially a subclass of Restraints but it ended up being easier to keep them separate, so analagous functions are now overloaded rather than accessed via polymorphism. This was done in part to implement filters in a different way. Filters will be added to restraint sets and applied in the order that they are added. Previously, Filters were restraint sets that were applied to the restraints and restraint sets that they contained (including other filters). The approaches are basically equivalent.

<p> The model only contains restraint sets rather than individual restraints. The restraint sets are named, but the Model interface no longer provides a method for turning off restraints by hand. This functionality must be coded by sequencing through the restraint sets.


<hr>
<h2>Restraint</h2>

<p>A restraint uses the current state of some subset of particles of the model to determine a feature of the model and a score with respect to that feature. It can also calculate first derivatives for the score with respect to the feature and subsequently to the different particle attributes to provide a gradient in a direction that will reduce the current score. 

<h3>Interface:</h3>
<pre>
public:
	Restraint();
	virtual ~Restraint();
	void set_model_data(Model_Data* model_data);

	// return the score for this restraint or set of restraints
	// ... given the current state of the model
	virtual Float evaluate(bool calc_deriv) = 0;
	
	// status
	void set_is_active (const bool active);
	bool is_active (void);

	// called when at least one particle has been inactivated
	virtual void check_particles_active(void);
	
	virtual void show(std::ostream& out = std::cout);
</pre>


<h3>Issues:</h3>

<p>check_particles_active() is meant to be invisible to most users and almost no one should override this method unless they are defining a restraint where they are going to allow some particles within the restraint to be inactivated while still calculating some score based on the remaining particles.


<h3>Historical notes:</h3>

<p>Restraints were definable for a set of sets of particles so that a large number of similar restraints could be easily defined and efficiently specified and stored. This capability has been removed and current restraints tend to refer to one feature for one set of particles.

<p>However, it is still possible for a restraint to in fact represent a set of related restraints. It also might make sense for similar restraints that can use the same proximal pair list (non-bonded pair list) to be combined into a single restraint and for a pointer to that list to be held within the restraint. The restraints that use the list could then check before they re-evaluate whether the list needs to be updated. It might thus be possible to prevent any knowledge of the proximal pair list in the optimizers which seems desirable.


<hr>
<h2>Model_Data</h2>

<p>The model data refers to all of the attributes of the model and their associated values. Currently, all attributes are associated with particles but this need not be the case. For example, a restraint could add optimizable variables to the model data.

<p>The currently supported data types are Float, Int, and String. All Float values are considered potentially optimizable and have space allocated for storing derivatives. Also, groups of optimized variables with the same name reference in Particle instances have their statistics associated with changes in state saved in Model. For example, "X" variable for all particles would have a set of statistics that can be reached in Model with the name "X".

<h3>Interface:</h3>
<pre>
public:
	// variables
	class Float_Data
		{
		public:
			Float value_;
			Float deriv_;
			int stats_index_;
			bool is_optimized_;
		};
		
	// variable statistics
	// intended for keeping track of change sizes during optimization
	// ... for efficiency issues (e.g. updates of neighborhoods)
	class Statistics
		{
		public:
			Float min_;
			Float max_;
			Float max_delta_;
			Float min_delta_;
		};

	// particle float attributes (assumed differentiable variables)
	Float_Index add_float(const Float value, const std::string name="none");
	void set_float(const Float_Index idx, const Float value);
	Float get_float(const Float_Index idx);

	void add_to_deriv(const Float_Index idx, const Float value);
	Float get_deriv(const Float_Index idx);
	bool is_optimized(const Float_Index idx);
	void set_is_optimized(const Float_Index idx, bool is_optimized);

	void zero_derivatives(void);

	// particle int attributes
	Int_Index add_int(const Int value);
	void set_int(const Int_Index idx, const Int value);
	Int get_int(const Int_Index idx);
  
	// particle string attributes
	String_Index add_string(const String value);
	void set_string(const String_Index idx, const String value);
	String get_string(const String_Index idx);
</pre>


<h3>Issues:</h3>


<p>There is some question what is the best way to sequence through a list. Here we are using reset(), next(), and get(), which is common and is easy to access and use through Python. Here Opt_Float_Index_Iterator is used to get all of the Float attributes that are being optimized.

<p>The inconsistency of naming of the accessors here is due to fact that the normal method (the word alone without the get_ prefix) is disallowed because they are key words.

<h3>Historical notes:</h3>

<p>This new storage scheme is intended to allow efficiencies near those of one dimensional arrays for each variable type but allow particles to have very different attributes without lots of unused memory locations.

<hr>
<h2>Model_Loader</h2>

<p>The model loader loads the model from a file.

<h3>Interface:</h3>
<pre>
public:
	Model_Loader();
	~Model_Loader();

	// Model
	bool load_model(Model& model, const std::string& fname);
	void load_particle(Particle& particle, std::istream& in);
	void load_restraint_set(Model& model, Restraint_Set& restraint_set, std::istream& in);
	void load_distance_restraints(Model& model, Restraint_Set& restraint_set, std::istream& in);
	score_func* get_score_func(const std::string score_func_name);
	
</pre>

<h3>Issues:</h3>
<p>The loader will probably end up not being used, since it easier to write your own in Python or use the Python XML loader.

<h3>Historical notes:</h3>

<p>Each component of the model was previously responsible for loading itself from a text file. This has some advantages in that it extending the system can be contained within a single Restraint class definition. However, the current mode assumes that instantiation of components is more likely to come through the Python interface than through reading of a single text file. In that case, the Model Loader will be used mostly internally for testing.


