Import('env')

overview="""

The library provides support for the %RMF (short for Rich Molecular Format)
file format for storing
hierarchical molecular data (such as atomic or coarse
grained representations of proteins), along with
markup, including geometry and score data.

\\namespace RMF

This library provides support for %RMF (Rich Molecular Format) file format for
storing hierarchical molecular data (such as atomic
or coarse grained representations of proteins), along
with markup, including geometry and score data. The library uses the \\external{http://www.hdf5.org,HDF5} library to manage the data on
disk. Other backends (eg mmCIF) could be used, if desired.

\\section ff 1 RMF Files

The %RMF file format stores hierarchical data about a molecular
structure in a binary file. This data can include

- molecular structures stored hierarchically. These structures need not be atomic resolution.

- feature information about parts
of the structures, such as how well it fits a particular
measurement.

- geometric markup such as segments, surfaces, balls,
colors which can be used to improve visualization

For example, a protein can be stored as a hierarchy where the root
is the whole molecule. The root has one node per chain, each chain
has one node per residue and each residue one node per atom. Each
node in the hierarchy has the appropriate data stored along with
it: a chain node has the chain identifier, and a residue
node has the type of the residue stored and atom nodes have coordinates,
atom type and elements. Bonds between atoms are stored explicity.

The file might also include a feature node storing the r-value for a
FRET measurement between two residues as well as extra markers to highlight
key parts of the molecule.

Multiple conformations on the hierarchy are stored as frames.
Each frame has the same hierarchical structure, but some aspects of
the data (eg coordinates) can have one value for each frame (or no
value for a particle frame if they happen not be be applicable
then).

A hierarchical storage format was chose since
- most biological molecules have a natural hierarchical structure
- it reduces redundancy (eg the residue type is only stored once, as is the residue index)
- most software uses a hierarchy of some sort to represent structures at runtime, so less translation is needed
- low resolution and multiresolution structures are then more natural as they are just truncations of a full, atomic hierarchy.

See \internal{simple.xml, simple.rmf} for an XML dump of the %RMF generated from
\internal{simple.pdb.txt, simple.pdb}. For a larger example, see
 \internal{3O3Y.xml, 3O3Y.rmf} from \internal{3O3Y.pdb.txt, 3O3Y.pdb}. Note,
that viewing XML files works much better with \external{http://www.mozilla.org/firefox, Firefox}
\external{http://chrome.google.com/, Google Chrome} than with Safari.

\\subsection structure 1.1 The RMF Hierarchy
R
More technically, each node in the %RMF hierarchy has

- a type (RMF::NodeType)

- a human readable name (RMF::NodeHandle::get_name()

- an ID that is unique within the file
  (RMF::NodeHandle::get_id())

- and associated attributes.

Each attribute is identified by a key (RMF::Key) and is
defined by a unique combination of
- a type. The currently supported types are
   - \c Float: a 64 bit floating point value
   - \c String: an ASCII string
   - \c Int: a 64 bit integer
   - \c Index: a postive 64 bit index
   - \c Node: another node in the hierarchy
   - \c Floats: a list of 64 bit floats
   - \c Strings: a list of strings
   - \c Nodes: a list of nodes
   - \c Indexes: a list of indexes

- a category such as RMF::physics, identified by
an RMF::Category

- a name string

On a per %RMF basis, the data associated with a given key can either
have one value for each node which has that attribute, or one value
per frame per node with the attribute. The methods in
RMF::NodeHandle to get and set the attributes take an optional
frame number.

A number of data categories and attributes have been defined so
far. New ones can be added as needed, without affecting existing
files. See the documentation for each category for more
information:
- \\ref physics "physics",
- \\ref sequence "sequence",
- \\ref shape "shape",
- \\ref feature "feature",
- \\ref publication "publication",
- \\ref bond "bond".

In addition, arbitrary data can be associated with tuples of Nodes.
This mechanism is used to store bond information (which is always stored
in the file to avoid the difficulties associated with parsing PDB files).
Information about bond angles or torsion angles could be stored
using the same mechanism. Currently, the library API supports tuples up to
size 4, but we can add arbitrary sized tuples when needed.

\\subsection adding 1.2 Adding custom data to an RMF

When adding data to an %RMF file that is just to be used for
internal consumption, one should create a new category. For
example, \imp defines an ''imp'' category when arbitrary particle
data is stored.

If, instead, the data is likely to be a general interest, it
probably makes sense to add it to the documentation of this library
so that the names used can be standardized.


\\subsection rmf_hdf5 1.3 RMF and HDF5

The %RMF data is stored in a single
\\external{http://www.hdfgroup.org/HDF5/doc/UG/UG_frame09Groups.html,HDF5
group} in the file on disk. As a result, one could easily put
multiple %RMF "files" in a single HDF5 archive, as well as store
other data (such as electron density maps).  However, adding extra
data sets within the %RMF HDF5 group is not supported.

HDF5 was chosen over the other candidates as it
  - supports binary i/o, avoiding issues parsing and delimiters that occur with text files
  - supports random access, allowing loading of individual conformations without reading the who file
  - can use internal compression to reduce the size of files
  - has well developed support library facilitating easy use from most programming languages and has a variety of command line tools to aid debugging

\\note The following information about how the data is stored on disk
is not complete. Implementers should instead use the API provided by this
library.

The %RMF data is spread over various data sets, divided up into classes based on
the RMF::Category, data type and whether the particular attribute
has one value per frame or just one for the whole file and whether the data
is for one one or a tuple of nodes. Each node
has space allocated where it can store information about whether it
has attributes in a given class, and if so, where in the corresponding
data set the attributes are stored.

Space is allocated in the appropriate table if an attribute in a particular
class is used in a node. A special marker value
is used to signify when a particular attribute in a class is not found for a
particular node (e.g. a -1 is used to signify that a node does not
have an index attribute).

To get any idea of the data layout in a file, see the dump (produced by
 \c h5dump) of a tiny %RMF, \internal{simple.hdf5.txt, simple.rmf}. For a larger
example, see \internal{3O3Y.hdf5.txt, 3O3Y.rmf}.

\\section lib 2 The RMF library

The %RMF library provides an intermediate level interface to facilitate I/O of
%RMF data into and out of programs. The primary classes of interest are
RMF::RootHandle representing the root of an %RMF hierarchy and RMF::NodeHandle
representing a node in the hierarchy.

The file is automatically closed when the last handle to it is destroyed.

\\subsection assoc 2.1 Associations

The %RMF wrapper has the concept of an association between nodes in
its hierarchy and objects in the program accessing. The methods
RMF::RootHandle::get_node_handle_from_association(),
RMF::NodeHandle::set_association() and
RMF::NodeHandle::get_assocation() can be used to take advantage of
this. The idea is that one can store pointers to the programatic
data structures corresponding to the nodes and so avoid maintaining
ones own lookup table.

\\subsection accelerating 2.2 Accelerated I/O

Traversing large %RMF files can be slow, especially when doing so in scripting
languages. The library provides a few methods RMF::get_values() to accelerate
this process when loading values for each of a number of frames. Other such
batch methods can be added as appropriate.

\\subsection parallel 2.3 Parallel I/O

If RMF::RootHandle::flush() has been called since the last change, it is safe
to read the file from another process. Writing from more than one process is not
supported. Nor is reading or writing from more than one thread of the same
program.

\\subsection invariants 2.4 Invariants

Currently, there is little explicit checking of invariants between attributes
in the %RMF file. An extensible framework for checking invariants on file
close and open will be added.


\\subsection bindings 2.5 Other language bindings

The %RMF library currently supports C++ and Python. The API is
written so that \\external{http://www.swig.org,SWIG} can be used to
easily generate bindings for most languages. The two main
exceptions are C and Fortran. Until the SWIG C target support is
finished, these can be supported by writing a simple C API
manually, probably a weeks work.

\\subsection hdf5access 2.6 HDF5 wrappers

The library provides a \\ref hdf5 "simple wrapper for the HDF5 library".

\\section bins 3 Helper programs

   - \c rmf_show prints out the hierarchy written to the file.

   - \c rmf_pdb converts an rmf file to or from a PDB file, assuming all hierarchies
   in the rmf file are atomic resolution.

   - \c rmf_xml converts an rmf file to an XML files that can be opened in an XML viewer
   (eg Google Chrome or Firefox). These viewers support collapsing of subtrees, which
   makes it much easier to get around large hierarchies.

See the \\ref application_rmf_tools "RMF tools" application for
\\imp-related helper programs.


\\page categories Categories

\\section singleton_categories Categories
The following are pre-defined Categories for data stored in single nodes.

\\rmfattributetable_begin{Physics}
    \\rmfattribute{cartesian x, Float, the x coordinate in angstrom, }
    \\rmfattribute{cartesian y, Float, the y coordinate in angstrom,
    required if other cartesian coordinates are included}
    \\rmfattribute{cartesian z, Float, the z coordinate in angstrom,
    required if other cartesian coordinates are included}
    \\rmfattribute{radius, Float,
    the radius of the volume occupied by the entity in angstrom,
    positive; requires coordinates }
    \\rmfattribute{mass, Float, the mass of the node in Daltons,
    positive; requires coordinates}
    \\rmfattribute{diffusion coefficient, Float,
    the diffusion coefficient for the node in angstroms per squared femtosecond,
    positive}
    \\rmfattributetable_end

\\rmfattributetable_begin{Sequence}
    \\rmfattribute{first residue index, Int,
    the first residue index included in this node,
    any descendent that has an index must be in the specified range}
    \\rmfattribute{last residue index, Int,
    the last residue index included in this node,
    must be greater than begin residue index}
    \\rmfattribute{element, Index, the atomic number of the element,
    nodes with elements cannot have children}
    \\rmfattribute{secondary structure, Index,
    0 for unstructured; 1 for helix; 2 for strand,
    node must have a residue type}
    \\rmfattribute{sequence, Strings,
    store the sequence as a list of three letter codes,
    if the index range is specified then the lengths must match;
    children with residue types must match}
    \\rmfattribute{residue type, String,
    the three letter code for the residue type,
    this must match any sequence information higher in the tree and no
    descendent must have a residue type}
    \\rmfattribute{chain id, Index,
    stores an integer for the chain identifier. When translating from
    pdb files the position in the alphabet of the chain should probably
    be used (eg chain 'A' is 0), }
    \\rmfattributetable_end

\\rmfattributetable_begin{Shape}
    \\rmfattribute{cartesian x, Float, the x coordinate,
    must have y and z and no coordinates fields}
    \\rmfattribute{cartesian y, Float, the y coordinate,
    must have x and z and no coordinates fields}
    \\rmfattribute{cartesian z, Float, the z coordinate,
    must have x and y and no coordinates fields}
    \\rmfattribute{cartesian xs, Floats, the x coordinates,
    the number must match that of the y and z coordinates}
    \\rmfattribute{cartesian ys, Floats, the y coordinates,
    the number must match that of the x and z coordinates}
    \\rmfattribute{cartesian zs, Floats, the z coordinates,
    the number must match that of the x and y coordinates}
    \\rmfattribute{radius, Float, the radius, positive}
    \\rmfattribute{rgb red, Float, the red channel for the color,
    between 0 and 1; must have green and blue}
    \\rmfattribute{rgb green, Float, the green channel for the color,
    between 0 and 1; must have red and blue}
    \\rmfattribute{rgb blue, Float, the blue channel for the color,
    between 0 and 1; must have red and green}
    \\rmfattribute{triangle vertex 0s Indexes,
    indexes into the coordinates fields to define triangular faces,
    indexes must be less than the coordinates length;
    triangle vertex 1s and triangle vertex 2s must be there}
    \\rmfattribute{triangle vertex 1s, Indexes,
    indexes into the coordinates fields to define triangular faces,
    indexes must be less than the coordinates length;
    triangles vertex 1 and triangles vertex 2 must be there}
    \\rmfattribute{triangle vertex 2s, Indexes,
    indexes into the coordinates fields to define triangular faces,
    indexes must be less than the coordinates length;
    triangles vertex 1 and triangles vertex 2 must be there}
    \\rmfattribute{type, Index, 0 for sphere(s); 1 for cylinder(s);
    2 for surface,
    appropriate attributes must be there;
    if cylinders or spheres there must be a radius;
    if cylinder and the coordinates fields are used the size
    must be divisible by 2}
    \\rmfattributetable_end

    \\rmfattributetable_begin{Feature}
    \\rmfattribute{score, Float, the score, }
    \\rmfattribute{representation, NodeIDs, the nodes involved in the feature, }
    \\rmfattributetable_end


    \\rmfattributetable_begin{Publication}
    \\rmfattribute{title, String, article title, }
    \\rmfattribute{book title, String, the book title, }
    \\rmfattribute{chapter, String, the book chapter, must have book title}
    \\rmfattribute{journal, String, the name of the journal, }
    \\rmfattribute{url, String, a url for the publication, }
    \\rmfattribute{pubmed id, Int, the pubmed id, }
    \\rmfattribute{year, Int, the year of publication, }
    \\rmfattribute{first page, Index, the first page number, }
    \\rmfattribute{last page, Index, the last page number, }
    \\rmfattribute{author, Strings,
    the author names as a list for "Firstname Lastname", }
    \\rmfattributetable_end

    \\section pair_categories Pair Categories
    The following are categories for storing data on pairs of nodes.
    \\rmfattributetable_begin{Bond}
      \\rmfattribute{length, Float, the length in angstroms, }
      \\rmfattribute{type, Index, the bond type (0 covalent, 1 ionic,
      2 hydrogen...),
      \\rmfattributetable_end
"""
env.IMPModuleDoc(authors=["Daniel Russel"],
                 brief="This module provides %RMF I/O",
                 overview=overview,
                 publications=env.IMPStandardPublications(),
                 files=["3O3Y.hdf5.txt", "3O3Y.xml", "simple.hdf5.txt",
                        "simple.xml", "3O3Y.pdb.txt", "simple.pdb.txt"],
                 license=env.IMPStandardLicense())
