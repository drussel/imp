%{
#include <RMF/internal/swig_helpers.h>
%}
%include "RMF_types.i"
%include "RMF/infrastructure_macros.h"

/* Apply the passed macro to each type used in RMF */
%define IMP_RMF_SWIG_FOREACH_TYPE(macroname)
  macroname(int, Int, Ints, int);
  macroname(float, Float, Floats, double);
  macroname(index, Index, Indexes, int);
  macroname(string, String, Strings, std::string);
  macroname(node_id, NodeID, NodeIDs, RMF::NodeID);
  macroname(node_ids, NodeIDs, NodeIDsList, RMF::NodeIDs);
  macroname(ints, Ints, IntsList, RMF::Ints);
%enddef

%pythoncode %{
_types_list=[]
def get_data_types():
   return _types_list
%}


%{
namespace {
void handle_exception(void) {
    try {
      throw;
    } catch (const RMF::Exception &e) {
      PyErr_SetString(PyExc_RuntimeError, e.what());
    } catch (...) {
      PyErr_SetString(PyExc_RuntimeError,
                      "Unknown error caught by Python wrapper");
    }
}
}
%}

%exception {
  try {
    $action
  } catch (...) {
    // If Python error indicator is set (e.g. from a failed director method),
    // it will be reraised at the end of the method
    if (!PyErr_Occurred()) {
      handle_exception();
    }
    SWIG_fail;
  }
}


/* Declare the needed things for each type */
%define IMP_RMF_SWIG_DECLARE_TYPE(lcname, Ucname, Ucnames, Type)
%inline %{
namespace RMF {
 const Type Null##Ucname=Ucname##Traits::get_null_value();
}
%}
namespace RMF {
%rename(_##Ucname##Traits) Ucname##Traits;
}

IMP_RMF_SWIG_VALUE_INSTANCE(RMF, Ucname##Key, Ucname##Key, Ucname##Keys);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, Pair##Ucname##Key, Pair##Ucname##Key, Pair##Ucname##Keys);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, Triplet##Ucname##Key, Triplet##Ucname##Key, Triplet##Ucname##Keys);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, Quad##Ucname##Key, Quad##Ucname##Key, Quad##Ucname##Keys);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5##Ucname##DataSet1D, HDF5##Ucname##DataSet1D, HDF5##Ucname##DataSet1Ds);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5##Ucname##DataSet2D, HDF5##Ucname##DataSet2D, HDF5##Ucname##DataSet2Ds);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5##Ucname##DataSet3D, HDF5##Ucname##DataSet3D, HDF5##Ucname##DataSet3Ds);
%pythoncode %{
_types_list.append(#lcname)
%}
%enddef

%define IMP_RMF_SWIG_DEFINE_TYPE(lcname, Ucname, Ucnames, Type)
%template(HDF5##Ucname##DataSet1D) RMF::HDF5DataSetD<RMF::Ucname##Traits, 1>;
%template(HDF5##Ucname##DataSet2D) RMF::HDF5DataSetD<RMF::Ucname##Traits, 2>;
%template(HDF5##Ucname##DataSet3D) RMF::HDF5DataSetD<RMF::Ucname##Traits, 3>;
%template(Ucname##Key) RMF::Key<RMF::Ucname##Traits, 1>;
%template(Pair##Ucname##Key) RMF::Key<RMF::Ucname##Traits, 2>;
%template(Triplet##Ucname##Key) RMF::Key<RMF::Ucname##Traits, 3>;
%template(Quad##Ucname##Key) RMF::Key<RMF::Ucname##Traits, 4>;
%enddef

IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodeID, NodeID, NodeIDs);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodePairID, NodePairID, NodePairIDs);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodeTripletID, NodeTripletID, NodeTripletIDs);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodeQuadID, NodeQuadID, NodeQuadIDs);

IMP_RMF_SWIG_NATIVE_VALUES_LIST(RMF, double, Floats, FloatsList);
IMP_RMF_SWIG_NATIVE_VALUES_LIST(RMF, int, Ints, IntsList);
IMP_RMF_SWIG_NATIVE_VALUES_LIST(RMF, std::string, Strings, StringsList);
IMP_RMF_SWIG_VALUE_BUILTIN(RMF, Float, Floats, double);
IMP_RMF_SWIG_VALUE_BUILTIN(RMF, Int, Ints, int);
IMP_RMF_SWIG_VALUE_BUILTIN(RMF, String, Strings, std::string);
IMP_RMF_SWIG_NATIVE_VALUE(float);
IMP_RMF_SWIG_NATIVE_VALUE(double);
IMP_RMF_SWIG_NATIVE_VALUE(int);
IMP_RMF_SWIG_NATIVE_VALUE(std::string);


IMP_RMF_SWIG_GRAPH(RMF, NodeTree, NodeTree, RMF::NodeHandle);
IMP_RMF_SWIG_VALUE(RMF, NodeHandle, NodeHandles);
IMP_RMF_SWIG_VALUE(RMF, RootHandle, RootHandles);
IMP_RMF_SWIG_VALUE_TEMPLATE(RMF, CategoryD);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, Category, Category, Categories);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, PairCategory, PairCategory, PairCategories);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, TripletCategory, TripletCategory, TripletCategories);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, QuadCategory, QuadCategory, QuadCategories);
IMP_RMF_SWIG_VALUE_TEMPLATE(RMF, Key);
IMP_RMF_SWIG_VALUE(RMF, HDF5Group, HDF5Groups);
IMP_RMF_SWIG_VALUE(RMF, HDF5File, HDF5Files);
IMP_RMF_SWIG_VALUE_TEMPLATE(RMF, HDF5DataSetD);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5DataSetIndex1D, HDF5DataSetIndex1D, HDF5DataSetIndex1Ds);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5DataSetIndex2D, HDF5DataSetIndex2D, HDF5DataSetIndex2Ds);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, HDF5DataSetIndex3D, HDF5DataSetIndex3D, HDF5DataSetIndex3Ds);
IMP_RMF_SWIG_VALUE_TEMPLATE(RMF, NodeSetHandle);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodePairHandle, NodePairHandle, NodePairHandles);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodeTripletHandle, NodeTripletHandle, NodeTripletHandles);
IMP_RMF_SWIG_VALUE_INSTANCE(RMF, NodeQuadHandle, NodeQuadHandle, NodeQuadHandles);
IMP_RMF_SWIG_PAIR(RMF, NodeHandle, BondPair, BondPairs)

IMP_RMF_SWIG_FOREACH_TYPE(IMP_RMF_SWIG_DECLARE_TYPE);

// char is special cased since it is just used for attributes
namespace RMF {
%rename(_CharTraits) CharTraits;
}

%extend RMF::RootHandle {
   %pythoncode %{
    def get_keys(self, kc, arity=1):
        ret=[]
        for t in _types_list:
           if arity==1:
             fn= getattr(self, "get_"+t+"_keys")
           elif arity==2:
             fn= getattr(self, "get_pair_"+t+"_keys")
           elif arity==3:
             fn= getattr(self, "get_triplet_"+t+"_keys")
           elif arity==4:
             fn= getattr(self, "get_quad_"+t+"_keys")
           ret.extend(fn(kc))
        return ret
  %}
   %pythoncode %{
    def get_node_sets(self, arity):
        ret=[]
        if arity==2:
          return self.get_node_pairs()
        elif arity==3:
          return self.get_node_triplets()
        elif arity==4:
          return self.get_node_quads()
        else:
          return []
  %}
  %pythoncode %{
    def get_set_categories(self, arity):
        ret=[]
        if arity==1:
          return self.get_categories()
        if arity==2:
          return self.get_pair_categories()
        elif arity==3:
          return self.get_triplet_categories()
        elif arity==4:
          return self.get_quad_categories()
        else:
          return []
  %}
}




%include "RMF/NodeID.h"
%include "RMF/hdf5_handle.h"
%include "RMF/hdf5_types.h"
%template(_IntsTraits) RMF::ArrayTraits<RMF::IntTraits>;
%template(_NodeIDsTraits) RMF::ArrayTraits<RMF::NodeIDTraits>;

%include "RMF/HDF5DataSetD.h"
%template(HDF5DataSetIndex1D) RMF::HDF5DataSetIndexD<1>;
%template(HDF5DataSetIndex2D) RMF::HDF5DataSetIndexD<2>;
%template(HDF5DataSetIndex3D) RMF::HDF5DataSetIndexD<3>;
%template(_IndexDataSet2DTraits) RMF::HDF5DataSetDTraits<RMF::IndexTraits, 2>;
%template(_FloatDataSet2DTraits) RMF::HDF5DataSetDTraits<RMF::FloatTraits, 2>;
%template(NodeID) RMF::NodeIDD<1>;
%template(NodePairID) RMF::NodeIDD<2>;
%template(NodeTripletID) RMF::NodeIDD<3>;
%template(NodeQuadID) RMF::NodeIDD<4>;


%include "RMF/Key.h"
IMP_RMF_SWIG_FOREACH_TYPE(IMP_RMF_SWIG_DEFINE_TYPE);

%include "RMF/HDF5Group.h"
%include "RMF/Category.h"

%template(Category) RMF::CategoryD<1>;
%template(PairCategory) RMF::CategoryD<2>;
%template(TripletCategory) RMF::CategoryD<3>;
%template(QuadCategory) RMF::CategoryD<4>;

%include "RMF/NodeSetHandle.h"
%include "RMF/NodeHandle.h"
%include "RMF/RootHandle.h"
%include "RMF/names.h"

%pythoncode %{

import re
import math
import sys
import os
import random
import time
import types
import shutil
import datetime
import unittest



class TestCase(unittest.TestCase):
    """Super class for RMF test cases"""

    def setUp(self):
        self.start_time=datetime.datetime.now()

    def tearDown(self):
        delta= datetime.datetime.now()-self.start_time
        try:
            pv = delta.total_seconds()
        except AttributeError:
            pv = (float(delta.microseconds) \
                  + (delta.seconds + delta.days * 24 * 3600) * 10**6) / 10**6
        if pv > 1:
            print >> sys.stderr, "in %.3fs ... " % pv,

    def get_input_file_name(self, filename):
        """Get the full name of an input file in the top-level
           test directory."""
        # If we ran from run-all-tests.py, it set an env variable for us with
        # the top-level test directory
        if 'TEST_DIRECTORY' in os.environ:
            top = os.environ['TEST_DIRECTORY']
            return os.path.join(top, 'input', filename)
        else:
            # Otherwise, search up from the test's directory until we find
            # the input directory
            testdir = os.path.dirname(os.path.abspath(sys.argv[0]))
            dirs = testdir.split(os.path.sep)
            for i in range(len(dirs), 0, -1):
                input = os.path.sep.join(dirs[:i] + ['input'])
                if os.path.isdir(input):
                    return os.path.join(input, filename)
        # If not found, default to the current working directory:
        ret= os.path.join('input', filename)
        if not open(ret, "r"):
            raise IOError("Test input file "+ret+" does not exist")

    def get_tmp_file_name(self, filename):
        """Get the full name of an output file in the build/tmp directory."""
        dirpath=os.environ['IMP_TMP_DIR']
        if not os.path.exists(dirpath):
            os.mkdir(dirpath)
        return os.path.join(dirpath, filename)

"""
class _TestResult(unittest.TextTestResult):
    def getDescription(self, test):
        doc_first_line = test.shortDescription()
        if self.descriptions and doc_first_line:
            return doc_first_line
        else:
            return str(test)


class _TestRunner(unittest.TextTestRunner):
    def _makeResult(self):
        return _TestResult(self.stream, self.descriptions, self.verbosity)
"""

def main(*args, **keys):
    """Run a set of tests; essentially the same as unittest.main(). Obviates
       the need to separately import the 'unittest' module, and ensures that
       main() is from the same unittest module that the IMP.test testcases
       are."""
    #testRunner=_TestRunner
    return unittest.main( *args, **keys)
%}
