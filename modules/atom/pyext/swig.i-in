namespace IMP {
namespace atom {
%warnfilter(403) ForceFieldParameters;
}
}

%include "IMP/atom/macros.h"

// must be before hierarchy
%include "IMP/atom/bond_decorators.h"

// it is used as a base class
%include "IMP/atom/Hierarchy.h"

// since we have to fake it


%feature("shadow") IMP::atom::Hierarchies::__iter__ %{
def __iter__(self):
    return IMP.DecoratorIterator(self)
%}


%extend IMP::atom::Hierarchies {
  IMP::atom::Hierarchy __getitem__(int index) const {
    if (index < 0) index= index+self->size();
    if (index >= static_cast<int>(self->size())) {
       IMP_THROW("Index out of range in getitem" << index
       << self->size(), IMP::IndexException);
    }
    return self->operator[](index);
  }
  void __setitem__(int index, IMP::atom::Hierarchy val) {
    if (index < 0) index= index+self->size();
    if (index >= static_cast<int>(self->size())) {
       IMP_THROW("Index out of range in setitem" << index
       << self->size(), IMP::IndexException);
    }
    self->set(index, val);
  }
  int __len__() const {
    return self->size();
  }
  void append(IMP::atom::Hierarchy d) {
    self->push_back(d);
  }
  IMP::atom::Hierarchies
   __add__(const IMP::atom::Hierarchies &o) const {
    IMP::atom::Hierarchies ret(*self);
    ret.insert(ret.end(), o.begin(), o.end());
    return ret;
  }
  std::vector<IMP::atom::Hierarchy> __list__() const {
    std::vector<IMP::atom::Hierarchy> ret(self->begin(), self->end());
    return ret;
  }
  IMP::atom::Hierarchies __getslice__(int b, int e) const {
    if (e < 0) e= self->size()+e;
    if (b < 0) b= self->size()+b;
    IMP::atom::Hierarchies ret;
    ret.insert(ret.end(), self->begin()+b, self->begin()+e);
    //for ( int c=b; c!= e; ++c) {
    //   ret.push_back(self->operator[](c));
    //}
    return ret;
  }
}


%feature("shadow") IMP::atom::HierarchiesTemp::__iter__ %{
def __iter__(self):
    return IMP.DecoratorIterator(self)
%}

%extend IMP::atom::HierarchiesTemp {
  IMP::atom::Hierarchy __getitem__(int index) const {
    if (index < 0) index= index+self->size();
    if (index >= static_cast<int>(self->size())) {
       IMP_THROW("Index out of range in getitem" << index
       << self->size(), IMP::IndexException);
    }
    return self->operator[](index);
  }
  void __setitem__(int index, IMP::atom::Hierarchy val) {
    if (index < 0) index= index+self->size();
    if (index >= static_cast<int>(self->size())) {
       IMP_THROW("Index out of range in setitem" << index
       << self->size(), IMP::IndexException);
    }
    self->set(index, val);
  }
  int __len__() const {
    return self->size();
  }
  void __iter__() const {
     //PyErr_SetString(PyExc_NotImplementedError, const_cast<char*>("No such method"));
  }
  void append(IMP::atom::Hierarchy d) {
    self->push_back(d);
  }
  IMP::atom::Hierarchies
   __add__(const IMP::atom::HierarchiesTemp &o) const {
    IMP::atom::Hierarchies ret(*self);
    ret.insert(ret.end(), o.begin(), o.end());
    return ret;
  }
  std::vector<IMP::atom::Hierarchy> __list__() const {
    std::vector<IMP::atom::Hierarchy> ret(self->begin(), self->end());
    return ret;
  }
  IMP::atom::HierarchiesTemp __getslice__(int b, int e) const {
    if (e < 0) e= self->size()+e;
    if (b < 0) b= self->size()+b;
    IMP::atom::HierarchiesTemp ret;
    ret.insert(ret.end(), self->begin()+b, self->begin()+e);
    //for ( int c=b; c!= e; ++c) {
    //   ret.push_back(self->operator[](c));
    //}
    return ret;
  }
}




/* Wrap our own classes */
%include "IMP/atom/estimates.h"
%include "IMP/atom/distance.h"
%include "IMP/atom/smoothing_functions.h"
%include "IMP/atom/BondEndpointsRefiner.h"
%include "IMP/atom/BondPairContainer.h"
%include "IMP/atom/BondSingletonScore.h"
%include "IMP/atom/CoverBond.h"
%include "IMP/atom/BrownianDynamics.h"
%include "IMP/atom/Diffusion.h"
%include "IMP/atom/Chain.h"
%include "IMP/atom/Charged.h"
%include "IMP/atom/CoulombPairScore.h"
%include "IMP/atom/Domain.h"
%include "IMP/atom/LennardJones.h"
%include "IMP/atom/MolecularDynamics.h"
%include "IMP/atom/VelocityScalingOptimizerState.h"
%include "IMP/atom/selectors.h"
%include "IMP/atom/Fragment.h"
%include "IMP/atom/SimulationParameters.h"
%include "IMP/atom/Mass.h"
%include "IMP/atom/BondedPairFilter.h"

namespace IMP {
  namespace atom {
    %template(show_molecular_hierarchy) IMP::core::show<IMP::atom::Hierarchy>;
   // swig has random, perplexing issues if these are higher in the file
   %template(_KeyBaseAtomf) ::IMP::KeyBase<IMP_ATOM_TYPE_INDEX, false>;
   %template(_KeyBaseAtomt) ::IMP::KeyBase<IMP_ATOM_TYPE_INDEX, true>;
   %template(_KeyBaseResiduef) ::IMP::KeyBase<IMP_RESIDUE_TYPE_INDEX, false>;
   %template(_KeyBaseResiduet) ::IMP::KeyBase<IMP_RESIDUE_TYPE_INDEX, true>;
   %template(_KeyBaseHierarchyf) ::IMP::KeyBase<IMP_HIERARCHY_TYPE_INDEX, false>;
   %template(_KeyBaseHierarchyt) ::IMP::KeyBase<IMP_HIERARCHY_TYPE_INDEX, true>;
  }
}
%include "IMP/atom/element.h"
%include "IMP/atom/Atom.h"
%include "IMP/atom/Residue.h"
%include "IMP/atom/ForceFieldParameters.h"
%include "IMP/atom/CharmmParameters.h"
%include "IMP/atom/force_fields.h"
%include "IMP/atom/pdb.h"



namespace IMP {
  namespace atom {
   // must go after the above headers
   %template(HierarchyVector) ::std::vector<IMP::atom::Hierarchy>;
   //%implicitconv(Hierarchies)
   IMP_SWIG_DECORATORS(Atom, Atoms, Hierarchies)
   IMP_SWIG_DECORATORS(Residue, Residues, Hierarchies)
   IMP_SWIG_DECORATORS(Fragment, Fragments, Hierarchies)
   IMP_SWIG_DECORATORS(Domain, Domains, Hierarchies)
   IMP_SWIG_DECORATORS(Chain, Chains, Hierarchies)
   IMP_SWIG_DECORATORS(Bond, Bonds, Particles)
   IMP_SWIG_DECORATORS(Bonded, Bondeds, Particles)
   IMP_SWIG_DECORATORS(Diffusion, Diffusions, core::XYZs)
   IMP_SWIG_DECORATORS(SimulationParameters, SimulationParameterss, Particles)
  }
}
