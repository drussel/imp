Import('env')

# All .dox, .pdf and .pdb files are installed
env.IMPModuleDoc(env.IMPModuleGetDocs(),
                 authors=["Keren Lasker", "Daniel Russel"],
                 # Provide a brief description of what the module does
                 brief="MODULENAME provides a divide and conquer sampler. It provides a simpler interface and (hopefully) faster performance than the original IMP.domino module.",
                 # Provide a longer description of what the module does
                 # This description can have multiple paragraphs and all sorts of markup
                 overview="""This module provides a sampler which finds good solutions over a discrete sampling space. That is, given a scoring function encoded in the model and a list of possible states for each particle of the model that is allowed to change, encoded in a ParticleStates object, it finds all configurations of the model that have less than a certain score.

The process works by dividing the set of all optimized particles into subsets (represented using a Subset object). Good conformations for these subsets are found which are then combined together to produce the score for the whole model. A conformation is represented using a SubsetState object.

The central class is the DominoSampler which does the actual computation of good configruation. The computation is parameterized by a objects of several other types:
- each particle which is allowed to change must have a corresponding ParticleStates stored in
  the ParticleStatesTable made available to the DominoSampler.
- a SubsetEvaluatorTable parameterizes how a given configuration of a subset is scored. By
  default, the Model is used.
- a SubsetStatesTable parameterizes how the set of states of a subset are generated from the states of the constituent particle. The default one skips conformations which assign two particles to the same state and conformations which do not score well.

These classes are structured as tables which return the objects which act on
a particle subset or particle when asked. For example, a SubsetEvaluatorTable
has one main method SubsetEvaluatorTable::get_subset_evaluator() which takes
a Subset and returns a SubsetEvaluator. The SubsetEvaluator has a method
SubsetEvaluator::get_score() which can return the score for any conformation
(SubsetState) of the previously provided subset.

Implementation todo list:
- avoid rebuilding indexes repeatedly
- better filtering of states based on
   - lower bounds on the score of the rest of the model
- perhaps compact represetnation of incomplete states
- reduce looping through lists for reconciliation
- replace Subset with something that uses a memory pool if allocation becomes an issue
- figure out a better way of ordering particles to try when enumerating them. Factors are: number of filters potentially acting on each particle
- have a central table which lists dofs left for each particle, if any node can't find a state with the particle in a given state, it is removed from the list

Handling of compound restraints:
- define a static container as one which does not depend on any particles
- general case: if the input container is static, decompose the restraint
- general case: if it is not static, I don't know what to do. Restraint needs to
  get all possible particles from container and produce input over those. Throw
  exception for now
- special case 1: close pairs container, figure out a superset of all interactions

changes to IMP:
- remove get_interacting_particles()
- add get_subrestraints() method to restraint
- remove the partial evaluate support
- fix evaluation of individual restraints: make sure not incremental
- fix benchmarks
""",
                 publications=env.StandardPublications(),
                 license="Being worked out (currently have some code from Afra)"
#env.StandardLicense()
)
