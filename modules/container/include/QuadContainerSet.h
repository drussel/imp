/**
 *  \file QuadContainerSet.h
 *  \brief Store a set of QuadContainers
 *
 *  This file is generated by a script (tools/maintenance/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 */

#ifndef IMPCONTAINER_QUAD_CONTAINER_SET_H
#define IMPCONTAINER_QUAD_CONTAINER_SET_H

#include "container_config.h"
#include <IMP/QuadContainer.h>
#include <IMP/container_macros.h>
#include <IMP/internal/container_helpers.h>
#include <IMP/scoped.h>

IMPCONTAINER_BEGIN_NAMESPACE

//! Stores a set of QuadContainers
/** The input sets must be disjoint. This can change if there is
    demand for it.

    \usesconstraint
*/
class IMPCONTAINEREXPORT QuadContainerSet
  : public QuadContainer
{
  static QuadContainerSet* get_set(QuadContainer* c) {
    return dynamic_cast<QuadContainerSet*>(c);
  }
 public:
  //! Construct and empty set
  QuadContainerSet(Model *m,
                        std::string name="QuadContainerSet %1%");

  QuadContainerSet(const QuadContainersTemp &pc,
                        std::string name="QuadContainerSet %1%");

  bool get_contains_particle_quad(const ParticleQuad&) const;

  /** \brief apply modifer sm to all quad containers */
  void apply(const QuadModifier *sm) const;

  /** \brief apply derivative modifer sm to all quad containers

      @param[in]   sm the derivate modifier to be applied
      @param[out]  da derivative accumulator when applying sm
   */
  void apply(const QuadDerivativeModifier *sm,
             DerivativeAccumulator &da) const;

 /** \brief evaluates all quad containers using quad score

     @param[in]   s  quad score to evaluate each quad container
     @param[out]  da derivative accumulator when scoring each quad

     @return the sum of evaluation over all quad containers
  */
  double evaluate(const QuadScore *s,
                  DerivativeAccumulator *da) const;

 /** \brief evaluates all quad containers as long as below some maximal
            score threshold

     Evaluates all quad containers using quad score s
     until the specified maximal total evaluation score is breached,
     in order to save futile computation time.

     @param[in]   s   quad score for evaluating each quad
                      container
     @param[out]  da  derivative accumulator when scoring each quad
     @param[in]   max the maximal total evaluation score that is allowed

     @return the sum of evaluation at the end of evaluation, or right after
             the maximal value was first breached
  */
  double evaluate_if_good(const QuadScore *s,
                          DerivativeAccumulator *da,
                          double max) const;

  /** \brief apply template derivative modifer sm to all quad containers

      @param[in]   sm the template derivate modifier to be applied
      @param[out]  da derivative accumulator when applying sm
  */
  template <class SM>
    void template_apply(const SM *sm,
                        DerivativeAccumulator &da) const {
    for (unsigned int i=0; i< get_number_of_quad_containers(); ++i)
      {
        get_quad_container(i)->apply(sm, da);
      }
  }

  /** \brief apply template modifer sm to all quad containers */
  template <class SM>
    void template_apply(const SM *sm) const {
    for (unsigned int i=0; i< get_number_of_quad_containers(); ++i)
      {
        get_quad_container(i)->apply(sm);
      }
  }

  /** \brief evaluates all quad containers using template quad
             score s

      @param[in]   s  the template for scoring each quad container
      @param[out]  da derivative accumulator when scoring each quad

      @return the sum of evaluation over all quad containers
  */
  template <class SS>
    double template_evaluate(const SS *s,
                             DerivativeAccumulator *da) const {
    double ret=0;
    for (unsigned int i=0; i< get_number_of_quad_containers(); ++i)
      {
        ret+=get_quad_container(i)->evaluate(s, da);
      }
    return ret;
  }

 /** \brief evaluates all quad containers as long as below some maximal
            score threshold

     evaluates all quad containers using template quad score s,
     terminates if the specified maximal total evaluation score is breached
     in order to save futile computation time.

     @param[in]   s   the template for scoring each quad container
     @param[out]  da  derivative accumulator when scoring each quad
     @param[in]   max the maximal total evaluation score that is allowed

     @return the sum of evaluation at the end of the evaluation, or right after
             the maximum value was first breached
  */
  template <class SS>
    double template_evaluate_if_good(const SS *s,
                                 DerivativeAccumulator *da, double max) const {
    double ret=0;
    for (unsigned int i=0; i< get_number_of_quad_containers(); ++i)
      {
        double cur=
          get_quad_container(i)->evaluate_if_good(s, da, max);
        ret+=cur;
        max-=cur;
        if (max < 0) break;
      }
    return ret;
  }

  bool get_is_changed() const;
  ParticlesTemp get_all_possible_particles() const;
  IMP_OBJECT(QuadContainerSet);

  /** @name Methods to control the nested container

      This container merges a set of nested containers. To add
      or remove nested containers, use the methods below.
  */
  /**@{*/
  IMP_LIST_ACTION(public, QuadContainer, QuadContainers,
                  quad_container, quad_containers,
                  QuadContainer*, QuadContainers,
                  {
                    obj->set_was_used(true);
                    set_is_changed(true);
                    get_model()->reset_dependencies();
                  },{},
                  );
  /**@}*/
#ifndef IMP_DOXYGEN
  ParticleIndexQuads get_indexes() const;
  ParticleIndexQuads get_all_possible_indexes() const;
  ContainersTemp get_input_containers() const;
  void do_before_evaluate();
#endif
};


IMPCONTAINER_END_NAMESPACE

#endif  /* IMPCONTAINER_QUAD_CONTAINER_SET_H */
