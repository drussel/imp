/**
 *  \file AllPairContainer.h
 *  \brief Return all pairs from a SingletonContainer
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2011 IMP Inventors. All rights reserved.
 */

#ifndef IMPCONTAINER_ALL_PAIR_CONTAINER_H
#define IMPCONTAINER_ALL_PAIR_CONTAINER_H

#include "container_config.h"

#include <IMP/PairContainer.h>
#include <IMP/SingletonContainer.h>
#include <IMP/container/ListPairContainer.h>

IMPCONTAINER_BEGIN_NAMESPACE

//! Return all unordered pairs of particles taken from the SingletonContainer
/** Here is an example using this container to restrain all particles in a set
    to be within a a certain distance of one another.
    \verbinclude restrain_diameter.py

    \note Sequential access is much more efficient than random access which is
    suicidally slow for now. Complain if you want fast(er) random access.
    We might listen.

    \usesconstraint
 */
class IMPCONTAINEREXPORT AllPairContainer : public PairContainer
{
  IMP::internal::OwnerPointer<SingletonContainer> c_;
  mutable int a_, b_, i_;
  IMP_CONTAINER_DEPENDENCIES(AllPairContainer, ret.push_back(back_->c_););
  friend class AllBipartitePairContainer;
  AllPairContainer(SingletonContainer *c, bool);

  template <class F>
    void apply_to_contents(F f) const {
    unsigned int szc=c_->get_number_of_particles();
    for (unsigned int i=0; i< szc; ++i) {
      Particle *a= c_->get_particle(i);
      for (unsigned int j=0; j< i; ++j) {
        ParticlePair p(a, c_->get_particle(j));
        f(p);
      }
    }
  }
  template <class F>
    double accumulate_over_contents(F f) const {
    double ret=0;
    unsigned int szc=c_->get_number_of_particles();
    for (unsigned int i=0; i< szc; ++i) {
      Particle *a= c_->get_particle(i);
      for (unsigned int j=0; j< i; ++j) {
        ParticlePair p(a, c_->get_particle(j));
        ret+=f(p);
      }
    }
    return ret;
  }

public:
  //! Get the individual particles from the passed SingletonContainer
  AllPairContainer(SingletonContainer *c);

  static AllPairContainer *create_untracked_container(SingletonContainer *c) {
    AllPairContainer *lsc = new AllPairContainer(c, false);
    return lsc;
  }
#ifndef IMP_DOXYGEN
  bool get_is_up_to_date() const {
    return c_->get_is_up_to_date();
  }
#endif
  IMP_PAIR_CONTAINER(AllPairContainer);
};

IMP_OBJECTS(AllPairContainer,AllPairContainers);

IMPCONTAINER_END_NAMESPACE

#endif  /* IMPCONTAINER_ALL_PAIR_CONTAINER_H */
