/**
 *  \file TripletContainerSet.cpp
 *  \brief A set of TripletContainers.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 *
 */

#include "IMP/container/TripletContainerSet.h"
#include <algorithm>


IMPCONTAINER_BEGIN_NAMESPACE

TripletContainerSet
::TripletContainerSet(Model *m, std::string name):
  TripletContainer(m, name),
  deps_(new DependenciesScoreState(this), m){
}

namespace {
  Model *my_get_model(const TripletContainersTemp &in) {
    if (in.empty()) {
      IMP_THROW("Cannot initialize from empty list of containers.",
                IndexException);
    }
    return in[0]->get_model();
  }
}

TripletContainerSet
::TripletContainerSet(const TripletContainersTemp& in,
                        std::string name):
  TripletContainer(my_get_model(in), name),
  deps_(new DependenciesScoreState(this), my_get_model(in)){
  set_triplet_containers(in);
}


bool
TripletContainerSet
::get_contains_particle_triplet(const ParticleTriplet& vt) const {
  for (TripletContainerConstIterator it= triplet_containers_begin();
       it != triplet_containers_end(); ++it) {
    if ((*it)->get_contains_particle_triplet(vt)) return true;
  }
  return false;
}

void TripletContainerSet::do_show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << get_number_of_particle_triplets()
      << " containers" << std::endl;
}


ParticleIndexTriplets TripletContainerSet::get_indexes() const {
  ParticleIndexTriplets sum;
  for (TripletContainerConstIterator it= triplet_containers_begin();
       it != triplet_containers_end(); ++it) {
    ParticleIndexTriplets cur=(*it)->get_indexes();
    sum.insert(sum.end(), cur.begin(), cur.end());
  }
  return sum;
}

ParticleIndexTriplets TripletContainerSet::get_all_possible_indexes() const {
  ParticleIndexTriplets sum;
  for (TripletContainerConstIterator it= triplet_containers_begin();
       it != triplet_containers_end(); ++it) {
    ParticleIndexTriplets cur=(*it)->get_all_possible_indexes();
    sum.insert(sum.end(), cur.begin(), cur.end());
  }
  return sum;
}

IMP_LIST_IMPL(TripletContainerSet,
              TripletContainer,
              triplet_container,
              TripletContainer*,
              TripletContainers);


void TripletContainerSet::apply(const TripletModifier *sm) const {
  for (unsigned int i=0; i< get_number_of_triplet_containers(); ++i) {
    get_triplet_container(i)->apply(sm);
  }
}

void TripletContainerSet::apply(const TripletDerivativeModifier *sm,
                               DerivativeAccumulator &da) const {
  for (unsigned int i=0; i< get_number_of_triplet_containers(); ++i) {
    get_triplet_container(i)->apply(sm, da);
  }
}

double TripletContainerSet::evaluate(const TripletScore *s,
                                       DerivativeAccumulator *da) const {
  return template_evaluate(s, da);
}

double TripletContainerSet::evaluate_if_good(const TripletScore *s,
                                               DerivativeAccumulator *da,
                                               double max) const {
  return template_evaluate_if_good(s, da, max);
}


ParticlesTemp TripletContainerSet::get_contained_particles() const {
  ParticlesTemp ret;
  for (unsigned int i=0; i< get_number_of_triplet_containers(); ++i) {
    ParticlesTemp cur= get_triplet_container(i)->get_contained_particles();
    ret.insert(ret.end(), cur.begin(), cur.end());
  }
  return ret;
}

Restraints
TripletContainerSet::create_decomposition(TripletScore *ss) const {
  Restraints ret;
  for (unsigned int i=0; i< get_number_of_triplet_containers(); ++i) {
    Restraints cur=get_triplet_container(i)->create_decomposition(ss);
    ret.insert(ret.end(), cur.begin(), cur.end());
  }
  return ret;
}


IMPCONTAINER_END_NAMESPACE
