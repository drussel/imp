/**
 *  \file PredicateSingletonsRestraint.cpp   \brief Container for singleton.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2012 IMP Inventors. All rights reserved.
 *
 */

#include "IMP/container/PredicateSingletonsRestraint.h"

IMPCONTAINER_BEGIN_NAMESPACE

PredicateSingletonsRestraint
::PredicateSingletonsRestraint(SingletonPredicate *pred,
                               SingletonContainer *input,
                               std::string name):
  Restraint(input->get_model(), name),
  predicate_(pred), input_(input), updated_(false),
  error_on_unknown_(true){}

double
PredicateSingletonsRestraint
::unprotected_evaluate(DerivativeAccumulator *da) const {
  update_lists_if_necessary();
  double ret=0;
  for (unsigned int i=0; i< restraints_.size(); ++i) {
    ret+=restraints_[i]->unprotected_evaluate(da);
  }
  return ret;
}

ParticlesTemp PredicateSingletonsRestraint
::get_input_particles() const {
  // not correct, but correct is complicated
  return input_->get_contained_particles();
}
ContainersTemp PredicateSingletonsRestraint
::get_input_containers() const {
  // List containers don't do anything interesting
  return ContainersTemp(1, input_);
}

Restraints PredicateSingletonsRestraint
::do_create_current_decomposition() const {
  update_lists_if_necessary();
  return restraints_;
}

void PredicateSingletonsRestraint
::assign_pair(ParticleIndex index) const {
  int bin=predicate_->get_value_index(get_model(), index);
  if (containers_.find(bin) == containers_.end()) {
    if (unknown_container_) {
      unknown_container_->add_particle(index);
    } else if (error_on_unknown_) {
      IMP_THROW("Invalid predicate value of " << bin
                << " encounted for " << index,
                ValueException);
    }
  } else {
    containers_.find(bin)->second->add_particle(index);
  }
}
void PredicateSingletonsRestraint
::update_lists_if_necessary() const {
  if (updated_ && !input_->get_contents_changed()) return;
  updated_=true;
  if (unknown_container_) {
    unknown_container_->clear_particles();
  }
  for (Map::const_iterator it= containers_.begin();
       it != containers_.end(); ++it) {
    it->second->clear_particles();
  }
  IMP_FOREACH_SINGLETON_INDEX(input_, {
      assign_pair(_1);
    });
}

void PredicateSingletonsRestraint::do_show(std::ostream &) const {
}
IMPCONTAINER_END_NAMESPACE
