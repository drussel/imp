%include "IMP/algebra/algebra_macros.h"

%pythoncode %{
def get_vector(v):
   try:
      return v.get_coordinates()
   except:
      return v
def get_sphere(v):
   try:
      return v.get_sphere()
   except:
      return v
%}

IMP_SWIG_VALUE(IMP::algebra, Rotation2D, Rotation2Ds);
IMP_SWIG_VALUE(IMP::algebra, Rotation3D, Rotation3Ds);
IMP_SWIG_VALUE(IMP::algebra, Transformation2D, Transformation2Ds);
IMP_SWIG_VALUE(IMP::algebra, Transformation3D, Transformation3Ds);
IMP_SWIG_VALUE(IMP::algebra, SphericalVector3D, SphericalVector3Ds);
IMP_SWIG_VALUE(IMP::algebra, Triangle3D, Triangle3Ds);
IMP_SWIG_VALUE(IMP::algebra::grids, GridIndex3D, GridIndex3Ds);
IMP_SWIG_VALUE(IMP::algebra::grids, ExtendedGridIndex3D, ExtendedGridIndex3Ds);

IMP_SWIG_VALUE(IMP::algebra,  AxisAnglePair, AxisAnglePairs);
IMP_SWIG_VALUE(IMP::algebra,  Cone3D, Cone3Ds);
IMP_SWIG_VALUE(IMP::algebra,  Cylinder3D, Cylinder3Ds);
IMP_SWIG_VALUE(IMP::algebra,  Ellipsoid3D, Ellipsoid3Ds);
IMP_SWIG_VALUE(IMP::algebra,  Plane3D, Plane3Ds);
IMP_SWIG_VALUE(IMP::algebra,  Segment3D, Segment3Ds);
IMP_SWIG_VALUE(IMP::algebra,  SpherePatch3D, SpherePatch3Ds);

// we seem to need the non-typedefed name, at least for the first argument
IMP_SWIG_VALUE(IMP::algebra,  VectorD<2>, Vector2Ds);
IMP_SWIG_VALUE(IMP::algebra,  VectorD<3>, Vector3Ds);
IMP_SWIG_VALUE(IMP::algebra,  VectorD<4>, Vector4Ds);
IMP_SWIG_VALUE(IMP::algebra,  SphereD<2>, Sphere2Ds);
IMP_SWIG_VALUE(IMP::algebra,  SphereD<3>, Sphere3Ds);
IMP_SWIG_VALUE(IMP::algebra,  SphereD<4>, Sphere4Ds);
IMP_SWIG_VALUE(IMP::algebra,  BoundingBoxD<2>, BoundingBox2Ds);
IMP_SWIG_VALUE(IMP::algebra,  BoundingBoxD<3>, BoundingBox3Ds);
IMP_SWIG_VALUE(IMP::algebra,  BoundingBoxD<4>, BoundingBox4Ds);
IMP_SWIG_VALUE(IMP::algebra,  ReferenceFrame3D, ReferenceFrame3Ds);

namespace boost {
template <class T, int D> class multi_array{};

namespace multi_array_types {
  typedef size_t size_type;
  typedef size_t difference_type;
  struct index;
  struct index_range{};
  struct extent_range{};
  struct index_gen{};
  struct extent_gen{};
}
}

/* Wrap our own classes */
%include "IMP_vector.i"
%include "IMP_transformation2d.i"
%include "IMP_transformation3d.i"
%include "IMP/algebra/ReferenceFrame3D.h"
%include "IMP_bounding_box.i"
%include "IMP_matrix2d.i"
%include "IMP_matrix3d.i"
%include "IMP_spherical_coords.i"
%include "IMP/algebra/eigen_analysis.h"
%include "IMP/algebra/Segment3D.h"
%include "IMP/algebra/Triangle3D.h"
%include "IMP/algebra/LinearFit.h"
%include "IMP/algebra/ParabolicFit.h"
%include "IMP/algebra/Plane3D.h"
%include "IMP/algebra/Cylinder3D.h"
%include "IMP/algebra/Ellipsoid3D.h"
%include "IMP/algebra/SphereD.h"
%include "IMP/algebra/Sphere3D.h"
%include "IMP/algebra/Grid3D.h"
%include "IMP_GeometricHash.i"
namespace IMP {
 namespace algebra {
   %template(Sphere2D) SphereD<2>;
   %template(Sphere3D) SphereD<3>;
   %template(Sphere4D) SphereD<4>;
   %template(Sphere4Ds) ::std::vector< IMP::algebra::SphereD<4> >;
   %template(Sphere3Ds) ::std::vector< IMP::algebra::SphereD<3> >;
   %template(Sphere2Ds) ::std::vector< IMP::algebra::SphereD<2> >;
}
}

%include "IMP/algebra/SpherePatch3D.h"
%include "IMP/algebra/Cone3D.h"
%include "IMP/algebra/io.h"
%include "IMP/algebra/vector_generators.h"
%include "IMP/algebra/endian.h"
%include "IMP/algebra/Rotation2D.h"
%include "IMP/algebra/shortest_segment.h"
%include "IMP/algebra/vector_search.h"
%include "IMP/algebra/geometric_alignment.h"

namespace IMP {
 namespace algebra {
   %template(NearestNeighbor2D) NearestNeighborD<2>;
   %template(NearestNeighbor3D) NearestNeighborD<3>;
   %template(NearestNeighbor4D) NearestNeighborD<4>;
   %template(get_basis_vector_2d) get_basis_vector_d<2>;
   %template(get_basis_vector_3d) get_basis_vector_d<3>;
   %template(get_basis_vector_4d) get_basis_vector_d<4>;
   %template(get_zero_vector_2d) get_zero_vector_d<2>;
   %template(get_zero_vector_3d) get_zero_vector_d<3>;
   %template(get_zero_vector_4d) get_zero_vector_d<4>;
   %template(get_ones_vector_2d) get_ones_vector_d<2>;
   %template(get_ones_vector_3d) get_ones_vector_d<3>;
   %template(get_ones_vector_4d) get_ones_vector_d<4>;
   %template(get_unit_bounding_box_2d) get_unit_bounding_box_d<2>;
   %template(get_unit_bounding_box_3d) get_unit_bounding_box_d<3>;
   %template(get_unit_bounding_box_4d) get_unit_bounding_box_d<4>;
   namespace grids {
   %template(_SparseIntStorage) SparseGridStorage3D<int, BoundedGridStorage3D>;
   %template(_SparseUBIntStorage) grids::SparseGridStorage3D<int, UnboundedGridStorage3D>;
   %template(_DenseDoubleStorage) DenseGridStorage3D<double>;
   %template(_DenseFloatStorage) DenseGridStorage3D<float>;
   %template(SparseIntGrid3D) Grid3D<int, SparseGridStorage3D<int, BoundedGridStorage3D> >;
   %template(SparseUnboundedIntGrid3D) Grid3D<int, SparseGridStorage3D<int, UnboundedGridStorage3D> >;
   %template(DenseDoubleGrid3D) Grid3D<double, DenseGridStorage3D<double> >;
   %template(DenseFloatGrid3D) Grid3D<float, DenseGridStorage3D<float> >;
   }

   // for debugging
   //%template(SpherePair3D) ::std::pair<IMP::algebra::SphereD<3>,IMP::algebra::SphereD<3> >;
   //%template(SpherePair3Ds) ::std::vector< ::std::pair<IMP::algebra::SphereD<3>,IMP::algebra::SphereD<3> > >;

   %template(AxisAnglePair) ::std::pair<IMP::algebra::VectorD<3>,double>;
   %template(get_transformation_aligning_first_to_second) get_transformation_aligning_first_to_second<std::vector<IMP::algebra::VectorD<3> >, std::vector<IMP::algebra::VectorD<3> > >;
   // rotation operations

   IMP_SWIG_VALUES(ReferenceFrame3D, ReferenceFrame3Ds);
 }
}
%inline %{
namespace IMP {
namespace algebra {

SphereD<2> get_unit_sphere_2d() { return SphereD<2>(get_zero_vector_d<2>(), 1);}
SphereD<3> get_unit_sphere_3d() { return SphereD<3>(get_zero_vector_d<3>(), 1);}
SphereD<4> get_unit_sphere_4d() { return SphereD<4>(get_zero_vector_d<4>(), 1);}
// swig doesn't instantiate them properly
bool get_interiors_intersect(const SphereD<2>&a, const SphereD<2> &b) {
   return get_interiors_intersect<2>(a,b);
}
bool get_interiors_intersect(const SphereD<3>&a, const SphereD<3> &b) {
   return get_interiors_intersect<3>(a,b);
}
bool get_interiors_intersect(const SphereD<4>&a, const SphereD<4> &b) {
   return get_interiors_intersect<4>(a,b);
}
double get_distance(const SphereD<2>&a, const SphereD<2> &b) {
   return get_distance<2>(a,b);
}
double get_distance(const SphereD<3>&a, const SphereD<3> &b) {
   return get_distance<3>(a,b);
}
double get_distance(const SphereD<4>&a, const SphereD<4> &b) {
   return get_distance<4>(a,b);
}

VectorD<2> get_random_vector_on(const SphereD<2> &s) {
 return get_random_vector_on<2>(s);
}
VectorD<2> get_random_vector_on(const BoundingBoxD<2> &s) {
  return get_random_vector_on<2>(s);
}
VectorD<3> get_random_vector_on(const SphereD<3> &s) {
  return get_random_vector_on<3>(s);
}
VectorD<3> get_random_vector_on(const BoundingBoxD<3> &s) {
  return get_random_vector_on<3>(s);
}
bool get_interiors_intersect(const BoundingBoxD<3>&a,
                             const BoundingBoxD<3> &b) {
   return get_interiors_intersect<3>(a,b);
}

VectorD<4> get_random_vector_on(const SphereD<4> &s) {
  return get_random_vector_on<4>(s);
}
VectorD<4> get_random_vector_on(const BoundingBoxD<4> &s) {
  return get_random_vector_on<4>(s);
}

VectorD<2> get_random_vector_in(const SphereD<2> &s) {
  return get_random_vector_in<2>(s);
}
VectorD<2> get_random_vector_in(const BoundingBoxD<2> &s) {
  return get_random_vector_in<2>(s);
}
VectorD<3> get_random_vector_in(const SphereD<3> &s) {
  return get_random_vector_in<3>(s);
}
VectorD<3> get_random_vector_in(const BoundingBoxD<3> &s) {
  return get_random_vector_in<3>(s);
}
VectorD<4> get_random_vector_in(const SphereD<4> &s) {
  return get_random_vector_in<4>(s);
}
VectorD<4> get_random_vector_in(const BoundingBoxD<4> &s) {
  return get_random_vector_in<4>(s);
}

std::vector<VectorD<2> > get_uniform_surface_cover(const SphereD<2> &s, unsigned int n) {
  return get_uniform_surface_cover<2>(s,n);
}
std::vector<VectorD<3> > get_uniform_surface_cover(const SphereD<3> &s, unsigned int n) {
  return get_uniform_surface_cover<3>(s,n);
}
std::vector<VectorD<4> > get_uniform_surface_cover(const SphereD<4> &s, unsigned int n) {
  return get_uniform_surface_cover<4>(s,n);
}

BoundingBoxD<2> get_bounding_box(const SphereD<2> &s) {
  return get_bounding_box<2>(s);
}
BoundingBoxD<3> get_bounding_box(const SphereD<3> &s) {
  return get_bounding_box<3>(s);
}
BoundingBoxD<4> get_bounding_box(const SphereD<4> &s) {
  return get_bounding_box<4>(s);
}
}
}
%}
