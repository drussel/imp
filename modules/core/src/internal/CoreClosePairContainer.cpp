/**
 *  \file ClosePairContainer.cpp   \brief A list of ParticlePairs.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2010 IMP Inventors. Close rights reserved.
 *
 */

#include "IMP/core/internal/CoreClosePairContainer.h"
#include <IMP/core/internal/DifferenceSingletonContainer.h>
#include <IMP/core/BoxSweepClosePairsFinder.h>
#include <IMP/core/GridClosePairsFinder.h>
#include <IMP/core/internal/CoreListPairContainer.h>
#include <IMP/core/internal/pair_helpers.h>
#include <IMP/core/internal/close_pairs_helpers.h>
#include <IMP/algebra/internal/tnt_array2d.h>
#include <IMP/PairModifier.h>
#include <algorithm>


IMPCORE_BEGIN_INTERNAL_NAMESPACE

IMP_LIST_IMPL(CoreClosePairContainer,
              PairFilter,
              pair_filter,
              PairFilter*,
              PairFilters, obj->set_was_used(true);,{},{});


CoreClosePairContainer::CoreClosePairContainer(SingletonContainer *c,
                                                 double distance,
                                                 ClosePairsFinder *cpf,
                                       double slack):
  internal::ListLikePairContainer(c->get_model(), "ClosePairContainer"),
  is_static_(false) {
 initialize(c, distance, slack,
             cpf);
}

CoreClosePairContainer::~CoreClosePairContainer()
{
}

void CoreClosePairContainer::initialize(SingletonContainer *c, double distance,
                                         double slack,
                                         ClosePairsFinder *cpf) {
  initialize_active_container(get_model());
  slack_=slack;
  distance_=distance;
  c_=c;
  cpf_=cpf;
  cpf_->set_distance(distance_+2*slack_);
  first_call_=true;
  moved_=cpf_->get_moved_singleton_container(c_, get_model(), slack_);
}

IMP_ACTIVE_CONTAINER_DEF(CoreClosePairContainer);


void CoreClosePairContainer::set_slack(double s) {
  slack_=s;
  cpf_->set_distance(distance_+2*slack_);
  ParticlePairsTemp et;
  update_list(et);
  first_call_=true;
}

void CoreClosePairContainer::set_is_static(bool t,
                                           const algebra::BoundingBox3Ds &bbs) {
  if (t&& !is_static_) {
    ParticlesTemp pt= c_->get_particles();
    // we don't want the slack any more
    cpf_->set_distance(distance_);
    IntPairs ips= cpf_->get_close_pairs(bbs);
    cpf_->set_distance(distance_+2*slack_);
    ParticlePairsTemp val(ips.size());
    for (unsigned int i=0; i< ips.size(); ++i) {
      val[i]= ParticlePair(pt[ips[i].first], pt[ips[i].second]);
    }
    update_list(val);
  }
  if (t != is_static_) {
    // reset dependency graph
    ticker_.reset();
    ticker_.set(new Ticker(this), get_model());
  }
  is_static_=t;

}

ContainersTemp CoreClosePairContainer
::get_state_input_containers() const {
  if (is_static_) return ContainersTemp();
  ContainersTemp ret= cpf_->get_input_containers(c_->get_particles());
  ret.push_back(c_);
  ret.push_back(moved_);
  return ret;
}


ParticlesTemp CoreClosePairContainer::get_state_input_particles() const {
  if (is_static_) return ParticlesTemp();
  ParticlesTemp ret(cpf_->get_input_particles(c_->get_particles()));
  if (get_number_of_pair_filters() >0) {
    ParticlePairsTemp all_pairs;
    for (unsigned int i=0; i< ret.size(); ++i) {
      for (unsigned int j=0; j< i; ++j) {
        all_pairs.push_back(ParticlePair(ret[i], ret[j]));
      }
    }
    for (PairFilterConstIterator it= pair_filters_begin();
         it != pair_filters_end(); ++it) {
      for (unsigned int i=0; i< all_pairs.size(); ++i) {
        ParticlesTemp cur= (*it)->get_input_particles(all_pairs[i]);
      ret.insert(ret.end(), cur.begin(), cur.end());
      }
    }
  }
  return ret;
}


void CoreClosePairContainer::do_before_evaluate() {
  IMP_OBJECT_LOG;
  IMP_CHECK_OBJECT(c_);
  IMP_CHECK_OBJECT(cpf_);
  IMP_INTERNAL_CHECK(c_->get_is_up_to_date(),
                     "Input container is not up to date.");
  if (is_static_) return;
  try {
    if (first_call_) {
      IMP_LOG(TERSE, "Handling first call of ClosePairContainer." << std::endl);
      ParticlePairsTemp c= cpf_->get_close_pairs(c_->get_particles());
      internal::filter_close_pairs(this, c);
      moved_->reset();
      IMP_LOG(TERSE, "Found " << c.size() << " pairs." << std::endl);
      update_list(c);
      first_call_=false;
    } else {
      IMP_INTERNAL_CHECK(moved_->get_is_up_to_date(),
                         "Moved container is not up to date.");
      if (moved_->get_number_of_particles() != 0) {
        if (moved_->get_particles().size() < c_->get_number_of_particles()*.1) {
          IMP_LOG(TERSE, "Handling incremental update of ClosePairContainer."
                  << std::endl);
          ParticlePairsTemp ret= cpf_->get_close_pairs(c_->get_particles(),
                                                       moved_->get_particles());
          internal::filter_close_pairs(this, ret);
          internal::filter_same(ret);
          IMP_LOG(TERSE, "Found " << ret.size() << " pairs." << std::endl);
          add_to_list(ret);
          moved_->reset_moved();
        } else {
          IMP_LOG(TERSE, "Handling full update of ClosePairContainer."
                  << std::endl);
          ParticlePairsTemp ret= cpf_->get_close_pairs(c_->get_particles());
          internal::filter_close_pairs(this, ret);
          IMP_LOG(TERSE, "Found " << ret.size() << " pairs." << std::endl);
          update_list(ret);
          moved_->reset();
        }
      } else {

        IMP_LOG(TERSE, "No particles moved more than " << slack_ << std::endl);
      }
    }
  } catch (std::bad_alloc&) {
    IMP_THROW("Ran out of memory when computing close pairs."
              << " Try to reduce the "
              << "slack or reformulate the problem.", ValueException);
  }
  IMP_IF_CHECK(USAGE_AND_INTERNAL) {
    std::set<ParticlePair> existings(particle_pairs_begin(),
                                     particle_pairs_end());
    std::cout << existings.size() << std::endl;
    for (unsigned int i=0; i< c_->get_number_of_particles(); ++i) {
      for (unsigned int j=0; j< i; ++j) {
        XYZR a(c_->get_particle(i)), b(c_->get_particle(j));
        double d= get_distance(a,b);
        if (d < distance_-.1) {
          if (RigidMember::particle_is_instance(a)
              && RigidMember::particle_is_instance(b)
              && RigidMember(a).get_rigid_body()
              == RigidMember(b).get_rigid_body())
            continue;
          ParticlePair pp(a,b);
          ParticlePairsTemp pps(1, pp);
          internal::filter_close_pairs(this, pps);
          IMP_INTERNAL_CHECK(pps.empty()
                             || existings.find(pp) != existings.end()
                             || existings.find(ParticlePair(pp[1], pp[0]))
                             != existings.end(), "Particle pair "
                             << a->get_name()
                             << " and " << b->get_name()
                             << " not found in list: "
                             << *pp[0] << std::endl
                             << *pp[1]);
        }
      }
    }
  }
}


void CoreClosePairContainer::do_after_evaluate() {
  internal::ListLikePairContainer::do_after_evaluate();
}


void CoreClosePairContainer::do_show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << "container " << *c_ << std::endl;
}


ParticlesTemp CoreClosePairContainer::get_contained_particles() const {
  ParticlesTemp ret= c_->get_contained_particles();
  ParticlesTemp nret =cpf_->get_input_particles(c_->get_particles());
  ret.insert(ret.end(), nret.begin(), nret.end());
  return ret;
}

bool CoreClosePairContainer::get_contained_particles_changed() const {
  return c_->get_contained_particles_changed();
}

IMPCORE_END_INTERNAL_NAMESPACE
