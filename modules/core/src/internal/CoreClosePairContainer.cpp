/**
 *  \file ClosePairContainer.cpp   \brief A list of ParticlePairs.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2010 IMP Inventors. Close rights reserved.
 *
 */

#include "IMP/core/internal/CoreClosePairContainer.h"
#include <IMP/core/internal/DifferenceSingletonContainer.h>
#include <IMP/core/BoxSweepClosePairsFinder.h>
#include <IMP/core/GridClosePairsFinder.h>
#include <IMP/core/internal/CoreListPairContainer.h>
#include <IMP/core/internal/pair_helpers.h>
#include <IMP/core/internal/close_pairs_helpers.h>
#include <IMP/algebra/internal/tnt_array2d.h>
#include <IMP/PairModifier.h>
#include <algorithm>


IMPCORE_BEGIN_INTERNAL_NAMESPACE

IntKey InList::key_= IntKey("in list temp");

IMP_LIST_IMPL(CoreClosePairContainer,
              PairFilter,
              pair_filter,
              PairFilter*,
              PairFilters, obj->set_was_used(true);first_call_=true;,
              {first_call_=true;},
              {if (container) container->first_call_=true;});


CoreClosePairContainer::CoreClosePairContainer(SingletonContainer *c,
                                                 double distance,
                                                 ClosePairsFinder *cpf,
                                       double slack):
  internal::ListLikePairContainer(c->get_model(), "ClosePairContainer") {
 initialize(c, distance, slack,
             cpf);
}

CoreClosePairContainer::~CoreClosePairContainer()
{
}

void CoreClosePairContainer::initialize(SingletonContainer *c, double distance,
                                         double slack,
                                         ClosePairsFinder *cpf) {
  initialize_active_container(get_model());
  slack_=slack;
  distance_=distance;
  c_=c;
  cpf_=cpf;
  cpf_->set_distance(distance_+2*slack_);
  first_call_=true;
  moved_=cpf_->get_moved_singleton_container(c_, get_model(), slack_);
}

IMP_ACTIVE_CONTAINER_DEF(CoreClosePairContainer);


void CoreClosePairContainer::set_slack(double s) {
  slack_=s;
  cpf_->set_distance(distance_+2*slack_);
  ParticlePairsTemp et;
  update_list(et);
  first_call_=true;
}


ContainersTemp CoreClosePairContainer
::get_state_input_containers() const {
  ContainersTemp ret= cpf_->get_input_containers(c_->get_particles());
  ret.push_back(c_);
  ret.push_back(moved_);
  return ret;
}


ParticlesTemp CoreClosePairContainer::get_state_input_particles() const {
  ParticlesTemp ret(cpf_->get_input_particles(c_->get_particles()));
  if (get_number_of_pair_filters() >0) {
    ParticlesTemp retc;
    for (PairFilterConstIterator it= pair_filters_begin();
         it != pair_filters_end(); ++it) {
      for (unsigned int i=0; i< ret.size(); ++i) {
        ParticlesTemp cur= (*it)->get_input_particles(ret[i]);
        retc.insert(retc.end(), cur.begin(), cur.end());
      }
    }
    ret.insert(ret.end(), retc.begin(), retc.end());
  }
  return ret;
}


namespace {
  struct Found {
    ParticlesTemp ps_;
    Found(const ParticlesTemp &ps): ps_(ps){
      std::sort(ps_.begin(), ps_.end());
    }
    bool operator()(const ParticlePair &pp) const {
      if (std::binary_search(ps_.begin(), ps_.end(), pp[0])
          || std::binary_search(ps_.begin(), ps_.end(), pp[1])) {
        return true;
      } else {
        return false;
      }
    }
  };
}

void CoreClosePairContainer::do_before_evaluate() {
  IMP_OBJECT_LOG;
  IMP_CHECK_OBJECT(c_);
  IMP_CHECK_OBJECT(cpf_);
  IMP_INTERNAL_CHECK(c_->get_is_up_to_date(),
                     "Input container is not up to date.");
  try {
    if (first_call_) {
      IMP_LOG(TERSE, "Handling first call of ClosePairContainer." << std::endl);
      ParticlePairsTemp c= cpf_->get_close_pairs(c_->get_particles());
      IMP_IF_CHECK(USAGE_AND_INTERNAL) {
        ParticlesTemp ps= c_->get_particles();
        std::sort(ps.begin(), ps.end());
        IMP_USAGE_CHECK(std::unique(ps.begin(), ps.end())==ps.end(),
                        "Duplicates in input");
        for (unsigned int i=0; i< c.size(); ++i) {
          IMP_INTERNAL_CHECK(c[i][0] != c[i][1],
                             "Homo pair found");
        }
      }
      internal::filter_close_pairs(this, c);
      moved_->reset();
      IMP_LOG(TERSE, "Found " << c.size() << " pairs." << std::endl);
      update_list(c);
      first_call_=false;
    } else {
      IMP_INTERNAL_CHECK(moved_->get_is_up_to_date(),
                         "Moved container is not up to date.");
      if (moved_->get_number_of_particles() != 0) {
        if (moved_->get_particles().size() < c_->get_number_of_particles()*.2) {
          IMP_LOG(TERSE, "Handling incremental update of ClosePairContainer."
                  << std::endl);
          ParticlesTemp moved=moved_->get_particles();
          ParticlePairsTemp ret= cpf_->get_close_pairs(c_->get_particles(),
                                                       moved);
          // make one pass
          internal::filter_close_pairs(this, ret);
          if (false) {
            internal::filter_same(ret, moved_->get_particles());
            //internal::filter_far(ret, get_distance());
            remove_from_list_if(Found(moved_->get_particles()));
            IMP_LOG(TERSE, "Found " << ret.size() << " pairs." << std::endl);
            add_to_list(ret);
          } else {
            internal::filter_same(ret);
            previous_moved_.insert(previous_moved_.end(),
                                   moved.begin(), moved.end());
            if (previous_moved_.size() > .2 *c_->get_number_of_particles()) {
              /*InList il= InList::create(moved);
              remove_from_list_if(il);
              InList::destroy(il);*/
              remove_from_list_if(FarParticle(distance_+2*slack_));
              previous_moved_.clear();
            }
            IMP_LOG(TERSE, "Found " << ret.size() << " pairs." << std::endl);
            add_unordered_to_list(ret);
          }
          moved_->reset_moved();
          IMP_LOG(TERSE, "Count is now "
                  << std::distance(particle_pairs_begin(),
                                   particle_pairs_end()) << std::endl);
        } else {
          IMP_LOG(TERSE, "Handling full update of ClosePairContainer."
                  << std::endl);
          ParticlePairsTemp ret= cpf_->get_close_pairs(c_->get_particles());
          internal::filter_close_pairs(this, ret);
          IMP_LOG(TERSE, "Found " << ret.size() << " pairs." << std::endl);
          update_list(ret);
          moved_->reset();
        }
      } else {
        IMP_LOG(TERSE, "No particles moved more than " << slack_ << std::endl);
      }
    }
  } catch (std::bad_alloc&) {
    IMP_THROW("Ran out of memory when computing close pairs."
              << " Try to reduce the "
              << "slack or reformulate the problem.", ValueException);
  }
  IMP_IF_CHECK(USAGE_AND_INTERNAL) {
    IMP::internal::Set<ParticlePair> existings(particle_pairs_begin(),
                                     particle_pairs_end());
    unsigned int num= std::distance(particle_pairs_begin(),
                                    particle_pairs_end());
    if(0) std::cout << num;
    for (ParticlePairIterator it=particle_pairs_begin();
         it != particle_pairs_end(); ++it) {
      for (unsigned int i=0; i< get_number_of_pair_filters(); ++i) {
        IMP_INTERNAL_CHECK(!get_pair_filter(i)->get_contains_particle_pair(*it),
                           "Pair " << *it
                           << " should have been filtered by filter "
                           << get_pair_filter(i)->get_name());
        IMP_INTERNAL_CHECK(!get_pair_filter(i)
                           ->get_contains_particle_pair(ParticlePair((*it)[0],
                                                                     (*it)[1])),
                           "Filter is not symmetric on pair " << *it
                           << get_pair_filter(i)->get_name());
      }
      IMP_INTERNAL_CHECK(existings.find(ParticlePair((*it)[1], (*it)[0]))
                         == existings.end(),
                         "Can't have both a pair and its reverse in the list"
                         << *it);
    }
    IMP_INTERNAL_CHECK(existings.size() == num,
                       "Not all particle pairs in list are unique: "
                       << num
                       << " vs " << existings.size() << std::endl);
    for (unsigned int i=0; i< c_->get_number_of_particles(); ++i) {
      for (unsigned int j=0; j< i; ++j) {
        XYZR a(c_->get_particle(i)), b(c_->get_particle(j));
        double d= core::get_distance(a,b);
        if (d < distance_-.1) {
          if (RigidMember::particle_is_instance(a)
              && RigidMember::particle_is_instance(b)
              && RigidMember(a).get_rigid_body()
              == RigidMember(b).get_rigid_body())
            continue;
          ParticlePair pp(a,b);
          ParticlePairsTemp pps(1, pp);
          internal::filter_close_pairs(this, pps);
          IMP_INTERNAL_CHECK(pps.empty()
                             || existings.find(pp) != existings.end()
                             || existings.find(ParticlePair(pp[1], pp[0]))
                             != existings.end(), "Particle pair "
                             << a->get_name()
                             << " and " << b->get_name()
                             << " not found in list: "
                             << *pp[0] << std::endl
                             << *pp[1]);
        }
      }
    }
  }
}


void CoreClosePairContainer::do_after_evaluate() {
  internal::ListLikePairContainer::do_after_evaluate();
}


void CoreClosePairContainer::do_show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << "container " << *c_ << std::endl;
}


ParticlesTemp CoreClosePairContainer::get_contained_particles() const {
  ParticlesTemp ret= c_->get_contained_particles();
  ParticlesTemp nret =cpf_->get_input_particles(c_->get_particles());
  ret.insert(ret.end(), nret.begin(), nret.end());
  return ret;
}

bool CoreClosePairContainer::get_contained_particles_changed() const {
  return c_->get_contained_particles_changed();
}

IMPCORE_END_INTERNAL_NAMESPACE
