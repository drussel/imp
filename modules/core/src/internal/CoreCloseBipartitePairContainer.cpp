/**
 *  \file CloseBipartitePairContainer.cpp   \brief A list of ParticlePairs.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-2011 IMP Inventors. Close rights reserved.
 *
 */

#include "IMP/core/internal/CoreCloseBipartitePairContainer.h"
#include <IMP/core/BoxSweepClosePairsFinder.h>
#include <IMP/core/GridClosePairsFinder.h>
#include <IMP/container/ListPairContainer.h>
#include <IMP/core/internal/pair_helpers.h>
#include <IMP/core/internal/close_pairs_helpers.h>
#include <IMP/PairModifier.h>
#include <algorithm>


IMPCORE_BEGIN_INTERNAL_NAMESPACE

IMP_LIST_IMPL(CoreCloseBipartitePairContainer,
              PairFilter,
              pair_filter,
              PairFilter*,
              PairFilters);


CoreCloseBipartitePairContainer
::CoreCloseBipartitePairContainer(SingletonContainer *a,
                              SingletonContainer *b,
                              double distance,
                              double slack):
  P(a->get_model(), "CoreCloseBipartitePairContainer") {
  std::ostringstream oss;
  oss << "BCPC " << get_name() << " hierarchy " << this;
  ObjectKey key=ObjectKey(oss.str());
  initialize(a,b, -1, -1, distance, slack, key);
}

CoreCloseBipartitePairContainer
::CoreCloseBipartitePairContainer(SingletonContainer *a,
                                  SingletonContainer *b,
                                  ParticleIndex cover_a,
                                  ParticleIndex cover_b,
                                  ObjectKey key,
                                  double distance,
                                  double slack):
  P(a->get_model(), "CoreCloseBipartitePairContainer") {
  initialize(a,b, cover_a, cover_b, distance, slack, key);
}

void CoreCloseBipartitePairContainer::initialize(SingletonContainer *a,
                                                 SingletonContainer *b,
                                                 ParticleIndex cover_a,
                                                 ParticleIndex cover_b,
                                                 double distance,
                                                 double slack,
                                                 ObjectKey key) {
  initialize_active_container(get_model());
  slack_=slack;
  distance_=distance;
  key_=key;
  sc_[0]=a;
  sc_[1]=b;
  were_close_=false;
  covers_[0]=cover_a;
  covers_[1]=cover_b;
  for (unsigned int i=0; i< 2; ++i) {
    internal::initialize_particles(sc_[i], key_,
                                   xyzrs_[i],
                                   rbs_[i], constituents_,
                                   rbs_backup_[i], xyzrs_backup_[i]);
  }
}

IMP_ACTIVE_CONTAINER_DEF(CoreCloseBipartitePairContainer, {
  });

ParticlesTemp CoreCloseBipartitePairContainer
::get_state_input_particles() const {
  ParticlesTemp ret= internal::get_input_particles(get_model(),
                                                   sc_[0],
                                                   access_pair_filters(),
                                                   xyzrs_[0], rbs_[0],
                                                   constituents_);
  ParticlesTemp ret1= internal::get_input_particles(get_model(), sc_[1],
                                                    access_pair_filters(),
                                                   xyzrs_[1], rbs_[1],
                                                   constituents_);
  ret.insert(ret.end(), ret1.begin(), ret1.end());
  return ret;
}

ContainersTemp CoreCloseBipartitePairContainer
::get_state_input_containers() const {
  ContainersTemp ret(sc_, sc_+2);
  return ret;
}

void CoreCloseBipartitePairContainer::do_before_evaluate() {
  IMP_OBJECT_LOG;
  core::internal::ListLikePairContainer::do_before_evaluate();
  // ignore covers for now
  if (true) {
    if (were_close_ && !internal::get_if_moved(get_model(), slack_,
                                               xyzrs_[0], rbs_[0],
                                               constituents_,
                                               rbs_backup_[0], xyzrs_backup_[0])
      && !internal::get_if_moved(get_model(), slack_,
                                 xyzrs_[1], rbs_[1], constituents_,
                                 rbs_backup_[1], xyzrs_backup_[1])){
      // all ok
    } else {
      // rebuild
      internal::reset_moved(get_model(),
                            xyzrs_[0], rbs_[0], constituents_,
                            rbs_backup_[0], xyzrs_backup_[0]);
      internal::reset_moved(get_model(),
                            xyzrs_[1], rbs_[1], constituents_,
                            rbs_backup_[1], xyzrs_backup_[1]);
      ParticleIndexPairs pips;
      internal::fill_list(get_model(), access_pair_filters(),
                          key_, slack_+2*distance_, xyzrs_, rbs_,
                          constituents_, pips);
      update_list(pips);
    }
  } else {
    ParticleIndexPairs none;
    update_list(none);
  }
}


void CoreCloseBipartitePairContainer::do_after_evaluate() {
  core::internal::ListLikePairContainer::do_after_evaluate();
}


void CoreCloseBipartitePairContainer::do_show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << "container "
      << sc_[0]->get_name() << " and " << sc_[1]->get_name() << std::endl;
}


ParticlesTemp CoreCloseBipartitePairContainer::get_contained_particles() const {
  ParticlesTemp ret = sc_[0]->get_particles();
  ParticlesTemp ret1= sc_[1]->get_particles();
  ret.insert(ret.end(), ret1.begin(), ret1.end());
  return ret;
}

ParticleIndexPairs
CoreCloseBipartitePairContainer::get_all_possible_indexes() const {
  ParticleIndexes pis= sc_[0]->get_all_possible_indexes();
  ParticleIndexes pjs= sc_[0]->get_all_possible_indexes();
  ParticleIndexPairs ret; ret.resize(pis.size()*pjs.size());
  for (unsigned int i=0; i< pis.size(); ++i) {
    for (unsigned int j=0; j< pjs.size(); ++j) {
      ret.push_back(ParticleIndexPair(pis[i], pjs[j]));
    }
  }
  return ret;
}

IMPCORE_END_INTERNAL_NAMESPACE
