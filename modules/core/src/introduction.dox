/**
\page introduction An Introduction to IMP


\section i0 Architecture
 
  - Representation: IMP::Particle objects store data
  - Scoring:
    - \ref restraint "General purpose restraints" are components for assembling general restraints. 
    - \ref exp_restraint "Experimental restraints" are restraints that directly incorporate experimental data.
    - IMP::ScoreState objects compute shared structure and invariants
    - IMP::SingletonScore, IMP::PairScore and IMP::TripletScore objects evaluate a score on a set of particles
  - IMP::Optimizer object optimize the Particles with respect to the Restraints


  - The IMP::Model ties everything together





\section i5 Other important bits
There is good \ref log "logging support":
\code
IMP::set_log_level(IMP.VERBOSE);
IMP_LOG(TERSE, "Something interesting has occurred with variable " 
                 << var << std::endl);
\endcode

\ref assert "Error reporting/checking" which can be controlled at runtime
\code
IMP::set_check_level(IMP.EXPENSIVE);
IMP_check(boolean_condition, "An error has occurred with value "
                             << some_value,
                             ExceptionType);
\endcode

The control functions are accessible from Python, but the check and log macros are not.

Saving state
\verbatim
IMP.core.write(my_imp_model, "somefile")
IMP.core.read("somefile", my_imp_model)
\endverbatim

\verbatim
IMP::core::write(my_imp_model, "somefile");
IMP::core::read("somefile", my_imp_model);
\endverbatim



\section i6 Examples
The following examples all are in python and C++ The following code is ommitted from the examples:
\verbatim
import IMP
import IMP.core
m= IMP.Model()
ps= IMP.core.SingletonContainer()
for i in range(0,100)
    p= IMP.Particle()
    m.add_particle(p)
    d= IMP.core.XYZDecorator.create(p)
    d.set_coordinates_are_optimized(True)
    d.set_coordinates(IMP.random_vector_in_box())
    d.set_radius(1.0)
    ps.add_particle(p)
\endverbatim

\code
#include <IMP.h>
#include <IMP/core.h>

IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::core::SingletonContainer ps;
for (int i=0; i< 100; ++i) {
    IMP::Particle* p=new IMP::Particle();
    ps->add_particle(p);
    m->add_particles(p);
    IMP::core::XYZRDecorator d= IMP::core::XYZRDecorator::create(p);
    d.set_coordinates_are_optimized(true);
    d.set_coordinates(IMP::random_vector_in_box());
    d.set_radius(1.0);
}

\endcode





\section i7 Restraint some distances

Restrain the distance between the first two particles.

\verbatim
uf= IMP.core.Harmonic(0,1)
df= IMP.core.SphereDistancePairScore(uf)
r= IMP.core.PairsRestraint(df, ps.get_particle(0), ps.get_particle(1))
m.add_restraint(r)
\endverbatim


\code
IMP::core::Harmonic *uf= new IMP::core::Harmonic(0,1);
IMP::core::SphereDistancePairScore *df= new IMP::core::SphereDistancePairScore(uf);
IMP::core::PairRestraint* r= new IMP::core::PairRestraint(df, ps->get_particle(0), ps->get_particle(1));
m->add_restraint(r);
\endcode



\section i8 Preventing collisions
The ClosePairsScoreState maintains a list of all pairs of particles which contains all pairs closer than min distance (between the spheres). The HarmonicLowerBound forces the spheres apart.
\verbatim
nbl= IMP.core.ClosePairsScoreState(ps)
nbl.set_distance(min_distance)
m.add_score_state(nbl)
h= IMP.core.HarmonicLowerBound(0,min_distance)
sd= IMP.core.SphereDistancePairScore(h)
nbr= IMP.core.PairsRestraint(sd, nbl.get_close_pairs_container())
m.add_restraint(nbr)
\endverbatim

\code
IMP::core::ClosePairsScoreState *nbl= new IMP::core::ClosePairsScoreState(ps);
nbl->set_distance(min_distance)
m->add_score_state(nbl);
IMP::core::HarmonicLowerBound* h= new IMP::core::HarmonicLowerBound(0,1);
IMP::core::SphereDistancePairScore *sd= new IMP::core::SphereDistancePairScore(h);
IMP::core::SingletonsRestraint* nbr= new IMP::core::SingletonsRestraint(sd, nbl->get_close_pairs_container());
m->add_restraint(nbr);
\endcode







\section i9 Restraining bonds

Load a protein and restrain all the bonds to have the correct length. Bond angles is a bit trickier at the moment.

\verbatim
prot= IMP.modeller.read_pdb("some.pdb")
bds= IMP.core.get_internal_bonds(prot)
bl= IMP.core.BondDecoratorSingletonContainer(bds)
h= IMP.core.Harmonic(0,1)
bs= IMP.core.BondDecoratorSingletonScore(h)
br= IMP.core.SingletonsRestraint(bs, bl)
m.add_restraint(br)
\endverbatim

\code
// Currently you can't read a pdb from C++
IMP::core::MolecularHierarchyDecorator prot=???;
IMP::core::BondDecorators bds= IMP::core::get_internal_bonds(prot);
IMP::core::BondDecoratorSingletonContainer *bl= new IMP::core::BondDecoratorSingletonContainer(bds);
IMP::core::Harmonic *h= new IMP::core::Harmonic(0,1);
IMP::core::BondDecoratorSingletonScore* bs= new IMP::core::BondDecoratorSingletonScore(h);
IMP::core::SingletonsRestraint *br= new IMP::core::SingletonsRestraint(bs, bl);
m->add_restraint(br);
\endcode







\section i10 Simple optimization setup
A basic setup for optimizing a model.
\verbatim
m= IMP::Model()
particles = setup_model(m)
fname= "/tmp/best_scoring_config.yaml"
best_score=1000000
o= IMP.ConjugateGradients()
o.set_model(m)
for i in range(0,1000):
    randomize(particles)
    score=o.optimize(1000)
    if score < best_score:
       IMP::core::write_yaml(m, fname)
       best_score= score
IMP::core::read_yaml(fname, m)
\endverbatim

\code
IMP::Pointer<IMP::Model> m= new IMP::Model();
IMP::Particles particles = setup_model(m);

std::string best;
float best_score=std::numeric_limits<IMP::Float>::infinity();

IMP::core::ConjugateGradients o;
o.set_model(m)
for (int i=0; i< 100; ++i) {
    randomize(particles)
    IMP::Float score=o.optimize(1000)
    if (score < best_score) {
       std::ostringstream oss;
       IMP::core::write(m, oss);
       best=oss.str();
       best_score= score;
    }
}
std::istringstream iss(best_score);
IMP::core::read(iss, m);
\endcode

\section i11 Writing a simple restraint
This is actually an IMP::core::SingletonsRestraint. You really wouldn't want to write such a thing in Python, although you can.

\code
class IMPDLLEXPORT MyRestraint: public IMP::Restraint {
      IMP::Pointer<IMP::SingletonScore> ss_;
      IMP::Pointer<IMP::core::SingletonContainer> sc_;
public:
        MyRestraint(IMP::SingletonScore *ss,
                    IMP::core::SingletonContainer *sc): ss_(ss),
                                                        sc_(sc){}
        IMP_RESTRAINT(my_version_info);
};

IMP::Float MyRestraint::evaluate(IMP::DerivativeAccumulator *da) {
      IMP::Float accum=0;
      for (IMP::core::SingletonContainer::ParticlesIterator it = sc_->particles_begin(); 
           it != sc_->particles_end(); ++it) {
          accum += ss_->evaluate(*it, da);
       }
       return accum;
}
IMP::Float MyRestraint::show(std::ostream &out) const {
      out << "MyRestraint on " << sc_->get_number_of_particles() << " particles" << std::endl;
}

IMP::ParticlesList
MyRestraint::get_interacting_particles() const
{
       return IMP::ParticlesList();
}

\endcode


\section i12 Available functionality

Look through the types inherited from these methods to get an idea of the functionality available.

- IMP::DecoratorBase
- IMP::Restraint
- IMP::SingletonScore
- IMP::PairScore
- IMP::TripletScore
- and check out the modules page for an orthogonal view




\section i13 C++ vs Python

Most code maps trivially from one to the other as you can see in the example.
- have to declare variables in C++
- need to know about smart pointers (use IMP::Pointer to store pointers)
- memory management is a bit of a mess in Python
- a few things can only be done in one language or the other (pdb files in python)

Debugging is much easier in C++.
- hard to inspect objects in python

Easier to experiment in Python.
- we don't have good doc strings though and no str(foo)

Recommendations:
- write restraints and decorators in C++
- never inherit from a C++ object in Python: the python wrapper we use does not manage memory properly.


\section i14 Conventions to be aware of

We attempted to be very uniform in naming:
- classes are CamelCase
- methods_use_underscores
- methods start with add_, remove_, get_, set_ as appropriate
- If there is an object of type Foo, then Foos is a collection of that object
- Things that maintain a list of objects of type Foo all have at type FooIndex and methods
\verbatim
Foo get_foo(FooIndex)
FooIndex add_foo(Foo)
void add_foos(Foos)
void remove_foo(FooIndex)
etc.
\endverbatim
- Particles are passed around as pointers (rather than indexes).




\section i15 Getting started

Check out the wiki page to get started with IMP
https://salilab.org/imp/wiki/

*/
