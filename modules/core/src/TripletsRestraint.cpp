/**
 *  \file TripletsRestraint.cpp
 *  \brief Implementation
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-9 Sali Lab. All rights reserved.
 *
 */

#include "IMP/core/TripletsRestraint.h"
#include <IMP/internal/container_helpers.h>
#include "IMP/core/ListTripletContainer.h"

#include <IMP/TripletScore.h>
#include <IMP/log.h>


IMPCORE_BEGIN_NAMESPACE

TripletsRestraint
::TripletsRestraint(TripletScore *ss,
                      const ParticleTriplets &pc,
                      std::string name):
  Restraint(name),
  ss_(ss),
  pc_(new ListTripletContainer(pc))
{
}

TripletsRestraint
::TripletsRestraint(TripletScore *ss,
                      TripletContainer *pc,
                      std::string name): Restraint(name),
                                         ss_(ss), pc_(pc) {

}

double TripletsRestraint
::unprotected_evaluate(DerivativeAccumulator *accum) const
{
  IMP_OBJECT_LOG;
  IMP_CHECK_OBJECT(ss_);
  IMP_CHECK_OBJECT(pc_);

  score_= pc_->evaluate(ss_, accum);
  return score_;
}

double TripletsRestraint
::unprotected_incremental_evaluate(DerivativeAccumulator *accum) const
{
  IMP_OBJECT_LOG;
  IMP_CHECK_OBJECT(ss_);
  IMP_CHECK_OBJECT(pc_);
  IMP_LOG(VERBOSE, "Scores are " << score_);
  score_+=pc_->evaluate_change(ss_, accum);
  // compute the base for the added ones
  IMP_LOG(VERBOSE, " " << score_);
  score_ +=pc_->get_added_triplets_container()
    ->evaluate_prechange(ss_, accum);
  IMP_LOG(VERBOSE," " << score_);
  if (accum) {
    DerivativeAccumulator nda(*accum, -1);
    score_ -=pc_->get_removed_triplets_container()
      ->evaluate_prechange(ss_, &nda);
  } else {
    score_ -=pc_->get_removed_triplets_container()
      ->evaluate_prechange(ss_, NULL);
  }
  IMP_LOG(VERBOSE," " << score_ << std::endl);
  return score_;
}

ParticlesList TripletsRestraint::get_interacting_particles() const
{
  IMP_OBJECT_LOG;
  ParticlesList ret0= IMP::internal::get_interacting_particles(pc_.get(),
                                                               ss_.get());
  return ret0;
}

ParticlesTemp TripletsRestraint::get_input_particles() const
{
  IMP_OBJECT_LOG;
  ParticlesTemp ret0= IMP::internal::get_input_particles(pc_.get(),
                                                         ss_.get());
  return ret0;
}

ObjectsTemp TripletsRestraint::get_input_objects() const
{
  return ObjectsTemp(1, pc_);
}

namespace {
  ListTripletContainer *
  check_methods(TripletContainer *pc, std::string str) {
    ListTripletContainer *ret
      = dynamic_cast<ListTripletContainer*>(pc);
    if (! ret) {
      std::ostringstream oss;
      oss << "Method TripletsRestraint::" << str
          << " can only be called if the TripletContainer "
          << " is a ListTripletContainer.";
      throw UsageException(oss.str().c_str());
    }
    return ret;
  }
}

void TripletsRestraint::add_particle_triplets(const ParticleTriplets &ps) {
  ListTripletContainer *pc= check_methods(pc_.get(), "add_particle_triplets");
  pc->add_particle_triplets(ps);
}

void TripletsRestraint::set_particle_triplets(const ParticleTriplets &ps){
  ListTripletContainer *pc= check_methods(pc_.get(), "add_particle_triplets");
  pc->set_particle_triplets(ps);
}

void TripletsRestraint::add_particle_triplet(ParticleTriplet v){
  ListTripletContainer *pc= check_methods(pc_.get(), "add_particle_triplets");
  pc->add_particle_triplet(v);
}

void TripletsRestraint::clear_particle_triplets() {
  ListTripletContainer *pc= check_methods(pc_.get(), "add_particle_triplets");
  pc->clear_particle_triplets();
}


void TripletsRestraint::show(std::ostream& out) const
{
  out << "TripletRestraint with score function ";
  ss_->show(out);
  out << " and container ";
  pc_->show(out);
  out << std::endl;
}

IMPCORE_END_NAMESPACE
