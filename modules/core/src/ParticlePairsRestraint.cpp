/**
 *  \file ParticlePairsRestraint.cpp
 *  \brief Apply a PairScore function to a container of ParticlePairs .
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-8 Sali Lab. All rights reserved.
 *
 */

#include "IMP/core/ParticlePairsRestraint.h"
#include "IMP/core/internal/container_helpers.h"
#include "IMP/core/ListParticlePairContainer.h"

#include <IMP/PairScore.h>
#include <IMP/log.h>


IMPCORE_BEGIN_NAMESPACE

ParticlePairsRestraint
::ParticlePairsRestraint(PairScore *ss,
                      const ParticlePairs &pc):
  ss_(ss),
  pc_(new ListParticlePairContainer(pc))
{
}

ParticlePairsRestraint
::ParticlePairsRestraint(PairScore *ss,
                      ParticlePairContainer *pc): ss_(ss), pc_(pc) {

}


ParticlePairsRestraint::~ParticlePairsRestraint()
{
}

Float ParticlePairsRestraint::evaluate(DerivativeAccumulator *accum)
{

  IMP_CHECK_OBJECT(ss_);
  IMP_CHECK_OBJECT(pc_);

  Float score=0;


  for (ParticlePairContainer::ParticlePairIterator
         it= pc_->particle_pairs_begin();
       it != pc_->particle_pairs_end(); ++it) {
    score += internal::ContainerTraits<ParticlePair>
      ::evaluate(ss_, *it, accum);
  }

  return score;
}


ParticlesList ParticlePairsRestraint::get_interacting_particles() const
{
  if (!internal::ContainerTraits<ParticlePair>::is_singleton) {
    ParticlesList ret;
    for (ParticlePairContainer::ParticlePairIterator it
           = pc_->particle_pairs_begin();
         it != pc_->particle_pairs_end(); ++it) {
      ret.push_back(internal::ContainerTraits<ParticlePair>::create_set(*it));
    }
    return ret;
  } else {
    return ParticlesList();
  }
}

namespace {
  ListParticlePairContainer *
  check_methods(ParticlePairContainer *pc, std::string str) {
    ListParticlePairContainer *ret
      = dynamic_cast<ListParticlePairContainer*>(pc);
    if (! ret) {
      std::ostringstream oss;
      oss << "Method ParticlePairsRestraint::" << str
          << " can only be called if the ParticlePairContainer "
          << " is a ListParticlePairContainer.";
      throw InvalidStateException(oss.str().c_str());
    }
    return ret;
  }
}

void ParticlePairsRestraint::add_particle_pairs(const ParticlePairs &ps) {
  ListParticlePairContainer *pc= check_methods(pc_.get(), "add_particle_pairs");
  pc->add_particle_pairs(ps);
}

void ParticlePairsRestraint::set_particle_pairs(const ParticlePairs &ps){
  ListParticlePairContainer *pc= check_methods(pc_.get(), "add_particle_pairs");
  pc->set_particle_pairs(ps);
}

void ParticlePairsRestraint::add_particle_pair(ParticlePair v){
  ListParticlePairContainer *pc= check_methods(pc_.get(), "add_particle_pairs");
  pc->add_particle_pair(v);
}

void ParticlePairsRestraint::clear_particle_pairs() {
  ListParticlePairContainer *pc= check_methods(pc_.get(), "add_particle_pairs");
  pc->clear_particle_pairs();
}


void ParticlePairsRestraint::show(std::ostream& out) const
{
  out << "ContainerRestraint with score function ";
  ss_->show(out);
  out << " and container ";
  pc_->show(out);
  out << std::endl;
}

IMPCORE_END_NAMESPACE
