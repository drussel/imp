/**
 *  \file ConnectingPairContainer.cpp   \brief A list of ParticlePairs.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-9 Sali Lab. Connecting rights reserved.
 *
 */

#include "IMP/misc/ConnectingPairContainer.h"
#include <IMP/core/internal/DifferenceSingletonContainer.h>
#include <IMP/core/ListPairContainer.h>
#include <IMP/core/internal/pair_helpers.h>
#include <IMP/core/internal/close_pairs_helpers.h>
#include <IMP/PairModifier.h>
#include <IMP/algebra/vector_search.h>


namespace boost {
  unsigned int get(const std::vector<unsigned int> &v,
                   unsigned int i) {
    return v[i];
  }
  void put(std::vector<unsigned int> &v,
           unsigned int i, unsigned int j) {
    v[i]=j;
  }
}
#include <boost/pending/disjoint_sets.hpp>
#include <algorithm>


#include <boost/graph/kruskal_min_spanning_tree.hpp>
#include <boost/graph/prim_minimum_spanning_tree.hpp>
#include <boost/graph/adjacency_list.hpp>
#include <boost/graph/adjacency_matrix.hpp>


IMPMISC_BEGIN_NAMESPACE

namespace {
  typedef std::vector<unsigned int> Index;
  typedef Index Parent;
  typedef boost::disjoint_sets<Index,Parent> UF;
  void build_graph(SingletonContainer *sc, ParticlePairsTemp &out, UF &uf) {
    algebra::Vector3Ds vs(sc->get_number_of_particles());
    for (unsigned int i=0; i< vs.size(); ++i) {
      vs[i]= core::XYZ(sc->get_particle(i)).get_coordinates();
    }
    algebra::NearestNeighborD<3> nn(vs);
    for (unsigned int i=0; i< vs.size(); ++i) {
      unsigned int ni=nn.get_nearest_neighbor(i);
      out.push_back(ParticlePair(sc->get_particle(i), sc->get_particle(ni)));
      uf.union_set(i, ni);
    }
    //if (uf.count_sets() > 1) {
      for (unsigned int i=1; i< vs.size(); ++i) {
        int si=uf.find_set(i);
        int si0= uf.find_set(0);
        if (si != si0) {
          out.push_back(ParticlePair(sc->get_particle(si),
                                     sc->get_particle(si0)));
          uf.union_set(si, si0);
        }
      }
      //}
  }



  /*typedef boost::adjacency_list<boost::vecS, boost::vecS,
                        boost::undirectedS, boost::no_property,
                        boost::property<boost::edge_weight_t, double> > Graph;*/
  typedef boost::adjacency_matrix<boost::undirectedS, boost::no_property,
                        boost::property<boost::edge_weight_t, double> > Graph;
  typedef boost::graph_traits<Graph>::edge_descriptor Edge;
  typedef Graph::edge_property_type Weight;
  typedef boost::graph_traits<Graph>::vertex_descriptor Vertex;

  void compute_mst(const SingletonContainer *a,
                   ParticlePairsTemp &out) {
    unsigned int nump= a->get_number_of_particles();
    Graph g(nump);
    for (unsigned int i=0; i< nump; ++i) {
      core::XYZR di(a->get_particle(i));
      for (unsigned int j=0; j<i; ++j) {
        core::XYZR dj(a->get_particle(j));
        double d=algebra::power_distance(di.get_sphere(), dj.get_sphere());
        /*Edge e =*/ boost::add_edge(i, j, Weight(d), g);
        //boost::put(boost::edge_weight_t(), g, e, d);
      }
    }
    std::vector<Edge> mst;
    mst.resize(nump-1);
    boost::kruskal_minimum_spanning_tree(g, mst.begin());

    for (unsigned int index=0; index< mst.size(); ++index) {
      int i= boost::target(mst[index], g);
      int j= boost::source(mst[index], g);
      out.push_back(ParticlePair(a->get_particle(i), a->get_particle(j)));
    }
  }

}



ConnectingPairContainer::ConnectingPairContainer(SingletonContainer *c,
                                                 double error, bool mst):
  IMP::core::internal::ListLikePairContainer("ConnectingPairContainer"),
  error_(error),
  mst_(mst) {
  initialize(c);
}

void ConnectingPairContainer::initialize(SingletonContainer *sc) {
  sc_=sc;
  fill_list(true);
  Model *m=sc->get_particle(0)->get_model();
  mv_= new core::internal::MovedSingletonContainerImpl<algebra::Sphere3D,
    core::internal::SaveXYZRValues,
    core::internal::SaveMovedValues<core::internal::SaveXYZRValues>,
    core::internal::ListXYZRMovedParticles>(m, sc, error_);
  set_model(m);
}

IMP_ACTIVE_CONTAINER_DEF(ConnectingPairContainer)

ParticlesTemp ConnectingPairContainer::get_state_input_particles() const {
  return sc_->get_particles();
}

void ConnectingPairContainer::fill_list(bool first) {
  // if we have a list and nothing moved further than error do nothing
  // otherwise rebuild
  ParticlePairsTemp new_list;

  if (mst_) {
    compute_mst(sc_, new_list);
  } else {
    Index index(sc_->get_number_of_particles());
    for (unsigned int i=0; i< index.size(); ++i) {
      index[i]=i;
    }
    Parent parent=index;
    UF uf(index, parent);
    build_graph(sc_, new_list, uf);
  }
  update_list(new_list);
}

void ConnectingPairContainer::do_before_evaluate() {
  mv_->update();
  if (mv_->get_number_of_particles() != 0) {
    fill_list(false);
    mv_->reset();
  }
}


void ConnectingPairContainer::do_after_evaluate() {
  IMP::core::internal::ListLikePairContainer::do_after_evaluate();
}


void ConnectingPairContainer::show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << "ConnectingPairContainer on ";
  sc_->show(out);
}

ObjectsTemp ConnectingPairContainer::get_input_objects() const {
  ObjectsTemp ret(2);
  ret[0]=sc_;
  return ret;
}

IMPMISC_END_NAMESPACE
