/**
 *  \file ConnectingPairContainer.cpp   \brief A list of ParticlePairs.
 *
 *  This file is generated by a script (core/tools/make-container).
 *  Do not edit directly.
 *
 *  Copyright 2007-9 Sali Lab. Connecting rights reserved.
 *
 */

#include "IMP/misc/ConnectingPairContainer.h"
#include <IMP/core/internal/DifferenceSingletonContainer.h>
#include <IMP/core/ListPairContainer.h>
#include <IMP/core/internal/pair_helpers.h>
#include <IMP/core/internal/close_pairs_helpers.h>
#include <IMP/PairModifier.h>
#include <IMP/algebra/vector_search.h>
namespace boost {
  unsigned int get(const std::vector<unsigned int> &v,
                   unsigned int i) {
    return v[i];
  }
  void put(std::vector<unsigned int> &v,
           unsigned int i, unsigned int j) {
    v[i]=j;
  }
}
#include <boost/pending/disjoint_sets.hpp>
#include <algorithm>


IMPMISC_BEGIN_NAMESPACE

namespace {
  typedef std::vector<unsigned int> Index;
  typedef Index Parent;
  typedef boost::disjoint_sets<Index,Parent> UF;
  void build_graph(SingletonContainer *sc, ParticlePairsTemp &out, UF &uf) {
    algebra::Vector3Ds vs(sc->get_number_of_particles());
    for (unsigned int i=0; i< vs.size(); ++i) {
      vs[i]= core::XYZ(sc->get_particle(i)).get_coordinates();
    }
    algebra::NearestNeighborD<3> nn(vs);
    for (unsigned int i=0; i< vs.size(); ++i) {
      unsigned int ni=nn.get_nearest_neighbor(i);
      out.push_back(ParticlePair(sc->get_particle(i), sc->get_particle(ni)));
      uf.union_set(i, ni);
    }
    //if (uf.count_sets() > 1) {
      for (unsigned int i=1; i< vs.size(); ++i) {
        int si=uf.find_set(i);
        int si0= uf.find_set(0);
        if (si != si0) {
          out.push_back(ParticlePair(sc->get_particle(si),
                                     sc->get_particle(si0)));
          uf.union_set(si, si0);
        }
      }
      //}
  }
}


ConnectingPairContainer::ConnectingPairContainer(SingletonContainer *c,
                                                 double error): error_(error) {
  initialize(c);
}

void ConnectingPairContainer::initialize(SingletonContainer *sc) {
  sc_=sc;
  set_added_and_removed_containers(
           core::ListPairContainer::create_untracked_container(),
           core::ListPairContainer::create_untracked_container());
  fill_list(true);
  Model *m=sc->get_particle(0)->get_model();
  mv_= new core::internal::MovedSingletonContainerImpl<algebra::Sphere3D,
    core::internal::SaveXYZRValues,
    core::internal::SaveMovedValues<core::internal::SaveXYZRValues>,
    core::internal::ListXYZRMovedParticles>(m, sc, error_);
  set_model(m);
}



IMP_LISTLIKE_PAIR_CONTAINER_DEF(ConnectingPairContainer);

IMP_ACTIVE_CONTAINER_DEF(ConnectingPairContainer)

ParticlesTemp ConnectingPairContainer::get_state_input_particles() const {
  return sc_->get_particles();
}

void ConnectingPairContainer::fill_list(bool first) {
  // if we have a list and nothing moved further than error do nothing
  // otherwise rebuild
  Index index(sc_->get_number_of_particles());
  for (unsigned int i=0; i< index.size(); ++i) {
    index[i]=i;
  }
  Parent parent=index;
  UF uf(index, parent);
  ParticlePairsTemp new_list;
  build_graph(sc_, new_list, uf);

  core::internal::update_list(data_, new_list, this);
}

void ConnectingPairContainer::do_before_evaluate() {
  mv_->update();
  if (mv_->get_number_of_particles() != 0) {
    fill_list(false);
    mv_->reset();
  }
}


void ConnectingPairContainer::do_after_evaluate() {
  core::internal::get_list(get_added_pairs_container())->clear_particle_pairs();
  core::internal::get_list(get_removed_pairs_container())
    ->clear_particle_pairs();
}


void ConnectingPairContainer::show(std::ostream &out) const {
  IMP_CHECK_OBJECT(this);
  out << "ConnectingPairContainer on ";
  sc_->show(out);
}

ObjectsTemp ConnectingPairContainer::get_input_objects() const {
  ObjectsTemp ret(2);
  ret[0]=sc_;
  return ret;
}

IMPMISC_END_NAMESPACE
