#!/usr/bin/python
import sys
from optparse import OptionParser
import os.path

header_template="""
/*
 * \file %(filename)s
 * \brief Provide macros to mark functions and classes as exported
 *        from a DLL/.so, and to set up namespaces
 *
 * When building the module, %(cppprefix)s_EXPORTS should be defined, and when
 * using the module externally, it should not be. Classes and functions
 * declared in the module's headers should then be marked with
 * %(cppprefix)sEXPORT if they are intended to be part of the API and
 * they are not defined entirely in a header.
 *
 * The Windows build environment requires applications to mark exports in
 * this way; we use the same markings to set the visibility of ELF symbols
 * if we have compiler support.
 *
 * All code in this module should live in the IMP::base namespace.
 * This is simply achieved by wrapping things with the
 * %(cppprefix)s_BEGIN_NAMESPACE and %(cppprefix)s_END_NAMESPACE macros.
 * There are similar macros for module code that is designed to be for
 * internal use only.
 *
 * This header is auto-generated by scons_tools/module/_config_h.py;
 * it should not be edited manually.
 *
 * Copyright 2007-2013 IMP Inventors. All rights reserved.
 *
 */

#ifndef %(cppprefix)s_CONFIG_H
#define %(cppprefix)s_CONFIG_H

#include <IMP/compatibility/compatibility_config.h>
#include <string>


#ifdef _MSC_VER

#ifdef %(cppprefix)s_EXPORTS
#define %(cppprefix)sEXPORT __declspec(dllexport)
#else // EXPORTS
#define %(cppprefix)sEXPORT __declspec(dllimport)
#endif // EXPORTS

#else // _MSC_VER

#ifdef GCC_VISIBILITY
#define %(cppprefix)sEXPORT __attribute__ ((visibility("default")))
#else // GCC_VISIBILITY
#define %(cppprefix)sEXPORT
#endif // GCC_VISIBILITY
#endif // _MSC_VER

#if defined(_MSC_VER) && !defined(SWIG)
#ifdef %(cppprefix)s_EXPORTS

#define %(cppprefix)s_EXPORT_TEMPLATE(name)                 template class __declspec(dllexport) name

#else //EXPORTS

#define %(cppprefix)s_EXPORT_TEMPLATE(name)                 template class __declspec(dllimport) name

#endif // EXPORTS

#else // MSC and SWIG
#define %(cppprefix)s_EXPORT_TEMPLATE(name) IMP_REQUIRE_SEMICOLON_NAMESPACE

#endif // MSC and SWIG

#define %(cppprefix)s_BEGIN_NAMESPACE \\
%(namespacebegin)s

#define %(cppprefix)s_END_NAMESPACE \\
%(namespaceend)s

#define %(cppprefix)s_BEGIN_INTERNAL_NAMESPACE \\
%(cppprefix)s_BEGIN_NAMESPACE namespace internal {


#define %(cppprefix)s_END_INTERNAL_NAMESPACE \\
} %(cppprefix)s_END_NAMESPACE

%(cppdefines)s

//  functions are defined explicitly for swig

%(cppprefix)s_BEGIN_NAMESPACE
/** \name Standard module methods
  All \imp modules have a set of standard methods to help get information
  about the module and about file associated with the modules.
  @{
  */
#if !defined(SWIG) && %(is_not_compatibility)s
%(cppprefix)sEXPORT std::string get_module_version();
#endif

#if !defined(SWIG)
// swig will whine about duplicate definitions of function
inline std::string get_module_name() {
   return "IMP::%(name)s";
}
#endif

%(cppprefix)s_END_NAMESPACE

#if !defined(SWIG) && !defined(IMP_DOXYGEN) &&  %(is_not_compatibility)s && %(is_not_base)s

#include <IMP/base/Showable.h>
#include <IMP/base/hash.h>

%(cppprefix)s_BEGIN_NAMESPACE
using ::IMP::base::Showable;
using ::IMP::base::operator<<;
using ::IMP::base::hash_value;
%(cppprefix)s_END_NAMESPACE
%(cppprefix)s_BEGIN_INTERNAL_NAMESPACE
using ::IMP::base::Showable;
using ::IMP::base::operator<<;
using ::IMP::base::hash_value;
%(cppprefix)s_END_INTERNAL_NAMESPACE
#endif





#if !defined(SWIG) && %(is_not_compatibility)s

%(cppprefix)s_BEGIN_NAMESPACE
//! Return the full path to installed data
/** Each module has its own data directory, so be sure to use
    the version of this function in the correct module. To read
    the data file "data_library" that was placed in the \c data
    directory of module "mymodule", do something like
    \code
    std::ifstream in(IMP::mymodule::get_data_path("data_library"));
    \endcode
    This will ensure that the code works when \imp is installed or
    used via the \c tools/imppy.sh script.
*/
%(cppprefix)sEXPORT std::string get_data_path(std::string file_name);

//! Return the path to installed example data for this module
/** Each module has its own example directory, so be sure to use
    the version of this function in the correct module.  For example
    to read the file \c example_protein.pdb located in the
    \c examples directory of the IMP::atom module, do
    \code
    IMP::atom::read_pdb(IMP::atom::get_example_path("example_protein.pdb", model));
    \endcode
    This will ensure that the code works when \imp is installed or
    used via the \c tools/imppy.sh script.
*/
%(cppprefix)sEXPORT std::string get_example_path(std::string file_name);
/** @} */
%(cppprefix)s_END_NAMESPACE
#endif


#endif  /* %(cppprefix)s_CONFIG_H */
"""

cpp_template="""/**
 *  \\file config.cpp
 *  \\brief base module version information.
 *
 *  Copyright 2007-2013 IMP Inventors. All rights reserved.
 *
 */

#include <%(filename)s>
#if  %(is_not_compatibility)s
#include <IMP/base/internal/directories.h>
#endif

%(cppprefix)s_BEGIN_NAMESPACE

#if  %(is_not_compatibility)s
std::string get_module_version() {
    return std::string("%(version)s");
}
std::string get_data_path(std::string file_name) {
  return IMP::base::internal::get_data_path("%(name)s", file_name);
}
std::string get_example_path(std::string file_name)  {
  return IMP::base::internal::get_example_path("%(name)s", file_name);
}
#endif

%(cppprefix)s_END_NAMESPACE
"""

parser = OptionParser()
parser.add_option("-D", "--defines", dest="defines", default="",
                  help="Colon separated list of defines.")
parser.add_option("-m", "--found_optional_modules",
                  dest="found_optional_modules", default="",
                  help="A colon separated list of found optional modules")
parser.add_option("-M", "--unfound_optional_modules",
                  dest="unfound_optional_modules", default="",
                  help="A colon separated list of unfound optional modules")
parser.add_option("-l", "--found_optional_dependencies",
                  dest="found_optional_dependencies", default="",
                  help="A colon separated list of found optional dependencies")
parser.add_option("-L", "--unfound_optional_dependencies",
                  dest="unfound_optional_dependencies", default="",
                  help="An colon separated list of unfound optional dependencies")
parser.add_option("-v", "--version",
                  dest="version",
                  help="The version")
parser.add_option("-i", "--header",
                  dest="header",
                  help="Where to put the header")
parser.add_option("-c", "--cpp",
                  dest="cpp",
                  help="Where to put the cpp file")
parser.add_option("-n", "--name",
                  dest="name", help="The name of the module.")

def add_list_to_defines(cppdefines, data, sym, val, names):
    for n in names:
        nn= n.replace(".", "_").upper()
        cppdefines.append("#define IMP_%s_%s_%s"%(data["name"].upper(), sym, nn))
        cppdefines.append("#define IMP_%s_HAS_%s %d"%(data["name"].upper(), nn, val))

def make_header(options):
    dir= os.path.dirname(options.header)
    try:
        os.makedirs(dir)
    except:
        #exists
        pass
    data={}
    if options.name=="kernel":
        data["filename"]="IMP/kernel_config.h"
        data["cppprefix"]="IMP"
        data["namespacebegin"]="namespace IMP {"
        data["namespaceend"]="}"
    else:
        data["filename"]="IMP/%s/%s_config.h"%(options.name, options.name)
        data["cppprefix"]="IMP%s"%options.name.upper().replace("_", "")
        data["namespacebegin"]="namespace IMP { namespace %s {"%options.name
        data["namespaceend"]="} }"
    if options.name!="compatibility":
        data["is_not_compatibility"]=1
    else:
        data["is_not_compatibility"]=0
    if options.name!="base":
        data["is_not_base"]=1
    else:
        data["is_not_base"]=0
    data["name"]= options.name
    cppdefines=[]
    if options.defines != "":
        for define in options.defines.split(":"):
            parts= define.split("=")
            if len(parts) ==2:
                cppdefines.append("#define %s %s"%(parts[0], parts[1]))
            else:
                cppdefines.append("#define %s"%parts[0])
    if options.found_optional_modules != "":
        add_list_to_defines(cppdefines, data, "USE", 1,
                            ["imp_"+x for x in options.found_optional_modules.split(":")])
    if options.unfound_optional_modules != "":
        add_list_to_defines(cppdefines, data, "NO", 0,
                            ["imp_"+x for x in options.unfound_optional_modules.split(":")])
    if options.found_optional_dependencies != "":
        add_list_to_defines(cppdefines, data, "USE", 1,
                            [x for x in options.found_optional_dependencies.split(":")])
    if options.unfound_optional_dependencies != "":
        add_list_to_defines(cppdefines, data, "NO", 0,
                            [x for x in options.unfound_optional_dependencies.split(":")])
    data["cppdefines"]="\n".join(cppdefines)
    open(options.header, "w").write(header_template%data)

def make_cpp(options):
    dir= os.path.dirname(options.cpp)
    try:
        os.makedirs(dir)
    except:
        # exists
        pass
    data={}
    if options.name=="kernel":
        data["filename"]="IMP/kernel_config.h"
        data["cppprefix"]="IMP"
    else:
        data["filename"]="IMP/%s/%s_config.h"%(options.name, options.name)
        data["cppprefix"]="IMP%s"%options.name.upper().replace("_", "")
    if options.name!="compatibility":
        data["is_not_compatibility"]=1
    else:
        data["is_not_compatibility"]=0
    data["name"]= options.name
    data["version"]= options.version
    open(options.cpp, "w").write(cpp_template%data)

def main():
    (options, args) = parser.parse_args()
    make_header(options)
    make_cpp(options)
if __name__ == '__main__':
    main()
