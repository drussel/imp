<chapter id="usage">
<title>Usage</title>

<sect1 id="compilation">
<title>Compilation from source code</title>

<sect2 id="prereq">
<title>Prerequisites</title>

<para>In order to obtain and compile &IMP;, you will need:</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.swig.org">SWIG</ulink> (1.3.33 or later).
</para></listitem>

<listitem><para>
<ulink url="http://www.scons.org">scons</ulink> (0.98 or later).
</para></listitem>

<listitem><para><ulink url="http://www.boost.org">Boost</ulink> (1.30 or later).
At the moment &IMP; only uses the Boost headers (not the libraries), so
installing these headers in <filename>/usr/local/include/boost</filename>
should suffice.</para></listitem>

<listitem><para><ulink url="http://www.python.org">Python</ulink> 2.3 or
later.</para></listitem>

<listitem><para>A <ulink url="http://subversion.tigris.org/">Subversion</ulink>
(svn) client to access the repository.</para></listitem>

</itemizedlist>

<sect3 id="mac">
<title>Mac</title>
<para> Mac users should use one of the available collections of Unix tools,
either <ulink url="http://www.macports.org/">MacPorts</ulink> or
<ulink url="http://www.finkproject.org/">Fink</ulink>. These both include SWIG,
scons, Subversion and Boost (for example, to install Boost with MacPorts, use
the command <command>sudo port install boost</command>). At the moment Fink
does not have a binary installer for Mac OS 10.5, so MacPorts is
preferred.</para>

<para>Do not install any C++ headers in <filename>/usr/include</filename> on
your Mac as the compiler assumes any such headers are C headers. Extra headers
not owned by MacPorts or Fink should be placed in
<filename>/usr/local/include</filename>.</para>
</sect3>

<sect3 id="windows">
<title>Windows</title>
<para> Windows users should probably install
<ulink url="http://www.cygwin.org/">Cygwin</ulink>, but we don't have any of
those yet, so we don't really know.</para>

</sect3>

</sect2>

<sect2 id="optionallibs">
<title>Optional dependencies</title>

<itemizedlist>
<listitem><para>If you want to use &IMP; with &MODELLER; (optional), you should
use version 9v2 or later.</para></listitem>
</itemizedlist>

</sect2>

<sect2 id="gettingbuilding">
<title>Getting and building IMP</title>
<para>
If you have Subversion installed you can get the current &IMP; code by running
the following:
<screen>
<command>svn co https://svn.salilab.org/imp/trunk imp</command>
</screen>
</para>
<para>
To build &IMP;, in the <filename>imp</filename> directory type:
<screen>
<command>scons</command>
</screen>
</para>
<para>
Finally, to use &IMP; within Python, type the following in the
<filename>imp</filename> directory:
<screen>
<command>bin/imppy.sh python</command>
</screen>
</para>

<para>
Some other useful commands:
<itemizedlist>

<listitem>If you have checked out a copy of &IMP;, you can update it to the
current code by typing
<screen>
<command>svn update</command>
</screen></listitem>

<listitem> To install &IMP; into <filename>install_dir</filename>, type
<screen>
<command>scons install prefix=install_dir</command>
</screen>
Note that installation does not currently work on Mac OS.
</listitem>
<listitem>
If you want to use &IMP; with &MODELLER;, set the <command>scons</command>
<varname>modeller</varname> variable to the directory where you have
&MODELLER; installed, e.g. <screen><command>scons modeller=~/modinstall</command> </screen>
Type <command>scons -h</command> to get help on this and other command-line
options.
</listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

<sect1 id="reference">
<title>Reference manual</title>
<para>
For information on the low-level &IMP; code, see the
<ulink url="doxygen/index.html">C++ API reference</ulink>.
</para>
</sect1>

<sect1 id="style">
<title>Style guide</title>

<para>
To ensure code consistency and readability, certain conventions should be
adhered to when writing code for &IMP;. Some of these conventions are
automatically checked for by source control before allowing a new commit, and
should also be checked yourself in new code by running
<command>scons standards</command>.
</para>

<sect2>
<title>C++ formatting</title>

<sect3>
<title>Indentation</title>
<para>All C++ headers and code should be indented in 'Linux' style, with
2-space indents. Do not use tabs. This is roughly the output of
<ulink url="http://astyle.sourceforge.net/">Artistic Style</ulink> with
the <parameter>--convert-tabs --style=linux --indent=spaces=2 --unpad=paren --pad=oper</parameter>
parameters. Split lines if necessary to ensure that no line is longer than
80 characters.
</para>

<para><emphasis>Rationale:</emphasis>
Different users have different-sized windows or terminals, and different tab
settings. This is also similar to other lab C and Fortran projects.
</para>
</sect3>

<sect3>
<title>Comments</title>

<para>Format to allow 
<ulink url="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink>
automated documentation creation. If possible, specify both a 'brief'
description and a more detailed one (in which parameters, return values,
and exceptions are documented). Use //! for the one-line brief description
and /** ... */ for the multi-line detailed description (put the closing */ on
a new line, so that these comments are always multi-line (Doxygen will not
accept both a 'brief' comment and a one-line detailed comment). All header
and source files should have a starting comment header, using the
<command>\file</command> command to document the purpose of the file.
For example:</para>
<informalexample><programlisting>
//! Calculates the square root.
/** \param[in] the_value Calculate the square root of this value.
    \exception std::domain_error value is out of range (negative).
    \return the square root of the given value.
 */
</programlisting></informalexample>
</sect3>

<sect3>
<title>Class names</title>

<para>Use CamelCase (i.e. capitalized concatenated words). For example:</para>
<informalexample><programlisting>
class SpecialVector
{
};
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
This makes it easier to tell between class names and function names where
this is ambiguous (particularly an issue with the Python interface). The
Python guys also mandate CamelCase for their class names, so this avoids
any need to rename classes between C++ and Python to ensure clean Python code.
</para>
</sect3>

<sect3>
<title>Exceptions</title>
<para>Exceptions are classes, so name as for classes, above. Do not use
exception specfications, but do document the possible exceptions thrown by
a function with the Doxygen <command>\exception</command> command.
</para>

<para><emphasis>Rationale:</emphasis>
Exception specifications do not guarantee that only the listed exceptions will
be thrown, and actually hurt compiler optimizations in many cases. Many
libraries (such as Boost) <ulink url="http://www.gotw.ca/publications/mill22.htm">advise against using them</ulink>.
</para>

</sect3>

<sect3>
<title>Member functions (class methods)</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
void SpecialVector::add_constant(int the_constant)
</programlisting></informalexample>

<para>Use set_ at the beginning of setting accessor functions, and get_ at the
beginning of accessor functions used to get a member variable value.
For example:</para>

<informalexample><programlisting>
float Sphere::get_radius(void) const;
void Sphere::set_radius(float);
</programlisting></informalexample>
</sect3>

<sect3>
<title>Member variables (class variables)</title>

<para>Use lower case, with words separated by underscores. End name in an
underscore. For example:</para>
<informalexample><programlisting>
std::vector&lt;int&gt; spec_vector_; 
</programlisting></informalexample>
</sect3>

<sect3>
<title>Local variables</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
int i, num_particles;
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
A trailing underscore makes it simple to tell between class members and
local variables.</para>
</sect3>

</sect2>

<sect2>
<title>C++ libraries and namespaces</title>
<para>Explicitly use namespace prefixes rather than the "using namespace"
syntax.</para>

<para><emphasis>Rationale:</emphasis>
Avoids namespace pollution, and removes any ambiguity.
</para>

</sect2>

<sect2>
<title>Includes</title>
<para>Always import headers for the current module first, followed by headers
for any dependent modules (e.g. the kernel), and finally any system headers.
Use angle brackets and the full name of the header (with IMP/ prefix).
For example,
</para>
<informalexample><programlisting>
#include &lt;IMP/mymodule/MyClass.h&gt;
#include &lt;IMP/mymodule/MyOtherClass.h&gt;

#include &lt;IMP/KernelBaseClass.h&gt;

#include &lt;math&gt;
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
This makes any dependencies in your code obvious, and by including standard
headers <emphasis>after</emphasis> IMP headers, any missing includes in the
headers themselves show up early (rather than being masked by other headers
you include). Adding the IMP prefix and using angle brackets reduces the
likelihood that uninstalled rogue headers in the source code directory are
used, which could break the build.
</para>

<para>For simplicity, to include a header from the same module within another
header, you can use a relative path (i.e. without the IMP/ prefix) and use
double quotes rather than angle brackets. This makes it obvious to the reader
that the include is from the same module. Since headers are staged to a build
directory, there is no danger of including an uninstalled header this way.
</para>
</sect2>

<sect2>
<title>Python formatting</title>
<para>All Python code should conform to the
<ulink url="http://www.python.org/dev/peps/pep-0008/">Python style
guide</ulink>. In essence this translates to 4-space indents, no tabs, and
similar class, method and variable naming to the C++ code. You can ensure that
your Python code is correctly indented by using the
<ulink url="http://docutils.sourceforge.net/sandbox/py-rest-doc/utils/reindent.py">reindent.py</ulink>
script, available as part of the Python distribution.
</para>

</sect2>

</sect1>

<sect1 id="codereview">
<title>Code review</title>

<para>To ensure code quality, additions to the IMP kernel should be reviewed
by the other developers. In general, this means posting a patch with some
explanation of the changes (e.g. suitable for the source control logs) to the
<email>imp-dev@salilab.org</email> mailing list. This is mandatory for
changes that:</para>
<itemizedlist>
<listitem><para>Change the API (e.g. remove or rename existing methods or
classes, change the arguments taken by existing methods, change the behavior
of existing methods, change the return values or thrown exceptions of existing
methods).</para></listitem>

<listitem><para>Remove or modify existing test cases.</para></listitem>
</itemizedlist>

<para>For more minor changes, such as adding new tests, methods and/or classes
(which may change the ABI but not the API), documentation updates, etc.
review is not <emphasis>required</emphasis> but is recommended.</para>

<para>Patches should contain a related set of changes. For example, a patch
which adds a new method <methodname>foo</methodname>, a new testcase for
<methodname>foo</methodname>, and some documentation for the
<classname>SpecialVector</classname> class, should be split into two patches:
one for the <methodname>foo</methodname> method and test, and the other for
the <classname>SpecialVector</classname> documentation.</para>

<para>New code in patches should also adhere to the
<link linkend="style">coding style guidelines</link>.</para>

<para>If new methods and/or classes are added, it is
<emphasis>strongly</emphasis> recommended that unit tests are added for these.
(Even a simple call of each method with no checking of the return values or
other effects is better than nothing.)</para>

<para><emphasis>Rationale:</emphasis>
Other developers may have external applications and their own in-progress work
which may be adversely affected by your changes. There may also be disagreement
about a change, so discussing it on the mailing list first assures that a
consensus is first reached, rather than other developers later reverting the
change. It is much easier to review a patch if it is small and contains only
relevant changes, and in addition it can generally be applied to source control
virtually unchanged if the code is OK. Test cases also help to document the
intent of code changes, as well as making sure that the new additions are not
accidentally broken in future.
</para>

</sect1>

</chapter>
