<chapter id="usage">
<title>Usage</title>

<sect1 id="compilation">
<title>Compilation from source code</title>

<sect2 id="prereq">
<title>Prerequisites</title>

<para>In order to obtain and compile &IMP;, you will need:</para>

<itemizedlist>
<listitem><para>
<ulink url="http://www.swig.org">SWIG</ulink> (1.3.33 or later).
</para></listitem>

<listitem><para>
<ulink url="http://www.scons.org">scons</ulink> (0.98 or later).
</para></listitem>

<listitem><para><ulink url="http://www.boost.org">Boost</ulink> (1.30 or later).
At the moment &IMP; only uses the Boost headers (not the libraries), so
installing these headers in <filename>/usr/local/include/boost</filename>
should suffice.</para></listitem>

<listitem><para><ulink url="http://www.python.org">Python</ulink> 2.3 or
later.</para></listitem>

<listitem><para>A <ulink url="http://subversion.tigris.org/">Subversion</ulink>
(svn) client to access the repository.</para></listitem>

</itemizedlist>

<sect3 id="mac">
<title>Mac</title>
<para> Mac users should use one of the available collections of Unix tools,
either <ulink url="http://www.macports.org/">MacPorts</ulink> or
<ulink url="http://www.finkproject.org/">Fink</ulink>. These both include SWIG,
scons, Subversion and Boost (for example, to install Boost with MacPorts, use
the command <command>sudo port install boost</command>). At the moment Fink
does not have a binary installer for Mac OS 10.5, so MacPorts is
preferred.</para>

<para>Do not install any C++ headers in <filename>/usr/include</filename> on
your Mac as the compiler assumes any such headers are C headers. Extra headers
not owned by MacPorts or Fink should be placed in
<filename>/usr/local/include</filename>.</para>
</sect3>

<sect3 id="windows">
<title>Windows</title>
<para> Windows users should probably install
<ulink url="http://www.cygwin.org/">Cygwin</ulink>, but we don't have any of
those yet, so we don't really know.</para>

</sect3>

</sect2>

<sect2 id="optionallibs">
<title>Optional dependencies</title>

<itemizedlist>
<listitem><para>If you want to use &IMP; with &MODELLER; (optional), you should
use version 9v5 or later.</para></listitem>
</itemizedlist>

</sect2>

<sect2 id="gettingbuilding">
<title>Getting and building IMP</title>
<para>
If you have Subversion installed you can get the current &IMP; code by running
the following:
<screen>
<command>svn co https://svn.salilab.org/imp/trunk imp</command>
</screen>
</para>
<para>
To build &IMP;, in the <filename>imp</filename> directory type:
<screen>
<command>scons</command>
</screen>
</para>
<para>
Finally, to use &IMP; within Python, type the following in the
<filename>imp</filename> directory:
<screen>
<command>bin/imppy.sh python</command>
</screen>
</para>

<para>
Some other useful commands:
<itemizedlist>

<listitem>If you have checked out a copy of &IMP;, you can update it to the
current code by typing
<screen>
<command>svn update</command>
</screen></listitem>

<listitem> To install &IMP; into <filename>install_dir</filename>, type
<screen>
<command>scons install prefix=install_dir</command>
</screen>
Note that installation does not currently work on Mac OS.
</listitem>
<listitem>
If you want to use &IMP; with &MODELLER;, set the <command>scons</command>
<varname>modeller</varname> variable to the directory where you have
&MODELLER; installed, e.g. <screen><command>scons modeller=~/modinstall</command> </screen>
Type <command>scons -h</command> to get help on this and other command-line
options.
</listitem>

</itemizedlist>
</para>

</sect2>

</sect1>

<sect1 id="reference">
<title>Reference manual</title>
<para>
For information on the low-level &IMP; code, see the
<ulink url="doxygen/index.html">C++ API reference</ulink>.
</para>
</sect1>

<sect1 id="modules">
<title>IMP modules</title>
<para>
IMP is divided into modules, with different uses and dependencies. The IMP
kernel only defines the simplest classes used in IMP, such as the particles,
and provides defined interfaces (abstract base classes) for functionality such
as restraints. The real work (or implementation) is done by modules.
</para>

<para>
Typically, a module groups functionality (such as restraints or specialized
optimizers) for specific applications or problem domains, such as the
<filename>em</filename> module for cryo EM fitting. Modules may also pull in
interfaces to external libraries (for example, the <filename>em</filename>
and <filename>modeller</filename> modules interface with EMBED and MODELLER
respectively) or may depend on other IMP modules (for example, many modules
depend on the <filename>core</filename> module).
</para>

<para>
There are also two "general purpose" modules: the <filename>misc</filename>
module, which contains miscellaneous features which are
generally <emphasis>not</emphasis> used by other modules, and
the <filename>core</filename> module, which contains features expected to be
used by almost everybody, and upon which many other modules depend.
The <filename>misc</filename> module can be used for features that do not
neatly fit into a specialized module, such as code that implements proposed
new methodologies.
</para>

<para>
It is also possible to create your IMP modules outside of IMP itself. This
is ideal if you have different licensing requirements, your code is very
experimental, or you do not want to share your source code, for example.
Of course, if you go down this route, you must do your own book keeping to
make sure that the IMP kernel and any modules you depend on are correctly built
before your own.
</para>
</sect1>

<sect1 id="style">
<title>Style guide</title>

<para>
To ensure code consistency and readability, certain conventions should be
adhered to when writing code for &IMP;. Some of these conventions are
automatically checked for by source control before allowing a new commit, and
should also be checked yourself in new code by running
<command>scons standards</command>.
</para>

<sect2>
<title>C++ formatting</title>

<sect3>
<title>Indentation</title>
<para>All C++ headers and code should be indented in 'Linux' style, with
2-space indents. Do not use tabs. This is roughly the output of
<ulink url="http://astyle.sourceforge.net/">Artistic Style</ulink> with
the <parameter>--convert-tabs --style=linux --indent=spaces=2 --unpad=paren --pad=oper</parameter>
parameters. Split lines if necessary to ensure that no line is longer than
80 characters.
</para>

<para><emphasis>Rationale:</emphasis>
Different users have different-sized windows or terminals, and different tab
settings. This is also similar to other lab C and Fortran projects.
</para>
</sect3>

<sect3>
<title>Comments</title>

<para>Format to allow 
<ulink url="http://www.stack.nl/~dimitri/doxygen/">Doxygen</ulink>
automated documentation creation. If possible, specify both a 'brief'
description and a more detailed one (in which parameters, return values,
and exceptions are documented). Use //! for the one-line brief description
and /** ... */ for the multi-line detailed description (put the closing */ on
a new line, so that these comments are always multi-line (Doxygen will not
accept both a 'brief' comment and a one-line detailed comment). All header
and source files should have a starting comment header, using the
<command>\file</command> command to document the purpose of the file.
For example:</para>
<informalexample><programlisting>
//! Calculates the square root.
/** \param[in] the_value Calculate the square root of this value.
    \exception std::domain_error value is out of range (negative).
    \return the square root of the given value.
 */
</programlisting></informalexample>
</sect3>

<sect3>
<title>Class names</title>

<para>Use CamelCase (i.e. capitalized concatenated words). For example:</para>
<informalexample><programlisting>
class SpecialVector
{
};
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
This makes it easier to tell between class names and function names where
this is ambiguous (particularly an issue with the Python interface). The
Python guys also mandate CamelCase for their class names, so this avoids
any need to rename classes between C++ and Python to ensure clean Python code.
</para>
</sect3>

<sect3>
<title>Exceptions</title>
<para>Exceptions are classes, so name as for classes, above. Do not use
exception specifications, but do document the possible exceptions thrown by
a function with the Doxygen <command>\exception</command> command.
</para>

<para><emphasis>Rationale:</emphasis>
Exception specifications do not guarantee that only the listed exceptions will
be thrown, and actually hurt compiler optimizations in many cases. Many
libraries (such as Boost) <ulink url="http://www.gotw.ca/publications/mill22.htm">advise against using them</ulink>.
</para>

</sect3>

<sect3>
<title>Member functions (class methods)</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
void SpecialVector::add_constant(int the_constant)
</programlisting></informalexample>

<para>Use set_ at the beginning of setting accessor functions, and get_ at the
beginning of accessor functions used to get a member variable value.
For example:</para>

<informalexample><programlisting>
float Sphere::get_radius(void) const;
void Sphere::set_radius(float);
</programlisting></informalexample>
</sect3>

<sect3>
<title>Member variables (class variables)</title>

<para>Use lower case, with words separated by underscores. End name in an
underscore. For example:</para>
<informalexample><programlisting>
std::vector&lt;int&gt; spec_vector_; 
</programlisting></informalexample>
</sect3>

<sect3>
<title>Local variables</title>

<para>Use lower case, with words separated by underscores. For example:</para>
<informalexample><programlisting>
int i, num_particles;
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
A trailing underscore makes it simple to tell between class members and
local variables.</para>
</sect3>

</sect2>

<sect2>
<title>C++ libraries and namespaces</title>
<para>Explicitly use namespace prefixes rather than the "using namespace"
syntax.</para>

<para><emphasis>Rationale:</emphasis>
Avoids namespace pollution, and removes any ambiguity.
</para>

<para>Use the provided macros such as <code>IMP_BEGIN_NAMESPACE</code> and
<code>IMP_END_NAMESPACE</code> to begin and end the namespace for the kernel
or a module.
</para>

</sect2>

<sect2>
<title>Includes</title>
<para>Always import headers for the current module first, followed by headers
for any dependent modules (e.g. the kernel), and finally any system headers.
Use angle brackets and the full name of the header (with IMP/ prefix).
For example,
</para>
<informalexample><programlisting>
#include &lt;IMP/mymodule/MyClass.h&gt;
#include &lt;IMP/mymodule/MyOtherClass.h&gt;

#include &lt;IMP/KernelBaseClass.h&gt;

#include &lt;math&gt;
</programlisting></informalexample>

<para><emphasis>Rationale:</emphasis>
This makes any dependencies in your code obvious, and by including standard
headers <emphasis>after</emphasis> IMP headers, any missing includes in the
headers themselves show up early (rather than being masked by other headers
you include). Adding the IMP prefix and using angle brackets reduces the
likelihood that uninstalled rogue headers in the source code directory are
used, which could break the build.
</para>

<para>For simplicity, to include a header from the same module within another
header, you can use a relative path (i.e. without the IMP/ prefix) and use
double quotes rather than angle brackets. This makes it obvious to the reader
that the include is from the same module. Since headers are staged to a build
directory, there is no danger of including an uninstalled header this way.
</para>
</sect2>

<sect2>
<title>Python formatting</title>
<para>All Python code should conform to the
<ulink url="http://www.python.org/dev/peps/pep-0008/">Python style
guide</ulink>. In essence this translates to 4-space indents, no tabs, and
similar class, method and variable naming to the C++ code. You can ensure that
your Python code is correctly indented by using the
<ulink url="http://docutils.sourceforge.net/sandbox/py-rest-doc/utils/reindent.py">reindent.py</ulink>
script, available as part of the Python distribution.
</para>

</sect2>

</sect1>

<sect1 id="adding-code">
<title>Adding code to IMP</title>

<sect2 id="choose-module">
<title>Choosing a module for your code</title>

<para>
By far the easiest way to contribute to IMP is to create a module for your
specific problem domain. For example, restraints and optimizers specific to
ligands could go in a <filename>ligand</filename> module. Please contact Ben
to have a new module created. If you feel your code doesn't belong in its
own module, you can add it to the <filename>misc</filename> module instead.
If you feel your new functionality is of use to everybody and should live in the
<filename>core</filename> module, you should request this on the IMP mailing
list and have it approved by Ben, who has the final say on where code should
end up. This is partly to prevent the <filename>core</filename> module from
becoming too bloated with specialized code.
</para>

<para>
Code should generally <emphasis>not</emphasis> be moved from one
module to another, unless there is an exceptionally good reason to do so. If
for some reason you do want to move things between modules, ask Ben to do it.
</para>
</sect2>

<sect2 id="define-interfaces">
<title>Defining your interfaces</title>

<para>
Before you sit down and write your new code or change existing code, you
should think about the interfaces. These are the classes and their methods,
without any implementation. It is recommended that you discuss these
interfaces on the <email>imp-dev@salilab.org</email> mailing list before you
proceed with implementation, so that you do not duplicate work, others can
make valuable suggestions or point out problems, and people are made aware of
your contribution. If you want to add to or change the interfaces in the
kernel or the <filename>core</filename> module, this discussion is
mandatory, since potentially everybody could be affected by your changes. Any
issues raised by users with changes to the kernel or <filename>core</filename>
must be resolved to their satisfaction before the changes are made. For clarity,
the following should be considered changes that warrant discussion:
</para>

<itemizedlist>
<listitem><para>Change the API (e.g. remove or rename existing methods or
classes, change the arguments taken by existing methods, change the behavior
of existing methods, change the return values or thrown exceptions of existing
methods).</para></listitem>

<listitem><para>Remove or modify existing test cases.</para></listitem>
</itemizedlist>

<para>
Conversely, changes in internal implementation or documentation to any module,
or changes in the interfaces of your own modules or the
<filename>misc</filename> module, do not need to be announced, and neither does
the addition of new methods to existing classes, although it may be helpful
to tell people about such changes.
</para>

</sect2>

<sect2 id="patches">
<title>Creating a patch</title>

<para>
Generally speaking, to add code to IMP, your changes should be made to your
checkout of the IMP repository, and then a patch generated by using the
<command>svn di</command> command.
</para>

<para>Patches should contain a related set of changes. For example, a patch
which adds a new method <methodname>foo</methodname>, a new testcase for
<methodname>foo</methodname>, and some documentation for the
<classname>SpecialVector</classname> class, should be split into two patches:
one for the <methodname>foo</methodname> method and test, and the other for
the <classname>SpecialVector</classname> documentation.</para>

<para>New code in patches should also adhere to the
<link linkend="style">coding style guidelines</link>.</para>

<para>If new methods and/or classes are added, it is
<emphasis>strongly</emphasis> recommended that unit tests are added for these.
(Even a simple call of each method with no checking of the return values or
other effects is better than nothing.)</para>

<para><emphasis>Rationale:</emphasis>
It is much easier for others to understand your patch's changes if it is small
and contains only relevant changes. Test cases also help to document the
intent of code changes, as well as making sure that the new additions are not
accidentally broken in future.
</para>

</sect2>

<sect2 id="commit-patch">
<title>Committing a patch</title>

<para>
Once your patch is complete and you have run the testcases to make sure you
didn't break anything, and reviewed the patch to check your work, it can be
committed to the source control system, provided that any interface changes
have <link linkend="define-interfaces">been discussed</link> if required.
How this is done depends on whether you have commit rights for the affected
module(s). If you do, you can simply use <command>svn ci</command>. If you do
not, send the patch to the owner of the module for integration, with a brief
description of your changes for the source control logs:
</para>

<sect3 id="kernel-ci">
<title>IMP kernel</title>
<para>
All changes to the IMP kernel, since they affect everybody, must be approved
by Ben. Send your patch to <email>imp-dev@salilab.org</email> for integration.
</para>
</sect3>

<sect3 id="core-misc-ci">
<title>core and misc modules</title>
<para>
Anybody can commit to these modules after approval; ask Ben to get your
account activated.
</para>
</sect3>

<sect3 id="other-ci">
<title>Other modules</title>
<para>
Domain-specific modules all have a responsible owner, and it is up to them
whether they want to allow others commit rights. Email them and ask for
commit rights (a sysadmin can add these), or send them your patch for
integration. If in doubt, post it on the <email>imp-dev@salilab.org</email>
mailing list.
</para>
</sect3>

</sect2>

<sect2 id="code-maturity">
<title>Code maturity</title>
<para>
IMP is a work shared by many developers, and they would prefer not to have
spend time working around problems introduced by others elsewhere in the code.
Therefore, it is expected that any code committed to IMP should at least
compile. Any test cases you write for your code should also be expected to
pass, or at least if they do not, you should quickly fix things so that they
do. (As a rule of thumb, your changes should not break the nightly builds
for more than 3 consecutive days; if they do, your changes risk being reverted.)
</para>

<para>
It is fine to add code to IMP that is not yet fully complete or ready for
others to use (provided that it compiles and tests, as above). However, any
such classes or methods should be marked in their Doxygen comments as
immature.
</para>

</sect2>

<sect2 id="bugs">
<title>Finding and fixing bugs in IMP</title>
<para>
If you find a bug in IMP, please report it on the
<ulink url="https://salilab.org/imp/bugs/">IMP bug tracker</ulink>. This will
ensure it does not get lost. The best way to report a bug is to provide a
short script file that demonstrates the problem.
</para>

<para>
If you create a patch which fixes a bug, please cite the bug ID in the commit
log for that patch. The patch should also include a testcase which triggers
the bug, so that we can ensure your fix for the bug does not break in future.
In many cases, the demonstration script in the bug report can be trivially
adapted into a test case.
</para>

</sect2>

</sect1>

</chapter>
