#!/usr/bin/python

import IMP
import IMP.saxs
import os
import re
import sys
import subprocess

def _run_binary(path, binary, args, out_file=None):
    if path:
        binary = os.path.join(path, binary)
    cmd = ' '.join([binary] + args)
    if out_file:
        stdout = open(out_file, 'w')
        cmd += ' > ' + out_file
    else:
        stdout = sys.stdout
    print cmd
    p = subprocess.Popen([binary] + args, stdout=stdout, stderr=sys.stderr)
    ret = p.wait()
    if ret != 0:
        raise OSError("subprocess failed with exit code %d" % ret)

def parse_args():
    parser = IMP.OptionParser(usage="%prog [options] <receptor_pdb> "
                                    "<ligand_pdb>",
                              description="Integrative pairwise docking using "
                                          "SAXS, EM2D, EM3D, CXMS and/or RTC "
                                          "data.",
                              imp_module=IMP.saxs)
    parser.add_option('--saxs', metavar='FILE', dest='saxs_file',
                      help="File name of the complex SAXS profile")
    parser.add_option('--em3d', metavar='FILE', dest='map_file',
                      help="File name of the complex density map in mrc format")
    parser.add_option('--em2d', metavar='FILE', action='append', default=[],
                      dest='class_averages',
                      help="File name of a complex 2D class average in PGM "
                           "format. This option can be repeated to use "
                           "multiple class averages (up to 5 in total)")
    parser.add_option('--cxms', metavar='FILE', dest='cross_links_file',
                      help="File name of the cross links file")
    parser.add_option('--receptor_rtc', metavar='FILE',
                      help="File name of the receptor NMR residue type content")
    parser.add_option('--ligand_rtc', metavar='FILE',
                      help="File name of the ligand NMR residue type content")
    choices=['EI', 'AA', 'other']
    parser.add_option('--complex_type', metavar='TYPE', type='choice',
                      dest="type", choices=choices,
                      help='/'.join(choices) + '; use this order for '
                           'receptor-ligand: '
                           'antibody-antigen, enzyme-inhibitor')
    parser.add_option('--pixel_size', type='float', default=0.,
                      help='Pixel size for EM2D images')
    parser.add_option('--saxs_receptor_pdb', metavar='FILE',
                      help='Additional receptor structure for SAXS scoring '
                           'with modeled missing atoms/residues. '
                           'This structure should be aligned to the '
                           'input receptor!')
    parser.add_option('--saxs_ligand_pdb', metavar='FILE',
                      help='Additional ligand structure for SAXS scoring '
                           'with modeled missing atoms/residues. '
                           'This structure should be aligned to the '
                           'input ligand!')
    parser.add_option('--patch_dock', metavar='DIR',
                      default=os.environ.get('PATCH_DOCK_HOME', None),
                      help='Directory where PatchDock tools are installed. '
                           'If not specified, the value of the PATCH_DOCK_HOME '
                           'environment variable is used if set, otherwise the '
                           'tools are assumed to be in the default path.')
    parser.add_option('--prefix', default='',
                      help='Add prefix string (separated by an underscore) '
                           'to filenames generated by the current run')
    parser.add_option('--precision', type='choice', choices=['1', '2', '3'],
                      default='1',
                      help='Sampling precision for rigid docking: 1-normal, '
                           '2-medium, 3-high. The higher the precision, the '
                           'higher are the run times')

    opts, args = parser.parse_args()
    if len(args) != 2:
        parser.error("incorrect number of arguments")
    opts.precision = int(opts.precision)
    if len(opts.class_averages) > 0 and opts.pixel_size <= 0.:
        parser.error("please specify pixel size for 2D images with "
                     "--pixel_size option")
    if opts.prefix:
        opts.prefix += '_'
    if not opts.saxs_file and not opts.map_file and not opts.class_averages \
       and not opts.cross_links_file and not opts.receptor_rtc \
       and not opts.ligand_rtc:
        parser.error("please provide one or more types of experimental data: "
                     "SAXS, EM3D, EM2D, CXMS or NMR residue type content")
    return opts, args

class Scorer(object):
    """Score transformations using a type of experimental data"""
    transformations_file = 'trans_pd'

    def __init__(self, idock, output_file):
        self.receptor = idock.receptor
        self.ligand = idock.ligand
        self.output_file = output_file

    def score(self, num_transforms):
        if os.path.exists(self.output_file) \
           and len(open(self.output_file).readlines()) >= num_transforms:
            print "Skipping %s for %s" % (str(self), self.receptor)
        else:
            self._run_score_binary()


class NMRScorer(Scorer):
    """Score transformations using NMR residue type content"""
    short_name = 'nmr_rtc'

    def __init__(self, idock):
        Scorer.__init__(self, idock, idock.get_filename("nmr_rtc_score.res"))
        self.receptor_rtc = idock.opts.receptor_rtc
        self.ligand_rtc = idock.opts.ligand_rtc
        if idock.opts.type == 'AA':
            self.receptor_rtc, self.ligand_rtc = self.ligand_rtc, '-'

    def __str__(self):
        return "NMR score"

    def _run_score_binary(self):
        _run_binary(None, "nmr_rtc_score",
                    [self.receptor, self.ligand, self.transformations_file,
                     self.receptor_rtc, self.ligand_rtc,
                     '-o', self.output_file])


class SAXSScorer(Scorer):
    """Score transformations using SAXS (rg + chi)"""
    short_name = 'saxs'

    def __init__(self, idock):
        Scorer.__init__(self, idock, idock.get_filename("saxs_score.res"))
        self.saxs_file = idock.opts.saxs_file
        self.saxs_receptor = idock.opts.saxs_receptor or idock.receptor
        self.saxs_ligand = idock.opts.saxs_ligand or idock.ligand

    def __str__(self):
        return "SAXS score"

    def _run_score_binary(self):
        _run_binary(None, "saxs_score",
                    [self.saxs_receptor, self.saxs_ligand,
                     self.transformations_file, self.saxs_file,
                     '-o', self.output_file])


class EM2DScorer(Scorer):
    """Score transformations using EM2D"""
    short_name = 'em2d'

    def __init__(self, idock):
        Scorer.__init__(self, idock, idock.get_filename("em2d_score.res"))
        self.class_averages = idock.opts.class_averages
        self.pixel_size = idock.opts.pixel_size

    def __str__(self):
        return "EM2D score"

    def _run_score_binary(self):
        _run_binary(None, "em2d_score",
                    [self.receptor, self.ligand, self.transformations_file] \
                    + self.class_averages \
                    + ['-o', self.output_file, '-n', '200', '-s',
                       str(self.pixel_size)])


class EM3DScorer(Scorer):
    """Score transformations using EM3D"""
    short_name = 'em3d'

    def __init__(self, idock):
        Scorer.__init__(self, idock, idock.get_filename("em3d_score.res"))
        self.map_file = idock.opts.map_file

    def __str__(self):
        return "EM3D score"

    def _run_score_binary(self):
        _run_binary(None, "em3d_score",
                    [self.receptor, self.ligand, self.transformations_file,
                     self.map_file, '-o', self.output_file, '-s'])


class CXMSScorer(Scorer):
    """Score transformations using CXMS"""
    short_name = 'cxms'

    def __init__(self, idock):
        Scorer.__init__(self, idock, idock.get_filename("cxms_score.res"))
        self.cross_links_file = idock.opts.cross_links_file

    def __str__(self):
        return "CXMS score"

    def _run_score_binary(self):
        _run_binary(None, "cross_links_score",
                    [self.receptor, self.ligand, self.transformations_file,
                     self.cross_links_file, '-o', self.output_file])


class IDock(object):
    """Handle all stages of the integrative docking protocol"""

    def __init__(self, opts, receptor, ligand):
        self.opts = opts
        self.receptor = receptor
        self.ligand = ligand

    def run_patch_dock_binary(self, binary, args):
        """Run a binary that is part of the PatchDock distribution"""
        _run_binary(self.opts.patch_dock, binary, args)

    def make_patch_dock_surfaces(self):
        """Make molecular surfaces for PatchDock"""
        self.run_patch_dock_binary('buildMS.pl', [self.receptor, self.ligand])

    def make_patch_dock_parameters(self):
        """Make parameter file for PatchDock"""
        if self.opts.precision == 1:
            rmsd = '4.0'
        else:
            rmsd = '2.0'
        if self.opts.precision == 3:
            script = 'buildParamsFine.pl'
        else:
            script = 'buildParams.pl'
        self.run_patch_dock_binary(script, [self.receptor, self.ligand, rmsd,
                                            self.opts.type])

    def get_filename(self, fn):
        """Get a filename, with user-defined prefix if given"""
        return self.opts.prefix + fn

    def get_all_scores_filename(self, scorers, prefix, suffix):
        """Get a filename containing the names of all scores used"""
        return self.get_filename(prefix \
                          + '_'.join([x.short_name for x in scorers]) + suffix)

    def do_patch_dock_docking(self):
        """Do PatchDock docking, using previously generated surfaces
           and parameter files"""
        out_file = self.get_filename('docking.res')
        # Skip if PatchDock output file exists and contains transformations
        # (not just the header containing parameter information)
        if os.path.exists(out_file) and len(open(out_file).readlines()) > 36:
            print "Skipping PatchDock for %s" % self.receptor
        else:
            self.run_patch_dock_binary('patch_dock.Linux',
                                       ['params.txt', out_file])

    def make_transformation_file(self):
        """Extract transformation image from PatchDock output file"""
        out_file = self.get_filename('docking.res')
        num_re = re.compile('\d')
        num_transforms = 0
        fout = open('trans_pd', 'w')
        for line in open(out_file):
            fields = line.split('|')
            if len(fields) > 1 and num_re.search(fields[0]):
                num_transforms += 1
                print >> fout, int(fields[0]), fields[-1].strip(' \r\n')
                if self.opts.precision == 1 and num_transforms >= 5000:
                    break
        return num_transforms

    def run_patch_dock(self):
        """Run PatchDock on the ligand and receptor"""
        self.make_patch_dock_surfaces()
        self.make_patch_dock_parameters()
        self.do_patch_dock_docking()
        num_transforms = self.make_transformation_file()
        # Swap ligand/receptor if we're doing AA
        if self.opts.type == 'AA':
            self.ligand, self.receptor = self.receptor, self.ligand
            self.opts.saxs_receptor_pdb, self.opts.saxs_ligand_pdb = \
                    self.opts.saxs_ligand_pdb, self.opts.saxs_receptor_pdb
        return num_transforms

    def get_scorers(self):
        """Set up and return a list of all applicable scorers"""
        scorers = []
        if self.opts.receptor_rtc or self.opts.ligand_rtc:
            scorers.append(NMRScorer(self))
        if self.opts.saxs_file:
            scorers.append(SAXSScorer(self))
        if self.opts.class_averages:
            scorers.append(EM2DScorer(self))
        if self.opts.map_file:
            scorers.append(EM3DScorer(self))
        if self.opts.cross_links_file:
            scorers.append(CXMSScorer(self))
        return scorers

    def get_filtered_scores(self, scorers):
        """Get scores that were filtered by an experimental method"""
        # If only one score, simply extract from its file
        if len(scorers) == 1:
            out_fh = open('trans_for_cluster', 'w')
            in_fh = open(scorers[0].output_file)
            for line in in_fh:
                spl = line.split('|')
                if '+' in line and '#' not in line and len(spl) > 1:
                    out_fh.write("%s %s %s" % (spl[0], spl[1], spl[-1]))
        else:
            out_file = self.get_all_scores_filename(scorers, 'combined_',
                                                    '.res')
            args = []
            for s in scorers:
                args.extend([s.output_file, '1.0'])
            _run_binary(None, 'combine_scores', args, out_file=out_file)
            out_fh = open('trans_for_cluster', 'w')
            in_fh = open(out_file)
            for line in in_fh:
                spl = line.split('|')
                if '#' not in line and len(spl) > 1:
                    out_fh.write("%s %s %s" % (spl[0], spl[1], spl[-1]))

    def get_clustered_transforms(self, scorers):
        """Cluster transformations with PatchDock"""
        out_file = self.get_all_scores_filename(scorers, 'clustered_', '.res')
        self.run_patch_dock_binary('interface_cluster.linux',
                                   [self.receptor + '.ms', self.ligand,
                                    'trans_for_cluster', '4.0', out_file])
        return out_file


def main():
    opts, args = parse_args()
    dock = IDock(opts, args[0], args[1])
    num_transforms = dock.run_patch_dock()
    scorers = dock.get_scorers()
    for scorer in scorers:
        scorer.score(num_transforms)
    dock.get_filtered_scores(scorers)
    dock.get_clustered_transforms(scorers)

if __name__ == "__main__":
    main()
